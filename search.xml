<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>02-面向对象，封装</title>
    <url>/2020/07/12/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><strong>面向对象</strong></h1><ol>
<li>类是抽象、具体的，是对象的模板，对象是类的实体。<br>成员变量（属性）+ 成员方法（行为）<br>成员方法没有static关键字<br>两个对象使用同一个方法内存图<br><img src="https://img-blog.csdnimg.cn/20200714151329227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;当一个对象作为参数，传参为对象的地址值。</li>
<li>· 局部变量，没有默认值。成员变量若没赋值，会有默认值，如下：<br><img src="https://img-blog.csdnimg.cn/2020071415141252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;· 局部变量位于栈内存，成员变量位于堆内存。<br>&emsp;· 局部变量随着方法进栈而产生，出栈消失；成员变量随着对象创建而产生，随着对象被垃圾回收而消失。</li>
</ol>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h1><ol>
<li>方法，关键字private都是封装性的体现</li>
<li>关键字this：谁在调用，this就代表谁<br>（关键字都是小写）</li>
<li>一个标准的类（Java Bean）包括四个组成部分：</li>
</ol>
<ul>
<li>成员变量用private修饰</li>
<li>构造一个无参数构造方法<br>自动生成（code中的generate，里面选择constructor，快捷键：alt+insert）</li>
<li>构造一个全参数构造方法<br>自动生成（code中的generate，里面选择constructor，快捷键：alt+insert）</li>
<li>为每个成员变量编写一对getter/setter方法<br>自动生成（code中的generate，快捷键：alt+insert）</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java面向对象与封装</tag>
      </tags>
  </entry>
  <entry>
    <title>05-继承，抽象</title>
    <url>/2020/07/14/05-%E7%BB%A7%E6%89%BF%EF%BC%8C%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>解决的问题：<font color = #F9000>共性抽取 </font></li>
<li>父类（基类/超类）；子类（派生类）<br>例如员工类-&gt;讲师类，助教类</li>
<li>特点：子类可以拥有父类“内容”；还可以拥有自己专属内容</li>
<li>定义格式：<br>public class 父类名{ }<br>public class 子类名 extends 父类名 { }</li>
<li>父类不知道子类，不能用子类中的数据。<br>如果成员对象重名：<br>直接通过子类对象访问成员变量：new对象时等号左边是谁，就优先用谁，没有则<strong>向上</strong>找。<br>间接通过成员方法访问成员变量：<br>重点看这个方法是属于谁的，则优先用谁的，没有则<strong>向上</strong>找。</li>
<li>局部变量：直接写成员变量名<br>本类的成员变量：this.成员变量名<br>父类的成员变量：super.成员变量名</li>
<li>访问成员方法重名：如果创建的对象是谁，就优先用谁，没有则<strong>向上</strong>找。</li>
<li>重写（Override）：继承关系中，方法名和参数列表【均一样】（覆盖，覆写）<br>重载（Overload）：方法名一样，参数列表不一样</li>
<li>覆盖重写的特点：创建的是子类对象，则优先使用子类方法</li>
<li>覆盖重写的注意事项：<ol>
<li>必须保证方法名和参数列表【均一样】<br>@Override：写在子类覆盖重写方法前面，用来检测是不是有效的正确覆盖重写。（@为注解）<br>(这个可以不写，只是一个安全检测手段)</li>
<li>子类方法的返回值必须【小于等于】父类方法的返回值范围。<br>java.lang.Object是所有类的公共最高父类，java.lang.String就是Object的子类。所以如果父类返回值为Object，那么子类可以为String</li>
<li>子类方法的权限必须【大于等于】父类方法的权限修饰符<br>补充：从大到小：public&gt;protected&gt;(default)&gt;private<br>(default)什么都不写，为空</li>
</ol>
</li>
<li>设计原则：对于已经投入使用的类，<strong>尽量不要进行修改</strong>。推荐规定一个新类，来重复利用其中共性内容，并添加改动新内容。</li>
<li>继承关系中，父类构造方法的访问特点：</li>
<li>子类构造方法中，有一个默认隐含的“super()”调用父类无参构造方法。所以一定是先调用父类构造，后执行子类构造。</li>
<li>子类构造可以通过super关键字调用父类重载构造。</li>
<li>只有子类构造方法才能调用父类构造方法。super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</li>
<li>this和super关键字：<br><img src="https://img-blog.csdnimg.cn/20200714155541195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>Java语言是单继承的，直接父亲只有一个</li>
</ol>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ol>
<li>抽象方法：如果父类中的方法不确定如何进行方法实现，并不具体，那么这个方法为抽象方法。<br>void之前加上abstract关键字，然后去掉大括号，直接分号结束<br>抽象类：抽象方法所在的类，必须为抽象类，在class之前加上abstract</li>
<li>使用：<br> 1.不能直接创建new对象<br> 2.必须用一个子类来继承抽象父类<br> 3.子类必须覆盖重写父类【所有】抽象方法<br> 理解：如果一个父类（A类）有两个抽象方法，他的子类（B类）只重写了其中一个抽象方法，那么B类依旧是抽象类，不能直接使用。需要再写一个B类的子类（C类），将剩下的抽象方法实现，这时候C类不需要加上abstract。可以直接new使用。<br> 4.创建子类对象进行使用</li>
<li>注意事项：<br> 1.抽象类中，可以有构造方法，是供子类构造方法中super();使用的。<br> <mark>alt+回车：选择第一个：告诉你需要覆盖重写的方法</mark><br> 2.抽象类中不一定有抽象方法（适配器模式）<br> 3.抽象类不可以直接new对象</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>抽象</tag>
      </tags>
  </entry>
  <entry>
    <title>03-API，Scanner，Random，ArrayList类</title>
    <url>/2020/07/13/03-API%EF%BC%8CScanner%EF%BC%8CRandom%EF%BC%8CArrayList%E7%B1%BB/</url>
    <content><![CDATA[<ol>
<li>API 应用程序编程接口，就是一些现成的类。<br>API文档：看包路径，构造方法，方法。</li>
<li>引用类型的基本使用步骤：</li>
</ol>
<ul>
<li>导包 import 包路径.类名称；<br>如果需要使用的目标类，和当前类位于同一个包下，可以省略包语句不写；<br>只有java.lang下的内容不需要导包。</li>
<li>创建<br>类名 对象名 = new 类名()；</li>
<li>使用<br>对象名.成员方法名()；<br>E.g <strong>使用Scanner</strong>：</li>
<li>import java.util.Scanner;     </li>
<li>Scanner sc = new Scanner(System.in); // 从键盘输入</li>
<li>int num = sc.nextInt(); // 获取键盘输入的int数字<br>String str = sc.next(); // 获取键盘输入的字符串</li>
</ul>
<p><strong>使用Random</strong>：</p>
<ul>
<li>import java.util.Random;</li>
<li>Random r = new Random();</li>
<li>int number = r.nextInt(10)；// 随机生成一个[0, 10) 间数据</li>
</ul>
<p><strong>使用ArrayList</strong>：（一个大小可变的数组）</p>
<ul>
<li>java.util.ArrayList</li>
<li>ArrayList <E> a = new ArrayList &lt;&gt;();<br>(E可以为数组、类名、接口任意<font color = #F9000><strong>引用类型</strong></font>)</li>
<li>public boolean add(E e) // 添加元素<br>public E remove(int index) // 删除下标为index的元素，并返回该元素<br>public E get(int index) // 获得下标为index的元素，并返回该元素<br>public int size() // 返回此集合中的元素数<br>存储基本数据类型不行，但是我们可以存取包装类：<br><img src="https://img-blog.csdnimg.cn/20200714151933376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<ol start="3">
<li>一个匿名对象只能使用一次，还可以作为参数和返回值<br><img src="https://img-blog.csdnimg.cn/20200714155541195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>Java语言是单继承的，直接父亲只有一个</li>
</ol>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ol>
<li>抽象方法：如果父类中的方法不确定如何进行方法实现，并不具体，那么这个方法为抽象方法。<br>void之前加上abstract关键字，然后去掉大括号，直接分号结束<br>抽象类：抽象方法所在的类，必须为抽象类，在class之前加上abstract</li>
<li>使用：<ol>
<li>不能直接创建new对象</li>
<li>必须用一个子类来继承抽象父类</li>
<li>子类必须覆盖重写父类【所有】抽象方法<br>理解：如果一个父类（A类）有两个抽象方法，他的子类（B类）只重写了其中一个抽象方法，那么B类依旧是抽象类，不能直接使用。需要再写一个B类的子类（C类），将剩下的抽象方法实现，这时候C类不需要加上abstract。可以直接new使用。</li>
<li>创建子类对象进行使用</li>
</ol>
</li>
<li>注意事项：<ol>
<li>抽象类中，可以有构造方法，是供子类构造方法中super();使用的。<br><mark>alt+回车：选择第一个：告诉你需要覆盖重写</mark></li>
<li>抽象类中不一定有抽象方法（适配器模式）</li>
<li>抽象类不可以直接new对象</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>04-String类,static,Arrays类</title>
    <url>/2020/07/13/04-String%E7%B1%BB%EF%BC%8Cstatic%EF%BC%8CArrays%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ol>
<li><font color = #F9000>字符串常量</font>，内容不可以改变。可以共享使用<br>程序中只有直接写上双引号字符串，才在字符串常量池中<br><img src="https://img-blog.csdnimg.cn/20200714152227142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>三种构造：<br><img src="https://img-blog.csdnimg.cn/20200714152254781.png" alt="在这里插入图片描述"><br> <font color = #F9000>按住CTRL键，去点击类名称（String），看源码。</font> String底层是靠字符数组实现的。<br> 一种直接创建：String str4 = “hello”;</li>
<li>方法：</li>
</ol>
<ul>
<li>public boolean equals (Object anObject) // 只有参数是字符串且内容相同（区分大小写），返回true。<br>如果要与双引号字符串比较，推荐把常量放到前面。</li>
<li>public boolean equalsIgnoreCase (String anotherString) // 字符串与另一字符串是否相同，不区分英文大小写</li>
<li>public int length () // 字符串长度</li>
<li>public String concat (String str) // 将参数字符串拼接到当前字符串尾，返回新字符串<br>（也可以用“+”）</li>
<li>public char charAt (int index) // 返回指定索引处的字符</li>
<li>public int indexOf (String str) // 返回参数字符串第一次出现在该字符串内的索引，如果没有返回-1<br>截取方法</li>
<li>public String substring (int beginIndex) // 从参数位置一直到末尾，返回新字符串（包括参数位置）</li>
<li>public String substring (int beginIndex, int endIndex) // 返回[beginIndex, endIndex)中间的子字符串<br>转换方法</li>
<li>public char[] toCharArray () // 拆分为字符数组返回</li>
<li>public byte[] getBytes () // 获取当前字符串底层的字节数组</li>
<li>public String replace (CharSequence oldString, CharSequence newString)  // 将所有出现的老字符串转换成新的字符串，返回新字符串 （CharSequence：可以接受字符串类型）<br><font color = #F9000>ctrl+n 输入“string”-&gt; ctrl+n 也可以打开源代码  </font><br>分割方法</li>
<li>public String[] split(String regex) // 按照参数规则，将字符串切割成若干部分。<br>参数是一个正则表达式，用“.”进行区分，用“\.”<br><font color = #F9000>Alt+回车，选择第一项：对一个对象进行new</font><br>e.g<br><img src="https://img-blog.csdnimg.cn/20200714152423734.png" alt="在这里插入图片描述"></li>
</ul>
<h2 id="static静态关键字"><a href="#static静态关键字" class="headerlink" title="static静态关键字"></a>static静态关键字</h2><ol>
<li>一旦用了static关键字，这样的内容<strong>属于类</strong>，只要是本类对象，共享同一份。</li>
<li>修饰成员变量时，该变量称为类变量。通过类名称进行调用：<br>Student.room = “101教室”;</li>
<li>当 static  修饰成员方法时，该方法称为<strong>类方法</strong> ，也称<strong>静态方法</strong>。静态方法不属于对象，也属于类的。<br>如果有static，那么不需要创建对象，直接通过类名称来使用它。</li>
<li>推荐写：</li>
</ol>
<ul>
<li>类名称.静态方法名()  // 对于本来当中的静态方法，可以省略类名称</li>
<li>类名称.静态变量</li>
</ul>
<ol start="5">
<li>注意事项：</li>
</ol>
<ul>
<li>成员方法可以访问成员变量和静态变量</li>
<li>静态方法只能访问静态变量，<font color = #F9000>不能直接访问成员变量</font><br><font color = #F4500>（原因：在内存中【先】有静态内容，【后】有非静态内容）</font></li>
<li>静态方法中不能用this<br>原因：this代表当前对象，但是静态方法中不用对象。</li>
</ul>
<ol start="6">
<li>static内存图<br><img src="https://img-blog.csdnimg.cn/20200714152704365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>静态代码块<br>public class 类名称  {<br>static {<br>// 静态代码块内容<br>}<br>}<br>特点：当第一次用于本类时，静态代码块执行唯一一次。<br>用处：用来一次性对静态成员变量赋值</li>
</ol>
<h2 id="数组工具类Arrays"><a href="#数组工具类Arrays" class="headerlink" title="数组工具类Arrays"></a>数组工具类Arrays</h2><ol>
<li>Java.util.Arrays，里面提供大量静态方法，用于实现数组常见操作</li>
<li>方法：</li>
</ol>
<ul>
<li>public static String toString(数组)  //将参数数组变成字符串，按照默认格式：[元素1，元素2……]</li>
<li>public static void sort(数组) // 默认排序效果为升序 ，如果是自定义的类型，需要有Comparable或者Comparator接口的支持</li>
</ul>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><ol>
<li>java.lang.Math，里面提供大量静态方法，完成与数学运算相关的操作</li>
<li>方法：</li>
</ol>
<ul>
<li>public static double abs(double a)  // 返回 double 值的绝对值，有多种重载</li>
<li>public static double ceil(double a) // 向上取整</li>
<li>public static double floor(double a) // 向下取整</li>
<li>public static long round(double a) // 四舍五入</li>
<li>Math.PI 代表圆周率</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>06-接口与多态</title>
    <url>/2020/07/14/06-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ol>
<li><p>接口就是一种<font color = #F9000>公共的规范标准</font>。接口是一种引用数据结构，最重要内容是其中的<font color = #F9000>抽象方法</font></p>
</li>
<li><p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">        <span class="comment">// 接口内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：<br> 1.接口不能有静态代码块和构造方法<br> 2.一个类可以同时实现多个接口 implements FuAI, FuBI，…<br> 3.如果实现类所实现的抽象方法在几个接口中重名，那么只需要覆盖重写一次这个方法<br> 4.如果覆盖重写没有覆盖全部的方法，这个类必须是抽象类<br> 5.对多个接口中冲突的默认方法（名字一样方法体不同）<font color = #F9000>一定要覆盖重写</font><br> 6.一个类直接父类当中的方法和接口中默认方法产生了冲突，优先使用父类中的方法。<font color = #F9000>java中，继承优先于接口实现</font>。<br> 7.接口与接口之间实现多继承。一个接口可以extends多个接口<br> 8.多个父类接口默认方法重复，子接口必须进行默认方法的覆盖重写【带default关键字】<br> 9.多个父类接口抽象方法重复，没关系</p>
</li>
<li><p>换成关键字interface之后，编译生成的字节码文件仍然是：.java –&gt;.class<br>如果是Java 7，那么接口中可以包含内容有：<br> 1.常量<br> 2.<font color = #F9000><strong>抽象方法</strong></font><br> Java 8，额外包含：<br> 3.默认方法<br> 4.静态方法<br> Java 9，额外包含：<br> 5.私有方法</p>
</li>
</ol>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ol>
<li><p>定义格式：<br><font color = #F9000><strong>public abstract</strong></font> 返回值类型 方法名称(参数列表);<br>注意事项：<br>public abstract 这两个关键词可以选择性省略（部分或者全部）<br>方法三要素可以随意进行选择</p>
</li>
<li><p>接口使用步骤：<br> 1.<font color = #F9000>不能直接使用</font>，必须要有一个“实现类”来“实现”该接口<br> 格式：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类名称 <span class="keyword">implements</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 2.接口实现类必须覆盖重写（实现）接口中所有的抽象方法<br> <mark>（alt+回车）</mark><br> 实现：去掉abstract关键字，加上方法体大括号<br> 跟继承相似，如果覆盖重写没有覆盖全部的方法，这个类必须是抽象类。</p>
</li>
<li><p>创建实现类的对象，进行使用</p>
</li>
</ol>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><ol>
<li>定义格式： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 public可以省略不写，但是不能改别的</li>
<li>接口中的默认方法，解决接口升级的问题</li>
<li>调用默认方法，如果实现类中没有，就会向上找接口</li>
<li>接口实现类可以直接调用默认方法，也可以覆盖重写<br><font color = green>理解：如果接口升级，新增了方法，那么实现这个接口的“实现类”就会报错。为了不报错而且接口实现类不用改，就能使用新添加的这个方法，我们让这新增的方法带有默认方法体。这样的方法就叫做默认方法。</font></li>
</ol>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ol>
<li>定义格式： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用：<br> 通过接口名称，直接调用其中的静态方法</li>
<li>强调：<br> 不能通过接口实现类的对象来调用接口当中的静态方法</li>
<li>问题描述：我们需要抽取一个公共方法，来解决两个默认方法（静态方法）之间重复代码问题，但这个共有方法不应该让实现类使用，应该是私有的。<br> 解决：<br> Java9开始，接口中允许定义私有方法。<br> 1.普通私有方法，解决<strong>多个默认方法之间</strong>重复代码问题 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 2.静态私有方法，解决<strong>多个静态方法之间</strong>重复代码问题 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ol>
<li>效果上看，可以当成是接口中的 ‘成员变量’，但必须使用public static final进行修饰。不可改变</li>
<li>格式：<br> public static final 数据类型 常量名称 = 数据值;</li>
<li>一旦使用final进行修饰，不可改变。</li>
<li>注意事项：<br> 1.可以省略全部或部分修饰词，但不写也是照样<br> 2.接口中的常量必须进行赋值<br> 3.接口中的常量名称，使用全部大写，下划线分隔</li>
</ol>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><ol>
<li><p>代码体现：父类引用指向子类对象</p>
</li>
<li><p>格式：<br> 父类名称 对象名 = new 子类名称();<br> 接口名称 对象名 = new 实现名称();</p>
</li>
<li><p>多态中成员变量的使用特点：<br> 1.直接通过对象名称访问成员变量：看等号<font color = #F9000>左边是谁</font>，优先用谁，否则向上找<br> <font color = green>思考：左边是父类，所以不能访问子类成员变量</font><br> 2.间接通过成员方法访问成员变量：看该方法<font color = #F9000>属于谁</font>，优先用谁，否则向上找<br> <font color = green>思考：如果有，子类如果覆盖重写，就用子类，否则用父类。</font><br> <font color = #F9000>编译看左边，运行看左边</font></p>
</li>
<li><p>多态中成员方法的使用特点：<br> 看<font color = #F9000>new的是谁</font>，就优先用谁，没有则向上找</p>
<p> <font color = #F9000>编译看左边，运行看右边</font><br> 编译可以把.java源代码翻译成.class源代码。如<code>Obj.methodZi();</code>中<code>methodZi</code>红色，看左边，发现是Fu类，里面并没有这个方法，所以报错</p>
</li>
<li><p>多态的好处：<br> 无论右边new的时候换成哪个子类对象，等号左边调用方法都不会改变。不关心等号左边new的是谁。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Employee one &#x3D; new Teacher();</span><br><span class="line">one.work(); &#x2F;&#x2F; 讲课</span><br><span class="line">Employee two &#x3D; new Assistant();</span><br><span class="line">two.work(); &#x2F;&#x2F; 辅导</span><br></pre></td></tr></table></figure></li>
<li><p>对象的向上转型，其实就是多态写法<br> 格式：父类名称 对象名 = new 子类名称();<br> 含义：右侧创建一个子类对象，当作父类看待使用</p>
<blockquote>
<p>向上转型一定是安全的。从小范围转换成为更大范围。（类似于int-&gt;double，自动类型转换）<br>一旦转型为父类，不能调用子类原本特有的内容</p>
</blockquote>
</li>
<li><p>对象的向下转型，其实是一个<font color = #F9000>【还原】</font>动作<br> 格式：子类名称 对象名 = (子类名称)父类对象；<br> 含义：将父类对象【还原】成为本来的子类对象</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animal animal &#x3D; new Cat(); &#x2F;&#x2F; 本来是猫，向上转型为动物</span><br><span class="line">Cat cat &#x3D; (Cat)animal； &#x2F;&#x2F; 向下转型只能还原成为本来的猫</span><br></pre></td></tr></table></figure>
<p> 如果向下转型成不是本来的子类，会报错classcastException</p>
<blockquote>
<p>如何知道一个父类引用的对象，本来是什么子类？<br>格式： 对象 instanceof 类名称<br>这会得到一个Boolean值，判断前面的对象能不能当作后面类型的实例。例如：<br>if(animal instanceof Cat)</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>接口</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>07-final，权限，内部类，引用类型</title>
    <url>/2020/07/17/07-final%EF%BC%8C%E6%9D%83%E9%99%90%EF%BC%8C%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h1><blockquote>
<p>final代表最终、不可改变的<br>可以修饰一个类<br>修饰一个方法<br>修饰一个局部变量<br>修饰一个成员变量</p>
</blockquote>
<p>1.修饰一个类时，格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class 类名称 &#123;</span><br><span class="line">	&#x2F;&#x2F;···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>含义：final类为太监类，不能有<strong>子类</strong><br>注意：一个类为final，所有成员方法都无法进行覆盖重写</p>
<p>2.修饰一个方法时，格式：<br>修饰符 final 返回值类型 方法名称(参数列表) {<br>    // 方法体<br>}<br>含义：最终方法，不能被覆盖重写<br>注意：对类、方法来说，abstract和final不能同时使用，矛盾</p>
<p>3.修饰一个局部变量<br>格式：只能赋值一次，不可改变 </p>
<blockquote>
<p>对<font color = #F9000>基本类型</font>来说，不可变说的是变量中的数据不可变<br>格式：final 数据类型 变量名称 = 字面量；<br>对<font color = #F9000>引用类型</font>来说，不可变说的是的变量中的地址值不可变<br>例如：final Student stu1 = new  Student(“高圆圆”);<br>stu1 = new  Student(“高圆”); // 错误，地址值不能变<br>stu1.setName(“高”); // 正确<br>stu1的地址值不能变，但地址所指向的对象可以改变</p>
</blockquote>
<p>4.修饰成员变量<br>含义：如果使用final修饰，那么这个变量也不可变<br>注意：</p>
<ol>
<li>由于成员变量具有默认值，所以用了final之后之后一定要手动赋值</li>
<li>对于final成员变量，那么使用直接复制，要么通过构造方法赋值（2选1） </li>
<li>必须保证类中所有重载的构造方法，都会最终会对final的成员变量进行赋值</li>
</ol>
<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>1.java中四种权限修饰符<br><img src="https://img-blog.csdnimg.cn/20200717142821884.png" alt="在这里插入图片描述"></p>
<p>2.java中只要不是在一个包中就要导包。一个包里面创建一个子包，也不属于同一个包。</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><pre><code>如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类</code></pre><p>分类：</p>
<ol>
<li>成员内部类</li>
<li>局部内部类（包含匿名内部类）</li>
</ol>
<p>注意：内用外，随便访问，外用内，需要内部类对象。</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>· 定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 class 外部类名称 &#123;</span><br><span class="line">  修饰符 class 内部类名称 &#123;</span><br><span class="line">    &#x2F;&#x2F;…</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，内部类名称为”外部类名称$内部类名称.class” ，所以定义类名称时候虽然标识符能用下划线和$符号，尽量不要用$符号，以免产生误解。<br>使用：</p>
<ol>
<li>间接方式：在外部类的方法中，(创建内部类对象)，使用内部类；然后main只是调用外部类的方法</li>
<li>直接方式：<br>类名称  对象名 = new 类名称();<br><font color = #F9000>【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】</font><br>· 先有外部类才能有内部类</li>
</ol>
<p>· 如果出现了重名对象，格式为：外部类名称.this.外部类成员变量名</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>如果一个类是定义在一个方法内部的，出来这个方法在外面就不能使用了。<br>定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 class 外部类名称 &#123;</span><br><span class="line">  修饰符 返回值类型 外部类方法名称(参数列表) &#123;</span><br><span class="line">    class 局部内部类名称 &#123;</span><br><span class="line">      &#x2F;&#x2F;…</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ···</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>· 局部内部类，如果希望访问所在方法的局部变量，这个局部变量必须是【有效final】的。（Java8开始，只要保证变量未变，final关键字也可以省略）<br> 原因：（生命周期问题）</p>
<ol>
<li>new出来的对象在堆当中</li>
<li>局部变量是跟着方法走的，在栈当中</li>
<li>方法运行结束之后，立刻出栈，局部变量就会立刻消失</li>
<li>但是new出来的对象会在堆当中持续存在，直到垃圾回收消失</li>
<li>当局部内部类中想要用方法的局部变量，只要保证值不变，就直接复制一份进来成常量，之后就用常量池里的常量<blockquote>
<p>定义一个类的时候，权限修饰符规则：</p>
</blockquote>
</li>
<li>外部类：public / （default）</li>
<li>成员内部类：public / protected / （default）/ private</li>
<li>局部内部类：什么都不能写</li>
</ol>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>如果接口的实现类，或者是父类的子类，只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改用【匿名内部类】</p>
<p>· 定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接口名称 对象名 &#x3D; new 接口名称() &#123;</span><br><span class="line">  &#x2F;&#x2F; 覆盖重写所有抽象方法</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>· 解析：</p>
<ol>
<li>new代表创建对象的动作</li>
<li>接口名称是匿名内部类需要实现哪个接口</li>
<li>{···}才是匿名内部类的内容<br>· 注意：</li>
<li>匿名内部类，在【创建对象】的时候，只能使用唯一一次</li>
<li>匿名对象，在【调用方法】的时候，只能调用唯一一次，要多次必须起名</li>
<li>匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】</li>
</ol>
<p><font color = #F9000>所以匿名内部类，匿名对象不是一回事</font></p>
<h3 id="引用类型用法总结"><a href="#引用类型用法总结" class="headerlink" title="引用类型用法总结"></a>引用类型用法总结</h3><ol>
<li>类可以作为成员变量类型</li>
<li>接口也可以作为成员变量类型</li>
<li>接口作为方法的参数和返回值</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>final</tag>
        <tag>权限</tag>
        <tag>内部类</tag>
        <tag>引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>10-List，Set，数据结构，Collections</title>
    <url>/2020/08/03/10-List%EF%BC%8CSet%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8CCollections/</url>
    <content><![CDATA[<h2 id="第一章-数据结构"><a href="#第一章-数据结构" class="headerlink" title="第一章 数据结构"></a>第一章 数据结构</h2><p><strong>常用数据结构</strong>：</p>
<ol>
<li>栈结构：先进后出</li>
<li>队列：先进先出</li>
<li>数组：查询快，增上慢。<br>注：在堆内存中，频繁创建数组复制数组中的元素，销毁数组，效率低下。</li>
<li>链表：查询慢，增删快。<br>单向链表：一条链，不能保证元素顺序（存储/取出元素顺序）【无序】<br>双向链表：两条链，有一条是专门记录元素的顺序【有序】</li>
<li>红黑树<br>特点：趋近于平衡树，<font color = #F9000>查询速度非常快</font>，查询叶子节点最大次数和最小次数不能超过2倍。<br>约束：<br> 1.节点可以是红色或黑色<br> 2.根节点是黑色的<br> 3.叶子节点必须是黑色的<br> 4.每个红色的节点的子节点都是黑色的<br> 5.任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同<br><img src="https://img-blog.csdnimg.cn/20200806091710223.png" alt="在这里插入图片描述"></li>
</ol>
<h2 id="第二章-List集合"><a href="#第二章-List集合" class="headerlink" title="第二章 List集合"></a>第二章 List集合</h2><pre><code>java.util.List 接口继承自 Collection 接口</code></pre><p>· 特点：<br>    1. 有序的集合（存储、取出元素顺序相同）<br>    2. 有索引，包含了一些带索引的方法<br>    3. 允许存储重复元素<br>· List接口中带索引的方法（特有）</p>
<ul>
<li><code>public void add(int index, E element)</code> : 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code> :用指定元素替换集合中指定位置的元素,返回值的更新前的元素。<br>  注：使用索引，防止索引越界异常<br>  IndexOutOfBoundException：索引异常，集合会报<br>  ArrayIndexOutOfBoundException：数组索引异常<br>  StringIndexOutOfBoundException：字符串索引异常</li>
</ul>
<h3 id="2-1-List的实现类"><a href="#2-1-List的实现类" class="headerlink" title="2.1 List的实现类"></a>2.1 List的实现类</h3><h4 id="2-1-1ArrayList集合"><a href="#2-1-1ArrayList集合" class="headerlink" title="2.1.1ArrayList集合"></a>2.1.1ArrayList集合</h4><p>· List接口的大小可变<strong>数组</strong>的实现。即底层是一个<font color = #F9000>数组结构</font>。查询快，增删慢。<br>· 此实现不是同步的。<br>注：<font color = #F9000>不是同步的，就是多线程的。</font>多线程速度效率高。</p>
<h4 id="2-1-2-LinkedList集合"><a href="#2-1-2-LinkedList集合" class="headerlink" title="2.1.2 LinkedList集合"></a>2.1.2 LinkedList集合</h4><pre><code>`java.util.LinkedList` 集合 implements List接口</code></pre><p>· <strong>特点</strong>：</p>
<ol>
<li>底层是一个<font color = #F9000>链表结构</font>。查询慢，增删快 </li>
<li>此实现不是同步的</li>
<li>里面包含了大量操作首位元素的方法<br>注：使用该集合特有的方法，不能使用多态。</li>
</ol>
<p>-<code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。<br>-<code>public void addLast(E e)</code> :将指定元素添加到此列表的结尾。【与add()方法等效】<br>-<code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。【与addFirst()等效】</p>
<p>-<code>public E getFirst()</code> :返回此列表的第一个元素。<br>-<code>public E getLast()</code>:返回此列表的最后一个元素。<br>（如果没有元素，报错NoSuchElementException，可用isEmpty()进行判断）</p>
<p>-<code>public E removeFirst()</code>:移除并<strong>返回</strong>此列表的第一个元素。<br>-<code>public E removeLast()</code>:移除并<strong>返回</strong>此列表的最后一个元素。<br>-<code>public E pop() :</code>从此列表所表示的堆栈处弹出一个元素。<br>【与 removeFirst()等效】</p>
<p>-<code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</p>
<h4 id="2-1-3-Vector集合"><a href="#2-1-3-Vector集合" class="headerlink" title="2.1.3 Vector集合"></a>2.1.3 Vector集合</h4><p>· 底层是一个<strong>数组</strong>。开始于JDK1.0，是所有单列集合的祖宗。<br>· 同步的，意味着是单线程的，速度慢。所以1.2版本后被ArrayList<strong>取代</strong><br>第三章 Set接口<br>    <code>java.util.Set</code> 接口 extends <code>Collection</code> 接口<br>· 特点：</p>
<ol>
<li>不允许存储重复元素</li>
<li>没有索引，没有带索引的方法，也不能使用普通的for循环遍历</li>
</ol>
<h2 id="第三章-Set接口"><a href="#第三章-Set接口" class="headerlink" title="第三章 Set接口"></a>第三章 Set接口</h2><h3 id="3-1-Set接口的实现类："><a href="#3-1-Set接口的实现类：" class="headerlink" title="3.1 Set接口的实现类："></a>3.1 Set接口的实现类：</h3><h4 id="3-1-1-HashSet集合"><a href="#3-1-1-HashSet集合" class="headerlink" title="3.1.1 HashSet集合"></a>3.1.1 HashSet集合</h4><pre><code>`java.util.HashSe`t  implement  `Set` 接口</code></pre><p>· <strong>特点</strong>：</p>
<ol>
<li>不允许存储重复元素</li>
<li>没有索引，没有带索引的方法，也不能使用普通的for循环遍历<br>（可以使用迭代器遍历，增强for遍历）</li>
<li>无序集合，存储、取出元素顺序有可能不一致</li>
<li>底层是一个<font color = #F9000>哈希表结构</font>，查询速度很快</li>
<li>此实现不同步 </li>
</ol>
<h4 id="3-1-2-HashSet集合存储数据的结构-哈希表"><a href="#3-1-2-HashSet集合存储数据的结构-哈希表" class="headerlink" title="3.1.2 HashSet集合存储数据的结构(哈希表)"></a>3.1.2 HashSet集合存储数据的结构(哈希表)</h4><p><strong>哈希值</strong><br>    一个<strong>十进制整数</strong>，没有重写由系统<strong>随机给出</strong>（就是<strong>对象的地址</strong>，是<strong>逻辑地址</strong>，不是实际存储的物理地址）<br>· 在Object类中有个方法，可以获取该对象的哈希值。</p>
<ul>
<li><code>int hashCode()</code> </li>
<li>方法源码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure>
注：<code>native</code>：代表该方法调用的是本地操作系统的方法</li>
<li>可以在对象中重写该方法，这时候，尽管对象的地址值相同（可以直接输出对象实例来查看），但是“==”判断是false。因为<strong>实际物理地址</strong>是不同的。</li>
<li>String类重写了Object类的hashCode方法。字符串相同，哈希值相同。但是字符串不相同，哈希值可能相同。<br>e.g “abc”：96354； “重地”，“通话”：1179395<br>· <strong>哈希冲突</strong>：两个元素不同，但是哈希值相同</li>
</ul>
<p><strong>哈希表</strong></p>
<ul>
<li><p>JDK1.8之前，哈希表=数组+链表<br>JDK1.8之后：<br>&emsp;哈希表=数组+红黑树; （提高查新速度）<br>&emsp;哈希表=数组+链表</p>
</li>
<li><p><strong>数组结构</strong>把元素进行分组，相同哈希值的元素是一组，<strong>链表/红黑树结构</strong>把相同哈希值的元素链接在一起。<br>数组的初始容量为16。</p>
</li>
<li><p>存储数据到集合中：<br>  1）计算元素哈希值<br>  2）先分组，再下挂。<br>  <img src="https://img-blog.csdnimg.cn/20200806092433407.png" alt="在这里插入图片描述"></p>
</li>
<li><p>JDK1.8之后，如果下挂的元素超过了8位，就会把链表转化为<font color = #F9000>红黑树结构</font>。为了提高查询速度<br>  <img src="https://img-blog.csdnimg.cn/2020080609253255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="3-1-3-Set集合不允许存储重复元素的原理"><a href="#3-1-3-Set集合不允许存储重复元素的原理" class="headerlink" title="3.1.3 Set集合不允许存储重复元素的原理"></a>3.1.3 Set集合不允许存储重复元素的原理</h4><p>· <font color = green>前提: 存储的元素必须重写<code>hashCode方法</code>和<code>equals方法</code></font><br>· 过程：<br>e.g<br><img src="https://img-blog.csdnimg.cn/20200806092600403.png" alt="在这里插入图片描述"><br>· <code>set.add(s1);</code></p>
<ul>
<li>add()方法会调用要存储对象“s1”的<code>hasCode</code>方法，<font color = #F9000>计算</font>字符串“abc”的<font color = #F9000>哈希值</font>是96354</li>
<li>在集合中找是否有96354这个哈希值的元素，发现<font color = #F9000>没有</font></li>
<li>把s1<font color = #F9000>存储</font>到集合中</li>
</ul>
<p>· <code>set.add(s2);</code></p>
<ul>
<li>add()方法会调用要存储对象“s2”的<code>hasCode</code>方法，<font color = #F9000>计算</font>字符串“abc”的<font color = #F9000>哈希值</font>是96354</li>
<li>在集合中找是否有96354这个哈希值的元素，发现有</li>
<li>s2会<font color = #F9000>调用equals方法</font>和哈希值相同的元素进行比较<code>s2.equals(s1);</code>，返回true</li>
<li>两个元素<font color = #F9000>哈希值相等</font>，还返回了<font color = #F9000>true</font>，认定<font color = #F9000>两个元素相同</font></li>
<li><font color = #F9000>不会</font>把s2存储到集合中。</li>
</ul>
<p>· <code>set.add(&quot;重地&quot;);</code></p>
<ul>
<li>add()方法会调用要存储对象“重地”的<code>hasCode</code>方法，<font color = #F9000>计算</font>字符串“重地”的<font color = #F9000>哈希值</font>是1179395</li>
<li>在集合中找是否有1179395这个哈希值的元素，发现<font color = #F9000>没有</font></li>
<li>把”重地”<font color = #F9000>存储</font>到集合中</li>
</ul>
<p>·  <code>set.add(&quot;通话&quot;);</code></p>
<ul>
<li>add()方法会调用要存储对象“通话”的<code>hasCode</code>方法，<font color = #F9000>计算</font>字符串“通话”的<font color = #F9000>哈希值</font>是1179395</li>
<li>在集合中找是否有1179395这个哈希值的元素，发现<font color = #F9000>有</font></li>
<li>“通话”会<font color = #F9000>调用equals方法</font>和哈希值相同的元素进行比较<code>&quot;通话&quot;.equals(&quot;重地&quot;);</code>，返回<font color = #F9000>false</font></li>
<li>两个元素哈希值相等，还返回了false，认定<font color = #F9000>两个元素不同</font></li>
<li>就会把”通话”<font color = #F9000>存储</font>到集合中<br><img src="https://img-blog.csdnimg.cn/20200806092946793.png" alt="在这里插入图片描述"></li>
</ul>
<h4 id="3-1-4-HashSet存储自定义类型元素"><a href="#3-1-4-HashSet存储自定义类型元素" class="headerlink" title="3.1.4 HashSet存储自定义类型元素"></a>3.1.4 HashSet存储自定义类型元素</h4><p>· 要求：之前存储的String、Integer等，已经重新了hashCode和equals方法。如果要存储自定义类型元素，必须要自己重写这两个方法。<br>【<mark>IDEA中，alt+insert进行重写</mark>】<br>· 没有重写hashCode方法，两个相同的元素，哈希值也不同，所以equals返回的也是false。（没有重写，比较的是地址值）</p>
<h3 id="3-2-LinkedHashSet集合"><a href="#3-2-LinkedHashSet集合" class="headerlink" title="3.2 LinkedHashSet集合"></a>3.2 LinkedHashSet集合</h3><p> <code>java.util.LinkedHashSet</code>集合 extends <code>HashSet</code>集合<br>特点：<br>    底层是一个哈希表（数组+链表/红黑树）+链表（记录元素的存储顺序），保证<strong>元素有序</strong></p>
<h3 id="3-3-可变参数"><a href="#3-3-可变参数" class="headerlink" title="3.3 可变参数"></a>3.3 可变参数</h3><pre><code>JDK1.5出现的新特性</code></pre><p>· 使用前提：当方法的参数列表数据类型已经确定，但参数的个数不确定，就可以使用。<br>· 使用格式：定义方法时使用</p>
<ul>
<li><code>修饰符 返回值类型 方法名(数据类型... 变量名){  }</code><br>· 特殊（终极）写法：<code>修饰符 返回值类型 方法名(Object... obj){  }</code><br>· 原理：</li>
<li>底层就是一个数组，根据传递参数的<strong>个数不同</strong>，会创建不同长度的数组，来存储这些参数。</li>
<li>传递的参数个数可以是0，1，2…</li>
</ul>
<p>e.g 定义计算<strong>（0~n）整数</strong>和的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int add(int…arr) &#123;</span><br><span class="line">  &#x2F;&#x2F; sout(arr);  &#x2F;&#x2F; [I@2ac1fdc4 </span><br><span class="line"> &#x2F;&#x2F;  sout(arr.lengh); &#x2F;&#x2F; 0</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  for(int i : arr) &#123;</span><br><span class="line">    sum +&#x3D; I;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：‘[’代表数组，‘I’是指int类型，@后是地址值<br>如果调用<code>add();</code>，会创建一个长度为0的数组，new int[0]<br>如果调用<code>add(10);</code>，会创建一个长度为1的数组，new int[1]<br>如果调用<code>add(10,20);</code>，会创建一个长度为2的数组，new int[2]<br>……</p>
<p>· 注意事项：</p>
<ol>
<li>一个方法的参数列表，只能有一个可变参数</li>
<li>如果方法的参数有多个，那么可变参数必须写在参数列表末尾</li>
</ol>
<h2 id="第四章-Collections"><a href="#第四章-Collections" class="headerlink" title="第四章 Collections"></a>第四章 Collections</h2><p>` java.utils.Collections 是集合工具类，用来对集合进行操作。部分方法如下：<br>    -  public static <T> boolean addAll(Collection<T> c, T… elements) :往集合中添加一些元素。<br>    - public static void shuffle(List&lt;?&gt; list) 打乱顺序 :打乱集合顺序。<br>    - public static <T> void sort(List<T> list) :将集合中元素按照默认规则排序。<br>    - public static <T> void sort(List<T> list，Comparator&lt;? super T&gt; ) :将集合中元素按照指定规则排<br>序。<br>e.g</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt;color&#x3D;newArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(color,&quot;♥&quot;,&quot;♠&quot;,&quot;♣&quot;,&quot;♦&quot;);</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li><strong>静态方法</strong>，直接使用类名（Collections）调用即可。</li>
<li>无论是Interger还是String，都实现了一个接口Comparable，实现这个接口的目的是重写里面的compareTo()方法（排序方法），重写后，才能按照自己的规则来排序。<br>所以<code>sort(List&lt;T&gt; list)</code>使用前提：被排序的集合中<strong>存储的元素</strong>，必须实现comparable，重写接口中方法compareTo定义排序规则。<br>重写自定元素<strong>类型中</strong>compareTo方法，默认返回0（认为元素都是相同的）。<br><code>comparable排序规则：自己（this）- 参数 ：升序</code></li>
</ol>
<p>· sort(List<T> list，Comparator&lt;? super T&gt; )使用方法：<br>e.g</p>
<pre><code>//排序方法  按照第一个单词的降序
Collections.sort(list, new Comparator&lt;String&gt;() {
    @Override
            public int compare(String o1, String o2) {
                return o2.charAt(0) ‐ o1.charAt(0);
            }
}

· comparable和comparator的区别：
    1. comparable：自己（this）和别人（参数）的比较。自己需要重写comparable接口，重写比较的规则compareTo方法。
    2. comparator：相当于找一个第三方的裁判，比较两者
注：comparator的compare方法排序规则：o1-o2 升序
</code></pre>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>Set</tag>
        <tag>数据结构</tag>
        <tag>Collections</tag>
      </tags>
  </entry>
  <entry>
    <title>09-Collection，泛型</title>
    <url>/2020/07/23/09-Collection%EF%BC%8C%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><p>• 集合和数组都是一种容器。区别是：数组长度固定，但是集合可变。数组可以存储基本类型，或者对象；而集合只能存储对象。<br>• 集合框架<br><img src="https://img-blog.csdnimg.cn/20200806090449273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200806090654195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="Collection常用功能"><a href="#Collection常用功能" class="headerlink" title="Collection常用功能"></a>Collection常用功能</h4><blockquote>
<p><code>java.util.Collection</code>接口：所有单列集合的最顶层的接口，里面定义了所有单列集合共性方法。任意单列集合都能使用Collection接口中的方法。</p>
</blockquote>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。一般返回true，可以不接受</li>
<li><code>public void clear()</code> :清空集合中所有的元素，不删除集合。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。删除存在元素返回true；删除不存在，失败返回false。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p><strong>使用</strong>：1.创建集合对象，可以使用多态<br>e.g. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用多态，只需要改等号右边的集合类型，上面通用方法都可以使用</span><br><span class="line">&#x2F;&#x2F; Collection&lt;String&gt;coll&#x3D; new ArrayList&lt;&gt;(); </span><br><span class="line"> Collection&lt;String&gt;coll&#x3D; new Hashset&lt;&gt;(); </span><br><span class="line"> coll.add(&quot;mike&quot;);</span><br><span class="line"> coll.add(&quot;clara&quot;);</span><br><span class="line"> Object[] arr &#x3D; coll.toArray();</span><br></pre></td></tr></table></figure>

<h4 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h4><p>Java.util.Iterator接口：迭代器（对集合进行遍历）是Collection通用的取出集合元素的方式。<br><strong>两个常用方法</strong>：<br><code>boolean hasNext()</code>  如果仍有元素可以迭代，则返回 true。<br><code>E next()</code> 返回迭代的下一个元素。<br>Iterator是接口，我们无法直接使用，需要使用iterator接口的实现类对象，获取实现类方法比较特殊。<br>Collection接口有个方法，返回的就是迭代器的实现对象<br><code>Iterator&lt;E&gt; iterator()</code> 返回在此 collection 的元素上进行迭代的迭代器。 </p>
<p><strong>使用步骤</strong>：</p>
<ol>
<li>使用集合中的方法iterator() 获得迭代器的实现对象，使用Iterator接口接收（多态）</li>
<li>使用Iterator接口中的方法 hasNext()判断有没有下一个元素</li>
<li>使用Iterator接口中的方法next() 取出集合中的下一个元素</li>
</ol>
<p><strong>注意</strong>：Iterator<E>也是有泛型的，迭代器的泛型跟着接口走，集合是什么泛型，迭代器就是什么泛型。<br>E.g</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it &#x3D; coll.iterator();</span><br><span class="line">While(it.hasNext()) &#123;</span><br><span class="line">  String s &#x3D; it.next();</span><br><span class="line">  System.out.println(s); </span><br><span class="line">&#125;</span><br><span class="line">System.out.println(---------------------); </span><br><span class="line">for(Iterator&lt;String&gt; it2 &#x3D; coll.iterator(); it2.hasNext(); ) &#123;</span><br><span class="line">  String s &#x3D; it.next();</span><br><span class="line">  System.out.println(s); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while循环通常用于不知道有多少元素，for循环一般用于知道有多少元素。</p>
<p><strong>实现原理</strong><br>获取迭代器的实现类对象，并且把指针（索引）指向集合的-1索引。<br>判断集合中有没有下一位元素，如果有就取出，然后把指针向后挪一位。</p>
<p>增强for（for each循环）<br>jdk1.5后出现，专门用来遍历<strong>数组和集合</strong>的。底层也是使用迭代器，只是用for循环格式简化书写，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>Collection<E>extends Iterable<E>：所有的单列集合都可以使用增强for<br>public interface Iterable<T>实现这个接口允许对象成为 “foreach” 语句的目标。</p>
<p><strong>格式</strong>：<br>for(集合/数组的数据类型 变量名：集合名/数组名) {<br>  sout(变量名);<br>}</p>
<p>E.g</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;遍历数组</span><br><span class="line">int[] arr &#x3D; &#123;1,2,3,4,5&#125;;</span><br><span class="line">for(int i : arr) &#123;</span><br><span class="line">  system.out.println(i)；</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;遍历集合</span><br><span class="line">ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;aaa&quot;);</span><br><span class="line">list.add(&quot;bbb&quot;);</span><br><span class="line">list.add(&quot;ccc&quot;);</span><br><span class="line">for(String s : list) &#123;</span><br><span class="line">  system.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一种未知的数据类型，不知道使用什么类型时，可以使用泛型。也可以看作是一个变量，用来接收数据类型。</p>
<blockquote>
<p>E，e：element 元素<br>T，t：type 类型<br>创建集合对象的时候，就会确定泛型的数据类型。</p>
</blockquote>
<p><strong>使用泛型好处</strong><br>1.创建集合对象，不使用泛型<br>好处：默认使用Object类型，可以存储任意类型的数据<br>弊端：不安全，会引发异常<br>e.g</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> AtrrayList ();</span><br><span class="line">list.add(<span class="string">"aa"</span>);</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">Iterator it = list.iterator();</span><br><span class="line">While(it.hasNext()) &#123;</span><br><span class="line">  <span class="comment">// 取出元素也是object类型</span></span><br><span class="line">  Object obj = it.next();</span><br><span class="line">  System.out.println(obj); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 想要使用String特有的方法，比如length获取字符串长度，无法做到 多态 obj = “aa”</span></span><br><span class="line">  <span class="comment">// 需要向下转型</span></span><br><span class="line">  String s = (String)obj;</span><br><span class="line">  System.out.println(s.length); </span><br><span class="line">  <span class="comment">//但是由于第二个是Integer类型，不能把integer转换成string，会抛出异常ClassCastException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.创建集合对象，使用泛型<br>好处：<br>    1. 避免类型转换的麻烦，存储什么类型，取出就是什么类型<br>    2. 把运行期代码异常提升到编译期（写代码时候就报错）</p>
<h4 id="泛型的定义与使用"><a href="#泛型的定义与使用" class="headerlink" title="泛型的定义与使用"></a>泛型的定义与使用</h4><p>1.含有泛型的类<br>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;E&gt; &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<font color = #F9000>创建对象的时候</font>确定泛型</p>
<p>2.含有泛型的方法<br>泛型定义在方法的修饰符和返回值类型之间<br>格式： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;泛型&gt; 返回类型 方法名 (参数列表&lt;使用泛型&gt;) &#123;</span><br><span class="line">  方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = #F9000>调用方法时</font>，确定泛型的类型（传递什么类型的参数，泛型就是什么类型）</p>
<p>3.含有泛型的接口<br>定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; </span><br><span class="line">  … </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用方式</strong>：</p>
<ol>
<li><p>定义类时确定泛型的类型<br> e.g</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 实现接口…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>始终不确定泛型的类型，直到创建对象时，确定泛型的类型。<br> e.g</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();</span><br><span class="line">my.add(<span class="string">"aa"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>当使用泛型类或者接口时，传递数据中不能确定是什么泛型类型，可以使用&lt;?&gt;表示。<br>使用：不能创造对象使用；只能作为方法的参数使用<br>注意：</p>
<ol>
<li>泛型没有继承概念<br>  Collection<Object> list = new ArrayList<String>();这种是错误的。</li>
<li>一旦使用了通配符，只能使用object类中的共性方法，集合中元素自身方法无法使用。（比如可以用在遍历集合方法中）</li>
</ol>
<p><strong>上下限限定</strong>（看懂即可）<br>泛型的上限限定： <code>？extends E</code> 代表使用的泛型只能是E类型的子类/本身<br>泛型的下限限定：<code>？super E</code>代表使用的泛型只能是E类型的父类/本身</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Collection</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>08-Object类，常用API</title>
    <url>/2020/07/18/08-Object%E7%B1%BB%EF%BC%8C%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p><code>java.lang.Object</code>是java所有子类的父类，所有子类都能使用它中描述的方法</p>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。<br>其实内容就是内容就是对象的类型+@+内存地址值。</li>
</ul>
<p>Object的toString方法中返回值为地址值，需要重写toString方法。<br><mark>Alt+insert：选择tostring方法，直接帮助重写</mark></p>
<p>看一个类是否重写了toString方法，直接打印这个类对应对象的名字即可：<br>    如果没有重写，那么打印的是对象的地址值（默认）<br>    如果重写了，那么就按照重写的方式打印 </p>
<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><pre><code>public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。</code></pre><p>&emsp;方法体里面返回<code>（this == obj）</code>，基本数据类型比较的是值，而引用数据类型比较的是地址。<font color = #F9000>所以equals方法默认比较的是两个对象的地址值。</font>如果new了两个对象（地址值是不相同的），p1、p2，调用p1.equals(p2)里面就是在比较p1地址值 == p2地址值 。<br>&emsp;比较地址值没有意义，所以我们一般需要重写，比较两个对象的属性值。因为参数是Object类型，我们传入的是Object子类，即使用了多态用法。但是多态写法有个缺点，不能使用子类的特有成员函数和成员变量，所以需要使用<font color = #F9000><strong>向下转型（强转）</strong></font>把Object类型转换成需要比较的类型。转换前使用instanceof来判断传入参数类型与要比较类型是否相同，防止转换异常(传入dog类型，要比较的是Person类，直接返回false即可)<br><mark>Alt+insert：选择equals() and hashCode()自动代码生成。最好template选择java 7+</mark><br>Jave7+，IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类<br><img src="https://img-blog.csdnimg.cn/20200721123157602.png" alt="在这里插入图片描述"><br>Objects类的equal方法：对两个对象进行比较防止空指针异常 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：Objects.equals(s1, s2)；</p>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p><code>java.util.Date</code>类 表示日期和时间的类，精确到毫秒。<br>1秒 = 1000毫秒<br>E.g 2019-01-03 09：55：22：222</p>
<p>我们可以把日期转换为毫秒进行计算，再转回日期<br> ·  时间原点：1970年1月1日8时0分0秒<br> ·  计算当前日期时间到原点之间共经历多少毫秒{Long类型的值}</p>
<blockquote>
<p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p>
</blockquote>
<p><strong>构造方法</strong><br>Date类的空参构造方法：<br><code>Date();</code>获取的是当前系统的Date日期<br>E.g Sun Aug 08 15：35：37 CST 2018  (CST是中国标准时间)<br>Date类的带参构造方法：<br><code>Date(long date);</code> 传递毫秒值，把毫秒值转换为Date日期</p>
<p><strong>成员方法</strong><br><code>public long getTime()</code> 把日期对象转换成毫秒。返回自1970年1月1日00:00:00 GMT）以来表示的毫秒数<br><code>String toLocalString();</code>  根据本地格式切换日期对象</p>
<h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><p><code>java.text.DateFormat</code> 是日期/时间格式化子类（父类为Format）的一个【抽象类】，可以使用它的子类为<code>java.text.SimpleDateFormat</code><br>作用：格式化（日期–&gt;文本），解析（文本–&gt;日期）</p>
<p><strong>simpleDateFormat的构造方法</strong>：</p>
<p><code>public SimpleDateFormat(String pattern)</code>： 用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。<br>参数：传递指定的格式。</p>
<p>常用的格式规则为：</p>
<table>
<thead>
<tr>
<th align="center">标识字母（区分大小写）</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">y</td>
<td align="center">年</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">月</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">日</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">时</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">分</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">秒</td>
</tr>
<tr>
<td align="center">常用：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">yyyy-MM-dd HH:mm:ss</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">yyyy年MM月dd日 HH时mm分ss秒</td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>成员方法</strong>：</p>
<ul>
<li><code>public String format(Date date)</code>：按照指定格式，将Date对象格式化为字符串。<br>使用步骤：</li>
</ul>
<ol>
<li>创建SimpleDateFormat对象，构造方法中传入指定格式</li>
<li>调用SimpleDateFormat对象中的方法format，按照构造方法中指定的模式，把Date日期格式化为符合模式的字符串（文本）</li>
</ol>
<ul>
<li><code>public Date parse(String source)</code>：将字符串解析为Date对象。<br>使用步骤：</li>
</ul>
<ol>
<li>创建SimpleDateFormat对象，构造方法中传入指定格式</li>
<li>调用SimpleDateFormat对象中的方法parse，把符号构造方法中模式的字符串，解析为Date日期<br>注意：</li>
</ol>
<p>-parse方法声明了一个ParseException解析异常。如果字符串和构造方法中指定格式不符，就会抛出异常。<br>-调用了一个抛出异常的方法，就必须处理这个异常，要么用throws继续声明抛出这个异常，要么用try…catch自己处理这个异常。<mark>（alt+回车）</mark></p>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p><code>java.util.Calendar</code>：一个【抽象的】日历类，里面提供了许多操作日历字段的方法（YEAR、MONTH、DAY_OF_MONTH、HOUR）<br>抽象类无法直接创建对象使用，里面有一个静态方法<code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历。该方法返回Calendar类的子类对象。<br>E.g Calendar c = Calendar.getInstance(); // 多态写法</p>
<p>常用成员方法：</p>
<ul>
<li><code>public int get(int field)</code>：返回给定日历字段的值。</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li>
<li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。把日历对象转换为日期对象<br>成员方法的参数：<ul>
<li>int field:日历类的字段，可以使用calendar类的静态成员获取</li>
<li>int value:增加/减少的值<br>Calendar类中提供很多成员常量，代表给定的日历字段：<br>（public static final int 字段值）<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以+1使用）西方月份0~11月</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天（几号）</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<p>E.g int year = c.get(Calendar.YEAR);<br>c .set(Calendar.YEAR, 2020);<br>c.add(YEAR, -3); // 2017<br>Date date = c.getTime(); // Sun Aug 08 15：35：37 CST 2017</p>
<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p>
<ul>
<li><p><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。<br>可以用来测试一个程序耗费时间</p>
</li>
<li><p><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。<br>参数：<br>  src：源数组<br>  srcPos：源数组起始位置<br>  destPos：目标数组<br>  length：要复制的数组元素数量</p>
</li>
</ul>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>字符串是常量，它们的值在创建之后不能更改。<br>字符串底部是被final修饰的数组，所以不能改变<br>private final byte[] value；</p>
<p>StringBuilder类（字符串缓存区）支持可变字符串[]<br>底层是个没有被final修饰的数组，可变长度。初始容量为16，如果超过16，会自动扩容，翻倍。<br>byte[] value = new byte[16];<br>E.g.<br><img src="https://img-blog.csdnimg.cn/20200721123725835.png" alt="在这里插入图片描述"></p>
<p><em><code>java.lang.StringBuilder</code>类：字符串缓存区，提高字符串的效率。<br>*</em>构造方法**：</p>
<ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<p><strong>常用方法</strong>：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身（返回的是this，即调用方法的对象），所以使用无需有返回值<br>E.g<br>bu1.append(8.8);</li>
</ul>
<blockquote>
<p>链式编程：方法返回值是一个对象，可以根据对象继续调用方法。<br>E.g<br>bu1.append(8.8).append(“abc”).append(true);</p>
</blockquote>
<ul>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。<br>String–&gt;StringBuilder：有参构造方法；StringBuilder–&gt;String：toString方法。</li>
<li><code>public StringBuilder reverse()</code>：逆转，返回此对象的一个引用</li>
</ul>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>基本数据类型没有对应的方法进行操作，我们用一个类把基本数据类型包装起来。</p>
<p><strong>基本类型    对应的包装类（位于java.lang包中）</strong></p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">对应的包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p><strong>装箱</strong>：把基本类型数据包装到包装类中</p>
<ol>
<li>构造方法：<br> Integer(int value) :构造一个新分配的 Integer 对象，它表示指定的 int 值。<br> Integer(String s) : 构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值<br> 传递的字符串必须是基本类型的字符串<br> 不能把一个“a”变成一个整数，会报错数字格式化异常</li>
<li>静态方法<br> static Integer    valueOf(int i) : 返回一个表示指定的 int 值的 Integer 实例。<br> static Integer    valueOf(String s) : 返回保存指定的 String 的值的 Integer 对象。</li>
</ol>
<p><strong>拆箱</strong>：在包装类中取出基本类型数据<br>使用成员方法<br> int intValue() :以 int 类型返回该 Integer 的值。</p>
<h3 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h3><p>JDK1.5之后，基本类型数据和包装类间可以自动转换。<br>Integer in = 1；// 自动装箱<br>//包装类无法直接参与运算，可以自动转换为基本类型的数据，再参与计算。<br>in = in +2;</p>
<p>ArrayList集合无法直接存储整数，可以存储Integer包装类<br>list.add(1); // 自动装箱<br>Int a = list.get(0); // 自动拆箱</p>
<p>基本数据类型和字符串之间的转换<br>基本类型–&gt;字符串</p>
<ol>
<li>基本类型数据的值+””(最简单）</li>
<li>使用包装类中的静态方法toString<br>static String    toString(int i) :返回一个表示指定整数的 String 对象。</li>
<li>使用String类中的静态方法<br>static String    valueOf(int i) :返回 int 参数的字符串表示形式。</li>
</ol>
<p>字符串–&gt;基本类型</p>
<ol>
<li>使用包装类的静态方法parseXX(“字符串”)<br> Integer类：static int parseInt(String s) // s必须是整数，不能是“a”这种<br>Double类：static double parseInt(String s)</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>11-Map，Debug</title>
    <url>/2020/08/09/11-Map%EF%BC%8CDebug/</url>
    <content><![CDATA[<h1 id="第一章-Map集合"><a href="#第一章-Map集合" class="headerlink" title="第一章 Map集合"></a>第一章 Map集合</h1><p>Map，Debug追踪，斗地主综合案例<strong>代码</strong>见<a href="https://github.com/two-fire/Java_Basic/tree/master" target="_blank" rel="noopener">github</a></p>
<h3 id="1-1-Map接口"><a href="#1-1-Map接口" class="headerlink" title="1.1 Map接口"></a>1.1 Map接口</h3><pre><code>`java.util.Map&lt;k, v&gt;`集合</code></pre><p>· Map集合的特点：</p>
<ol>
<li>Map 集合是一个双列集合，一个元素包含key，value两个值</li>
<li>Map 集合中的元素，key和value的数据类型不一定要相同</li>
<li>Map 集合中的元素，key不允许重复，value可以</li>
<li>Map 集合中的元素，key和value一一对应</li>
</ol>
<h3 id="1-2-Map接口的常用子类"><a href="#1-2-Map接口的常用子类" class="headerlink" title="1.2 Map接口的常用子类"></a>1.2 Map接口的常用子类</h3><h4 id="1-2-1-HashMap"><a href="#1-2-1-HashMap" class="headerlink" title="1.2.1 HashMap"></a>1.2.1 HashMap</h4><pre><code>`java.util.HashMap&lt;k, v&gt;`集合 implements Map&lt;k, v&gt;接口</code></pre><p>· HashMap集合的特点：</p>
<ol>
<li>HashMap集合的底层是<font color = #F9000>哈希表</font>：查询速度快<br>JDK1.8前：数组+单向列表<br>JDK1.8及以后：数组+单向列表/红黑树（链表长度超过8）</li>
<li>无序集合，存储/取出元素的顺序有可能不一致</li>
</ol>
<h4 id="1-2-2-LinkedHahMap"><a href="#1-2-2-LinkedHahMap" class="headerlink" title="1.2.2 LinkedHahMap"></a>1.2.2 LinkedHahMap</h4><pre><code>`java.util.LinkedHashMap&lt;k, v&gt;`集合 extends HashMap&lt;k, v&gt;集合</code></pre><p>· 特点：</p>
<ol>
<li>底层是<font color = #F9000>哈希表+链表</font>：保证迭代的顺序</li>
<li>有序的集合，存储/取出的顺序是一致的</li>
</ol>
<h3 id="1-3-Map接口中的常用方法"><a href="#1-3-Map接口中的常用方法" class="headerlink" title="1.3 Map接口中的常用方法"></a>1.3 Map接口中的常用方法</h3><ul>
<li><p><code>public V put(K key, V value)</code> :  把指定的键与指定的值添加到Map集合中。<br>  返回值：V<br>  &emsp;存储键值的时候，如果key不重复，返回null；<br>  &emsp;存储键值的时候，如果key重复，会使用新的value替换原来的，<strong>返回被替换的</strong>value值。</p>
</li>
<li><p><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。<br>  返回值：V<br>  &emsp;key存在，v返回被删除的值；<br>  &emsp;key不存在，v返回null。</p>
</li>
<li><p><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。<br>  返回值：V<br>  如果key存在，返回对应的value值；<br>  如果不存在，返回null。</p>
</li>
<li><p><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。<br>  包含返回ture，否则false。</p>
</li>
</ul>
<h3 id="1-4-Map遍历-键找值方法"><a href="#1-4-Map遍历-键找值方法" class="headerlink" title="1.4 Map遍历 键找值方法"></a>1.4 Map遍历 键找值方法</h3><p>遍历方法：</p>
<ul>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。<br>· 使用迭代器或增强for遍历Set集合，获取Map集合中的每个key。<br>· 通过Map集合中的方法<code>get(key)</code>，通过key获取value。</li>
</ul>
<h3 id="1-5-Map遍历-Entry键值对方法"><a href="#1-5-Map遍历-Entry键值对方法" class="headerlink" title="1.5 Map遍历 Entry键值对方法"></a>1.5 Map遍历 Entry键值对方法</h3><p>遍历方法：</p>
<ul>
<li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。<br>· 使用Set集合，获得每个Entry对象。set.iterator()<br>· 使用Entry对象中的<code>getValue()</code>和<code>getKey()</code>获取键值。<br><img src="https://img-blog.csdnimg.cn/20200809221649701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200809221838998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-6-HashMap存储自定义类型"><a href="#1-6-HashMap存储自定义类型" class="headerlink" title="1.6 HashMap存储自定义类型"></a>1.6 HashMap存储自定义类型</h3><pre><code>• Map集合需要重写hashCode()和equals()方法，以保证key唯一。
• key不允许重复，存取无序。</code></pre><h3 id="1-7-LinkedHashMap"><a href="#1-7-LinkedHashMap" class="headerlink" title="1.7 LinkedHashMap"></a>1.7 LinkedHashMap</h3><pre><code>`java.util.LinkedHashMap &lt;K, V&gt;` extends HashMap&lt;K, V&gt;</code></pre><p>· Map接口的<font color = #F9000>哈希表和链接列表</font>的实现，具有可欲知的迭代顺序。即如果要保证map中存放的key和取出的<strong>顺序一致</strong>，可以使用 <code>LinkedHashMap</code>集合来存放。<br>· 底层原理：哈希表+链表<br>· key不允许重复，存取有序。</p>
<h2 id="1-8-Hashtable"><a href="#1-8-Hashtable" class="headerlink" title="1.8 Hashtable"></a>1.8 Hashtable</h2><pre><code>`Java.util.Hashtable&lt;K, V&gt;`集合 implement `Map&lt;K, V&gt;`接口

• Hashtable：底层也是一个哈希表，线程安全（同步）的集合，是单线程集合，速度慢
• HashMap：底层是一个哈希表，线程不安全（不同步）的集合，是多线程集合，速度快
• 之前学的所有集合都可以存储null值，null键。但Hashtable集合不能存储null值，null键。
• Hashtable与Vector一样，Hashtable是双列集合的“祖宗”，在JDK1.2之后被更先进集合（**HahMap集合**）取代。
• 不过Hashtable的子类`Properties`依旧活跃。它是&lt;font color = #F9000&gt;唯一一个和IO流相结合&lt;/font&gt;的集合。</code></pre><h1 id="第二章-补充知识点"><a href="#第二章-补充知识点" class="headerlink" title="第二章 补充知识点"></a>第二章 补充知识点</h1><h3 id="2-1-JDK9-对集合添加的优化"><a href="#2-1-JDK9-对集合添加的优化" class="headerlink" title="2.1 JDK9 对集合添加的优化"></a>2.1 JDK9 对集合添加的优化</h3><p>·JDK9的新特性：<br>· <code>List接口</code>、<code>Set接口</code>、<code>Map接口</code>：里面增加了一个静态方法<code>of</code>，可以一次性向集合中添加多个元素。<br><code>static&lt;E&gt; List&lt;E&gt; of (E… elements)</code><br>· 使用前提：当集合中存储的元素个数已经确定而且不再改变的的时候使用。<br>· 注意：</p>
<ol>
<li>of方法只适用于List<strong>接口</strong>，Set接口，Map接口，不适用于<strong>接口的实现类</strong></li>
<li>of方法的返回值是<strong>不能改变的集合</strong>，集合不能再用add、put添加元素了，否则会抛出不支持操作异常</li>
<li>Set接口和Map接口在调用of方法的时候，不能有重复元素，否则会抛出非法参数异常</li>
</ol>
<h3 id="2-2-Debug追踪"><a href="#2-2-Debug追踪" class="headerlink" title="2.2 Debug追踪"></a>2.2 Debug追踪</h3><p>Debug调试程序：可以让代码<strong>逐行执行</strong>，查看代码执行过程，调试程序中出现的bug。<br>使用方式：</p>
<ul>
<li>在行号的右边，鼠标左键单击，添加断点（每个方法的第一行，哪有bug添加到哪里）</li>
<li>右键，选择Debug执行程序</li>
<li>程序就会停留在添加的第一个断点处<br>执行程序：</li>
<li>fn+f8：逐行执行程序</li>
<li>fn+f7：进入方法</li>
<li>fn+shift+f8：跳出方法</li>
<li>fn+f9：跳到下一个断点（如果没有下一个，就停止程序）</li>
<li>fn+ctrl+f2：退出debug模式，停止程序</li>
<li>Console：切换到控制台</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Map</tag>
        <tag>Debug</tag>
        <tag>JDK9</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU制造过程及原理</title>
    <url>/2020/09/18/CPU%E5%88%B6%E9%80%A0%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="CPU的制作过程"><a href="#CPU的制作过程" class="headerlink" title="CPU的制作过程"></a>CPU的制作过程</h2><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>&emsp;CPU上通过光刻工艺集成了大量晶体管，晶体管其实就是一个“开”或“关”的开关，而对于计算机说就是0或1。</p>
<p>&emsp;从沙子中提取纯净的单晶硅(半导体材料)，液化硅整型成为圆柱状的硅锭。直径目前多为200mm，越大越难。</p>
<p>&emsp;切片，越薄越好。要进行质检。今天的半导体制造多选择CMOS工艺（互补型金属氧化物半导体）。其中互补一词表示半导体中N型MOS管和P型MOS管之间的交互作用。</p>
<blockquote>
<p>(晶体管原理)[晶体管原理] 因为单晶硅的导电率低，有一种叫doping的技术，在合格的切片中掺杂质，来提升导电率。如果注入价电子为5的磷，有个电子就会在系统中自由移动（<font color = #F9000>N型DOPING，Negative，负极</font>）；如果注入价电子为3的硼，会有个空位（空穴），与之相邻的电子随时可以把它填上。这种电子移动可看作“空穴对位运动”。我们称为<font color = #F9000>P型DOPING，Positive，正极</font>。<br><img src="https://img-blog.csdnimg.cn/20200918231106288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<p>&emsp;在掺入化学物质的工作完成之后，标准的切片就完成了。将每片控制温度让表面生成一层二氧化硅膜。门氧化物（门电路）是晶体管门电路的一部分，通过对门电压的控制，控制电子流动，而与输入输出电压大小无关。</p>
<p>&emsp;在二氧化硅层上覆盖一个感光层（光刻胶）。</p>
<h4 id="光刻蚀"><a href="#光刻蚀" class="headerlink" title="光刻蚀"></a>光刻蚀</h4><p>&emsp;使用短波紫外线和透镜，感光层在紫外线照射下可溶，利用掩模上的电路图，光刻出每一层的电路图案。</p>
<p>&emsp;蚀刻：使用化学物质溶解掉暴露出的晶圆部分，剩下的部分被光刻胶保护。</p>
<p>&emsp;蚀刻完成后，清除光刻胶，就能看到设计好的电路图。剩下的是充满的沟壑的二氧化硅层以及暴露出来的在该层下方的硅层。</p>
<h4 id="掺杂"><a href="#掺杂" class="headerlink" title="掺杂"></a>掺杂</h4><p>&emsp;再次加上一个二氧化硅层，然后光刻一次（浇上光刻胶，光刻后洗掉曝光部分；之后进行离子注入，清除光刻胶）</p>
<p>&emsp;重复。</p>
<h4 id="就绪阶段"><a href="#就绪阶段" class="headerlink" title="就绪阶段"></a>就绪阶段</h4><p>&emsp;在绝缘材上蚀刻出三个孔洞，并填充铜，以便和其它晶体管互连。在晶圆上电镀一层硫酸铜，铜离子沉积在晶圆表面，形成一个薄薄的铜层。将多余的铜抛光掉。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>&emsp;晶圆切片，每一块是一个处理器的内核。丢弃瑕疵内核，封装好的内核，进行等级测试，决定处理器的等级。</p>
<h2 id="CPU原理"><a href="#CPU原理" class="headerlink" title="CPU原理"></a>CPU原理</h2><p>计算机需要解决的最根本的问题是怎么代表数字。<br>发明二进制后，发现电就可以代表数字。<br>最开始是一个电子管，通过正负极施压。但容易爆。<br>发现半导体，体积小，寿命长。晶体管是现代计算机的核心。<br>硅–&gt;加入特殊元素–&gt;P导体N导体–&gt;PN结–&gt;场效应晶体–&gt;逻辑开关<br><strong>时钟发生器</strong>（晶体振荡器）是读板上的一个芯片，不断对不同针脚通电、断电，不断推动运算。<br><strong>内存</strong>本质是存储了一些电信号，这是提前写好的运算过程，而这些电信号通过总线和我们计算机CPU相连接。CPU把里面的信息0、1读进来，我们就不需要手工给CPU针脚通电、断电了。</p>
<blockquote>
<p>CPU一次性能读进来多少位数字进来，就是多少位的OS。与总线读进来的位数不是一定完全匹配的。</p>
</blockquote>
<p>利用晶体管建立放大电路。第二个晶体管的基极与第一个的发射极连接起来。在输入端引入一个微小波动，另一端就会产生一个大的信号。<br><img src="https://img-blog.csdnimg.cn/20200918143429712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200918233339140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>硬件基础知识</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>晶体管</tag>
      </tags>
  </entry>
  <entry>
    <title>12-异常，线程</title>
    <url>/2020/09/03/12-%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>涉及代码见<a href="https://github.com/two-fire/Java_Basic" target="_blank" rel="noopener">github</a></p>
<h2 id="第一章-异常"><a href="#第一章-异常" class="headerlink" title="第一章 异常"></a>第一章 异常</h2><h3 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h3><p><strong>·</strong> 异常：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</p>
<p>Java等面向对象的语言中，异常本身是一个类。产生异常就算<strong>创造一个异常对象</strong>，Java处理异常就是<strong>中断处理</strong>。</p>
<blockquote>
<p>异常指的并<strong>不是语法错误</strong>,语法错了,编译不通过,不会产生字节码文件,根本不能运行。</p>
</blockquote>
<h3 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h3><p>所有错误或者异常的超类是 <code>java.lang.Throwable</code> ，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code> ，平常所说的<strong>异常</strong>指 <code>java.lang.Exception</code>。<br>· Exception：编译期异常，进行编译（写代码）Kava程序出现的问题<br>    - RuntimeException：运行期异常<br>注：把异常处理掉，程序就可以继续执行。</p>
<p>· Error：错误。<br>注：错误必须修改源代码，程序才能继续执行。</p>
<p>例一 ：编译期异常<br>SimpleDateFormat的parse()方法本身有编译期异常。处理方法：<br><mrak>alt+回车</mark></p>
<ol>
<li><p>把异常抛出，交给虚拟机来处理。方式：中断处理，中止程序把异常打印在控制台。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span>throwsParseException</span>&#123;</span><br><span class="line">	<span class="comment">//Exception：编译期异常</span></span><br><span class="line">	<span class="comment">//格式化日期</span></span><br><span class="line">	<span class="comment">// 1. throwsParseException处理异常</span></span><br><span class="line">	SimpleDateFormatsdf=newSimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">	<span class="comment">//把字符串格式的日期解析为Date格式的日期</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		正常情况</span></span><br><span class="line"><span class="comment">		Datedate=sdf.parse("1999-8-16");</span></span><br><span class="line"><span class="comment">		System.out.println(date);//MonAug1600:00:00CST1999</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		不正常情况</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	Datedate=sdf.parse(<span class="string">"19998-16"</span>);</span><br><span class="line">	System.out.println(date);<span class="comment">//ParseException解析异常</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p> 缺点：正常执行，没有问题。如果模式或者字符串有问题有问题，会报<strong>解析异常</strong>。</p>
</li>
<li><p>选择try-catch处理异常。<br> 优点：处理后，程序可以正常执行。如果异常，控制台会输出ParseException，不过也会打印后续代码</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.try-catch处理异常</span></span><br><span class="line">Datedate=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	date=sdf.parse(<span class="string">"19998-16"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ParseExceptione)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(date);</span><br><span class="line">System.out.println(<span class="string">"后续代码"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>例二：运行期异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[]arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(arr[3]);//ArrayIndexOutOfBoundsException（数组索引越界异常）</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//可能会出现异常的代码</span></span><br><span class="line">	System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exceptione)&#123;</span><br><span class="line">	<span class="comment">//异常的处理逻辑</span></span><br><span class="line">	System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"后续代码"</span>);</span><br></pre></td></tr></table></figure>
<p>输出：<br>java.lang.ArrayIndexOutOfBoundsException: 3<br>后续代码</p>
<p>例三：Error<br>必须修改代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Error</span></span><br><span class="line"><span class="keyword">int</span>[]arr=newint[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>];<span class="comment">//OutOfMemoryError内存溢出</span></span><br></pre></td></tr></table></figure>



<h3 id="1-4-异常产生过程解析"><a href="#1-4-异常产生过程解析" class="headerlink" title="1.4 异常产生过程解析"></a>1.4 异常产生过程解析</h3><p><img src="https://img-blog.csdnimg.cn/20200903154019269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="第二章-异常的处理"><a href="#第二章-异常的处理" class="headerlink" title="第二章 异常的处理"></a>第二章 异常的处理</h2><h3 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1 抛出异常throw"></a>2.1 抛出异常throw</h3><p>可以使用throw关键字在指定方法中<strong>抛出指定的异常</strong>。<br>使用格式：throw new xxxException(“异常产生的原因”);<br>注意:</p>
<ol>
<li><p>throw必须写在方法内部</p>
</li>
<li><p>throw后面的new的对象是Exception或者是Exception的子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"传递的数组的值为null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>*空指针异常是一个运行期异常，我们不用处理，默认交给JVM处理。</p>
<ol start="3">
<li>throw抛出指定的异常对象，我们就必须处理这个异常对象</li>
</ol>
<p>-如果throw后创建的是RuntimeException或者是RuntimeException的子类对象，我们可以不处理，默认交给JVM处理（打印异常对象，中断程序）<br>-如果throw后创建的是编译异常，我们就必须处理这个异常，要么throws，要么try-catch</p>
<ol start="4">
<li>以后我们首先必须对方法传递过来的参数进行合法性校验。如果参数不合法，就必须使用抛出异常的方法，告知方法的调用者，传递的参数有问题。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">If(index &lt; <span class="number">0</span> || index &gt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ArrayOutOfBoundException(<span class="string">"传递的数组超出了数组的范围"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>*ArrayOutOfBoundException同样是一个运行期异常</p>
<h3 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h3><p>Objects类中的静态方法：（简化代码）<br><code>public static &lt;T&gt; T requireNonNull(T obj)</code> :查看指定引用对象是不是null。<br>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>· 在方法中直接使用<code>Objects.requireNonNull(obj)</code>来代替类似于该方法源码那样自己写throw来抛出参数为null的异常。<br>· 也可以<code>Objects.requireNonNull(obj, &quot;传递的对象的值是null&quot;)</code>，自行添加message。</p>
<h3 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3 声明异常throws"></a>2.3 声明异常throws</h3><p>throws关键字：异常处理的第一种方式，交给别人处理<br>作用：当方法内部抛出异常对象的时候，我们就必须处理这个异常的对象。可以使用throws来处理，会把异常对象声明抛出给方法的<strong>调用者处理</strong>，最终交给JVM处理（中断处理）<br>使用格式：方法声明时使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span>  AAAException, BBBException…&#123; </span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> AAAException(<span class="string">"产生原因"</span>);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> BBBException(<span class="string">"产生原因"</span>);</span><br><span class="line">	…</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>throws必须写在方法声明处</li>
<li>throws后面声明的异常必须是Exception或者是Exception的子类</li>
<li>方法内部如果抛出了多个异常对象 ，那么throws后必须也声明多个异常。<br>【如果抛出的多个异常有子父类关系，只需要声明父类异常即可】</li>
<li>调用一个声明抛出异常的方法，我们就必须处理声明的异常。</li>
</ol>
<ul>
<li>要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM–&gt;中断处理。</li>
<li>要么try-catch，自己处理异常。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException,IOException </span>&#123;  <span class="comment">//交给JVM处理</span></span><br><span class="line">      readFile(<span class="string">"c:\\a.tx"</span>);</span><br><span class="line">        System.out.println(<span class="string">"后续代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	定义一个方法，对传递的文件路径进行合法性判断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException,IOException</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(!fileName.equals(<span class="string">"c:\\a.txt"</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"传递的文件路径不是c:\\a.txt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果传递的路径,不是.txt结尾</span></span><br><span class="line"><span class="comment">            那么我们就抛出IO异常对象,告知方法的调用者,文件的后缀名不对</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(!fileName.endsWith(<span class="string">".txt"</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"文件的后缀名不对"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"路径没有问题,读取文件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>*FileNotFoundException是编译异常，抛出了编译异常，就必须处理这个异常<br>*可以使用throws继续声明抛出FileNotFoundException这个异常对象，让方法调用者处理</p>
<ul>
<li><code>FileNotFoundException extends IOException extends Excepiton</code>，<br>所以<code>public static void readFile(String fileName) throws FileNotFoundException,IOException</code>还可以用<code>public static void main(String[] args) throws IOException</code>或者<code>public static void main(String[] args) throws Exception</code>代替。</li>
</ul>
<p>缺陷：如果有后续代码，无法执行。</p>
<h3 id="2-4-捕获异常try-catch"><a href="#2-4-捕获异常try-catch" class="headerlink" title="2.4 捕获异常try-catch"></a>2.4 捕获异常try-catch</h3><p>try-catch：异常处理第二种方式,自己处理异常<br>格式:</p>
<pre><code>try{
    **可能产生**异常的代码
}catch(定义一个异常的**变量**,用来**接收**try中抛出的异常对象){
    异常的处理逻辑,接收异常对象之后,怎么处理异常对象
    【一般在工作中,会把异常的信息记录到一个日志中】
}
...
catch(异常类名 变量名){

}</code></pre><p> 注意:<br>    1. try中可能会抛出多个异常对象,那么就可以使用<strong>多个</strong>catch来处理这些异常对象<br>    2. 如果try中产生了异常,那么就会<strong>执行catch中的异常处理逻辑</strong>, 执行完毕catch中的处理逻辑,  继续执行try…catch之后的代码；<br>    如果try中没有产生异常,那么就不会执行catch中异常的处理逻辑，<strong>执行完try中的代码</strong>,继续执行try…catch之后的代码<br><strong>调用方法输出异常信息</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void printStackTrace()</td>
<td align="center">输出异常的堆栈信息</td>
</tr>
<tr>
<td align="center">String getMesssage()</td>
<td align="center">返回异常信息描述字符串，是printStackTrace()输出信息的一部分</td>
</tr>
</tbody></table>
<p><strong>常见的异常类型</strong><br><img src="https://img-blog.csdnimg.cn/20210202213614973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicstaticvoidmain(String[]args)&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//可能产生异常的代码</span></span><br><span class="line">		readFile(<span class="string">"d:\\a.tx"</span>);</span><br><span class="line">		System.out.println(<span class="string">"资源释放"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span>(IOExceptione) &#123; <span class="comment">//try中抛出什么异常对象,catch就定义什么异常变量,用来接收这个异常对象</span></span><br><span class="line">		<span class="comment">//异常的处理逻辑,接收异常对象之后,怎么处理异常对象</span></span><br><span class="line">		System.out.println(<span class="string">"catch-传递的文件后缀不是.txt"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"后续代码"</span>);</span><br><span class="line">&#125;</span><br><span class="line">publicstaticvoidreadFile(StringfileName)throwsIOException&#123;</span><br><span class="line">	<span class="keyword">if</span>(!fileName.endsWith(<span class="string">".txt"</span>))&#123;</span><br><span class="line">	    <span class="keyword">throw</span> newIOException(<span class="string">"文件的后缀名不对"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"路径没有问题,读取文件"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Throwable类中3个异常处理的方法"><a href="#2-5-Throwable类中3个异常处理的方法" class="headerlink" title="2.5 Throwable类中3个异常处理的方法"></a>2.5 Throwable类中3个异常处理的方法</h3><pre><code>- `String getMessage()`返回此 throwable 的简短描述。
- `String toString()` 返回此 throwable 的详细消息字符串。
- `void printStackTrace()`  JVM打印异常对象,默认此方法, 打印的异常信息是最全面的</code></pre><p>在上一个例子的catch中的异常处理逻辑使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">StringgetMessage()返回此throwable的简短描述。</span></span><br><span class="line"><span class="comment">StringtoString()返回此throwable的详细消息字符串。</span></span><br><span class="line"><span class="comment">voidprintStackTrace()JVM打印异常对象,默认此方法,打印的异常信息是最全面的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//System.out.println(e.getMessage());//文件的后缀名不对</span></span><br><span class="line"><span class="comment">//System.out.println(e.toString());//重写Object类的toStringjava.io.IOException:文件的后缀名不对</span></span><br><span class="line"><span class="comment">//System.out.println(e);//java.io.IOException:文件的后缀名不对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异常产生的位置、原因、内容</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.IOException:文件的后缀名不对</span></span><br><span class="line"><span class="comment">atcom.itheima.demo02.Exception.Demo01TryCatch.readFile(Demo01TryCatch.java:55)</span></span><br><span class="line"><span class="comment">atcom.itheima.demo02.Exception.Demo01TryCatch.main(Demo01TryCatch.java:27)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">e.printStackTrace();</span><br></pre></td></tr></table></figure>

<h3 id="2-4-finally-代码块"><a href="#2-4-finally-代码块" class="headerlink" title="2.4 finally 代码块"></a>2.4 finally 代码块</h3><p>格式：<br> try{<br> } catch() {</p>
<p> }<br>        …<br>        catch() {</p>
<pre><code>} finally {
    无论是否出现异常都会执行
}</code></pre><p>注意：<br>    1. finally不能单独使用,必须和try一起使用<br>    2. finally一般用于<strong>资源释放</strong>(资源回收),无论程序是否出现异常,<strong>最后都要资源释放(IO)</strong></p>
<h3 id="2-5-异常注意事项"><a href="#2-5-异常注意事项" class="headerlink" title="2.5 异常注意事项"></a>2.5 异常注意事项</h3><p>多个异常使用捕获又该如何处理？</p>
<ol>
<li>多个异常分别处理。（多个try-catch）</li>
<li>多个异常一次捕获，多次处理。（一个try，多个catch）<br>注意事项：</li>
</ol>
<ul>
<li>catch里边定义的异常变量,如果有子父类关系,那么子类的异常变量必须写在上边,否则就会报错</li>
</ul>
<blockquote>
<p><strong>“多态”</strong>：try中的子类异常也可以被父类异常变量catch到进行处理，所以下面的子类异常变量无法被使用，就会报错。</p>
</blockquote>
<ol start="3">
<li>多个异常一次捕获一次处理。（catch的异常变量直接写为<code>Exception e</code>）</li>
</ol>
<p><strong>*运行时异常</strong>被抛出可以不处理，即不捕获也不声明抛出。<br> 默认给虚拟机处理,终止程序,什么时候不抛出运行时异常了,再来继续执行程序</p>
<p>*尽量不要在finally中写return，否则返回的总是finally中的return。</p>
<p>*子父类的异常:<br>子类重写父类方法时，</p>
<ol>
<li><strong>抛出和父类相同的异常</strong></li>
<li>或者抛出父类异常的子类</li>
<li>或者不抛出异常</li>
<li>如果父类方法没有抛出异常，子类也不可抛出异常。<br> 此时子类产生该异常，只能捕获处理，不能声明抛出</li>
</ol>
<h2 id="第三章-自定义异常"><a href="#第三章-自定义异常" class="headerlink" title="第三章 自定义异常"></a>第三章 自定义异常</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>自定义异常类:<br>        java提供的异常类, 不够我们使用, 需要自己定义一些异常类<br><strong>格式</strong>:<br>        public class XXXExcepiton extends Exception | RuntimeException{<br>            添加一个<strong>空参数</strong>的构造方法<br>            添加一个<strong>带异常信息</strong>的构造方法<br>        }<br>** 注意**:</p>
<ol>
<li>自定义异常类一般都是以Exception结尾,说明该类是一个异常类</li>
<li>自定义异常类,必须的继承Exception或者RuntimeException</li>
</ol>
<p>-<strong>继承</strong>Exception：那么自定义的异常类就是一个编译期异常,如果方法内部抛出了<font color = #F9000>编译期异常</font>,就必须处理这个异常,要么throws,要么try…catch<br>-继承RuntimeException：那么自定义的异常类就是一个<font color = #F9000>运行期异常</font>,无需处理,交给虚拟机处理(中断处理)</p>
<h3 id="3-2-自定义异常练习"><a href="#3-2-自定义异常练习" class="headerlink" title="3.2 自定义异常练习"></a>3.2 自定义异常练习</h3><p><a href="https://github.com/two-fire/Java_Basic" target="_blank" rel="noopener">Demo06MyException</a></p>
<h2 id="第四章-多线程"><a href="#第四章-多线程" class="headerlink" title="第四章 多线程"></a>第四章 多线程</h2><h3 id="4-1-并发与并行"><a href="#4-1-并发与并行" class="headerlink" title="4.1 并发与并行"></a>4.1 并发与并行</h3><p>并发：交替执行（单CPU系统）<br>并行：同时执行（多CPU系统）</p>
<h3 id="4-2-进程与线程"><a href="#4-2-进程与线程" class="headerlink" title="4.2 进程与线程"></a>4.2 进程与线程</h3><p>· 进程：进入到内存中的应用程序。<br>进程也是程序的一次执行过程，是<strong>系统运行程序</strong>的基本单位</p>
<p><img src="https://img-blog.csdnimg.cn/20200903154306476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>· 线程：进程的一个执行单元。<br><img src="https://img-blog.csdnimg.cn/20200903154339725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>· 线程调度：<br>    - 分时调度：所有线程轮流进行，均分时间<br>    - 抢占式调度：优先让优先级高的线程使用 CPU，如果优先级相同，就随机。<br>    注：<br>    java使用的是抢占式调度；<br>    win10设置优先级：任务管理器–&gt;详细信息–&gt;右键某应用程序–&gt;选择设置优先级</p>
<p>对于CPU的一个核而言，某个时刻，只能执行一个线程。多线程程序并不能提高<strong>程序运行速度</strong>，但能提高<strong>程序运行效率</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200903154359179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>· 主线程：执行主方法（main()）的线程</p>
<p>· 单线程程序：java程序中只有一个线程</p>
<ul>
<li>执行从main方法开始，从上到下依次执行。<br>所以中间一旦出现异常，中止程序，后面代码不能执行。<br><img src="https://img-blog.csdnimg.cn/20200903154419848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="4-3-创建线程类-一"><a href="#4-3-创建线程类-一" class="headerlink" title="4.3 创建线程类(一)"></a>4.3 创建线程类(一)</h3><p>1）创建多线程程序的第一种方式: 创建Thread类的子类<br><code>java.lang.Thread</code>类: 是描述线程的类,我们想要实现多线程程序,就必须继承Thread类</p>
<p> · 实现步骤:</p>
<ol>
<li>创建一个Thread类的子类</li>
<li>在Thread类的子类中<font color = #F9000>重写</font>Thread类中的<font color = #F9000>run方法</font>, 设置线程任务(开启线程要做什么)</li>
<li>创建Thread类的子类对象</li>
<li><font color = #F9000>调用</font>Thread类中的方法<font color = #F9000>start方法</font>,开启新的线程,<font color = #F9000>执行run方法</font><blockquote>
<p>void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。<br> 1）结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程, 执行其 run 方法）。<br> 2）<strong>多次启动一个线程是非法的</strong>。特别是当线程已经结束执行后，不能再重新启动。<br> 3）java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3.创建Thread类的子类对象</span></span><br><span class="line">        MyTread mt = <span class="keyword">new</span> MyTread();</span><br><span class="line">        <span class="comment">// 4.调用Thread类中的方法start方法,开启新的线程,执行run方法</span></span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个Thread类的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 2.在Thread类的子类中重写Thread类中的run方法,设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"run"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
案例“随机打印结果”见GIthub：<a href="https://github.com/two-fire/Java_Basic" target="_blank" rel="noopener">Demo07Thread</a></li>
</ol>
<h3 id="4-4-多线程原理"><a href="#4-4-多线程原理" class="headerlink" title="4.4 多线程原理"></a>4.4 多线程原理</h3><p>多线程程序_随机打印结果原理：<br><img src="https://img-blog.csdnimg.cn/20200903154449466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>多线程程序_随机打印内存图解：<br><img src="https://img-blog.csdnimg.cn/20200903154505588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4-5-Thread类"><a href="#4-5-Thread类" class="headerlink" title="4.5 Thread类"></a>4.5 Thread类</h3><h4 id="4-5-1-常用方法"><a href="#4-5-1-常用方法" class="headerlink" title="4.5.1 常用方法"></a>4.5.1 常用方法</h4><p>· 获取线程的名称两种方法:<br>    1. 使用<strong>Thread类</strong>中的方法<code>getName()</code><br>    <code>String getName()</code> 返回该线程的名称。<br>    2. 可以先获取到<strong>当前正在执行的线程</strong>,使用线程中的方法getName()获取线程的名称<br>    <code>static Thread currentThread()</code> 返回对当前正在执行的线程对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在run方法中获取的是新线程的名称</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">String name = getName(); </span><br><span class="line">System.out.println(name); <span class="comment">// Thread-0，……</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">System.out.println(t); <span class="comment">// Thread[Thread-0,5,main]</span></span><br><span class="line">String name = t.getName();</span><br><span class="line">System.out.println(name); <span class="comment">// Thread-1</span></span><br><span class="line"><span class="comment">//链式编程</span></span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line"><span class="comment">// 如果想获取主线程名称，就在主线程中编程。但不能使用方法一。</span></span><br></pre></td></tr></table></figure>

<p>· 设置线程名称两种方法（了解）：<br>    1. 使用Thread类中的方法setName(名字)<br>                void setName(String name) 改变线程名称，使之与参数 name 相同。<br>    2. 创建一个带参数的构造方法,参数传递线程的名称;调用父类的带参构造方法,把线程名称传递给父类,让父类(Thread)给子线程起一个名字<br>                <code>Thread(String name)</code>分配新的 Thread 对象。<br>    e.g 在main方法中，开启多线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">     MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.setName(<span class="string">"小强"</span>);</span><br><span class="line">        mt.start();</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">new</span> MyThread(<span class="string">"旺财"</span>).start();</span><br></pre></td></tr></table></figure>

<pre><code>-  `public static void sleep(long millis)`: 使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。&lt;font color = #F9000&gt;1000ms = 1s&lt;/font&gt;
毫秒数结束之后,线程继续执行
方法有异常，可以用try-catch处理异常</code></pre><h3 id="4-6-Runnable"><a href="#4-6-Runnable" class="headerlink" title="4.6 Runnable"></a>4.6 Runnable</h3><h4 id="4-6-1-创建线程类-二"><a href="#4-6-1-创建线程类-二" class="headerlink" title="4.6.1 创建线程类(二)"></a>4.6.1 创建线程类(二)</h4><p>2）创建多线程程序的第二种方式: 实现 <code>java.lang.Runnable</code><br>接口<br>    - Runnable 接口应该由那些<font color = #F9000>打算通过某一线程执行其实例的类</font>来实现。类必须定义一个称为 <font color = #F9000>run 的无参数方法</font>。</p>
<pre><code>- java.lang.Thread类的构造方法
    `Thread(Runnable target)` 分配新的 Thread 对象。
    `Thread(Runnable target, String name)` 分配新的 Thread 对象。</code></pre><p>实现步骤:<br>    1. 创建一个Runnable接口的实现类<br>    2. 在实现类中重写Runnable接口的run方法,设置线程任务<br>    3. 创建一个Runnable接口的实现类对象<br>    4. 创建Thread类对象,构造方法中传递Runnable接口的实现类对象<br>    5. 调用Thread类中的start方法,开启新的线程执行run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 3.创建一个Runnable接口的实现类对象</span></span><br><span class="line">       RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">       <span class="comment">// 4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">       Thread t = <span class="keyword">new</span> Thread(run);</span><br><span class="line">       <span class="comment">//  5.调用Thread类中的start方法,开启新的线程执行run方法</span></span><br><span class="line">       t.start();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 2.在实现类中重写Runnable接口的run方法,设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述案例见GitHub：<a href="https://github.com/two-fire/Java_Basic" target="_blank" rel="noopener">Demo08Runnable</a></p>
<h4 id="4-6-2-Tread和Runnable区别"><a href="#4-6-2-Tread和Runnable区别" class="headerlink" title="4.6.2 Tread和Runnable区别"></a>4.6.2 Tread和Runnable区别</h4><p>实现Runnable接口创建多线程程序的好处:<br>    1. 避免了单继承的局限性<br>    一个类只能继承一个类，类继承了Thread类就不能继承其他的类<br>    实现了Runnable接口，还可以继承其他的类，实现其他的接口<br>    2. 增强了程序的扩展性,降低了程序的耦合性(解耦)<br>    实现Runnable接口的方式，把<font color = #F9000>设置线程任务和开启新线程</font>进行了分离(解耦)<br>    · 实现类中,重写了run方法:用来设置线程任务<br>    · 创建Thread类对象,调用start方法:用来开启新线程</p>
<h4 id="4-7-3-匿名内部类方式实现线程创建"><a href="#4-7-3-匿名内部类方式实现线程创建" class="headerlink" title="4.7.3 匿名内部类方式实现线程创建"></a>4.7.3 匿名内部类方式实现线程创建</h4><p>匿名内部类作用: 简化代码<br>    - 把<strong>子类继承父类</strong>，<strong>重写父类的方法</strong>，<strong>创建子类对象</strong>合为一步完成<br>    - 把<strong>实现类实现类接口</strong>，<strong>重写接口中的方法</strong>，<strong>创建实现类对象</strong>合成一步完成<br>匿名内部类的最终产物: 子类/实现类对象, 而这个类没有名字</p>
<p>格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new 父类&#x2F;接口() &#123;</span><br><span class="line">    重复父类&#x2F;接口中的方法</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>e.g</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程的父类是Thread</span></span><br><span class="line"><span class="comment">// new MyThread().start();</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	<span class="comment">//重写run方法,设置线程任务</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的接口Runnable</span></span><br><span class="line"><span class="comment">//Runnable r = new RunnableImpl(); // 多态</span></span><br><span class="line">Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">	<span class="comment">//重写run方法,设置线程任务</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		···                </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化接口的方式</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">	<span class="comment">//重写run方法,设置线程任务</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		···</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio初次使用no devices灰色</title>
    <url>/2020/09/02/Android-Studioo%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8no-devices%E7%81%B0%E8%89%B2/</url>
    <content><![CDATA[<p><strong>Android Studio出现:Cause: unable to find valid certification path to requested target</strong></p>
<p><a href="https://blog.csdn.net/qq_17827627/article/details/99404177" target="_blank" rel="noopener">参考博客</a></p>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><ol>
<li>找不到可用证书.Android Studio没有获得使用网络的权限，无法访问</li>
<li>与网速有关，可以多次下载尝试</li>
</ol>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol>
<li>从<a href="https://bintray.com/bintray/jcenter获取证书。" target="_blank" rel="noopener">https://bintray.com/bintray/jcenter获取证书。</a></li>
</ol>
<ul>
<li>chrome打开打开<a href="https://bintray.com/bintray/jcenter" target="_blank" rel="noopener">https://bintray.com/bintray/jcenter</a></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200902145752506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>一直下一步，将证书导出到本地某个位置。<br><img src="https://img-blog.csdnimg.cn/20200902145856856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<p>*打开Android Studio，添加导出的证书，并勾选图中位置<br><img src="https://img-blog.csdnimg.cn/20200902150134840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol start="2">
<li>在build.gradle中两个repositories里面添加一句代码，写在第一句。即google()之前。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">maven&#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200902145541131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>安装和踩坑</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU的乱序执行</title>
    <url>/2020/09/21/CPU%E7%9A%84%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h2><p>乱序：在不影响最终结果的情况下（单线程前后两条指令没有关联），CPU执行指令不一定是顺序的。充分利用cpu</p>
<p>对象的创建过程：<br><img src="https://img-blog.csdnimg.cn/20200921173804629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li>new：申请一块内存，成员变量设为默认值（半初始化状态）</li>
<li>特殊调用<init> ，赋初始值</li>
<li>t和new T()相关联</li>
</ol>
<p>注：</p>
<ul>
<li>duplicate new完之后在栈帧里面存了一个引用，指向m=8这个对象，并不是本地变量表中的t。dup就是在上面再复制一份这个栈中的内容</li>
<li>invokespecial会消耗一个值，把它弹出来，把它指向的对象，调用它的构造方法。这时候栈中只剩一个了。<br>只有在执行了invokespecial（特殊调用），执行了构造方法之后，m才会变成8。</li>
<li>astore_1的意思是把剩下的一个弹出来赋值给局部变量表的第一个位置。结束后，t才会指向m=8<br>注：局部变量表的第0个位置是this</li>
</ul>
<h3 id="禁止乱序"><a href="#禁止乱序" class="headerlink" title="禁止乱序"></a>禁止乱序</h3><p><img src="https://img-blog.csdnimg.cn/20200921173951288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>volatile可以禁止指令重排序<br>volatile并不是用原语来实现，用的是lock指令（锁屏障）</p>
<p>CPU层面：Intel有序性的保障就是原语（sfence，Ifence，mfence）或者锁总线。</p>
<p>注：硬件层面来讲，使用原语效率高于lock指令。但Intel CPU上有这三条原语，别的上不一定有。但这条lock指令，很多CPU都有。所以JVM在实现的时候（或者说是Hotspot），并没有根据不同CPU设计不同原语来执行，而是就用了一条lock指令来实行。</p>
<p>而在JVM层面：8个原则，4个内存屏障（LL LS SL SS）<br><img src="https://img-blog.csdnimg.cn/20200921180931836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>所谓的JVM实现和这个实现不是一个概念（JVM实现是虚拟机规范层面的，与硬件无任何关系）<br>![在这里插入图片描述](<a href="https://img-blog.csd" target="_blank" rel="noopener">https://img-blog.csd</a> nimg.cn/20200921174528494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center)<br>内存屏障：什么时候上面执行完了下面才能执行。</p>
<p><img src="https://img-blog.csdnimg.cn/20200921180530102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="合并写"><a href="#合并写" class="headerlink" title="合并写"></a>合并写</h2><p>write combining buffer<br>一般4字节<br>由于ALU速度太快，所以在写入L1的同时，写入一个WC Buffer，满了之后再直接更新到L2</p>
]]></content>
      <categories>
        <category>硬件基础知识</category>
        <category>CPU</category>
      </categories>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU基本组成</title>
    <url>/2020/09/20/CPU%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/</url>
    <content><![CDATA[<h2 id="CPU的基本组成"><a href="#CPU的基本组成" class="headerlink" title="CPU的基本组成"></a>CPU的基本组成</h2><ol>
<li><p>PC（Program Counter，程序计数器）<br>记录当前指令地址</p>
</li>
<li><p>Registers（寄存器）<br>暂时存储CPU计算需要用到的数据。是存取速度最快的</p>
</li>
</ol>
<blockquote>
<p>64位CPU就是说该CPU的寄存器一次性能存64位的数字。而ALU和寄存器间也有电路连接，一次性也能读64位</p>
</blockquote>
<ol start="3">
<li>ALU（Arithmetic &amp; Logic Unit，运算逻辑单元）</li>
</ol>
<blockquote>
<p>JVM ：可以当成是Java的模拟计算机<br>本地变量表：相当于寄存器</p>
</blockquote>
<blockquote>
<p><strong>超线程</strong>：一个ALU对应多组寄存器|多个PC<br>线程的上下文切换：把上一个正在运行的线程中寄存器的东西和地址拿出来到缓存，把另一个切换进来。<br><img src="https://img-blog.csdnimg.cn/20200920203656198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<ol start="4">
<li><p>CU(Control Unit,控制单元)<br>对中断信号进行控制</p>
</li>
<li><p>MMU(Memory Management Unit,内存管理单元)<br>最早都是软件实现，现在都是软硬件结合实现</p>
</li>
<li><p>cache<br>存储器的层次结构<br><img src="https://img-blog.csdnimg.cn/20200920205302126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>为什么需要cache<br><img src="https://img-blog.csdnimg.cn/20200920205335209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>缓存物理结构：<br><img src="https://img-blog.csdnimg.cn/20200920212850285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>按块读取数据<br>DMA直接发一条指令，直接告诉硬盘把数据装到内存某个位置，硬盘直接与内存打交道。</p>
<h2 id="cache-line"><a href="#cache-line" class="headerlink" title="cache line"></a>cache line</h2><p>Intel中一个缓存行大小为64字节</p>
<p><strong>缓存行对齐 **<br><img src="https://img-blog.csdnimg.cn/20200920221229687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如果x，y处于一个缓存行。x被修改了，通知其他用到这个行的cpu这个行中数据过期了，执行下一句对y修改的指令时需要重新读一遍。效率非常低。<br>如果将x，y拆开（位于两个缓存行），效率就会增高。<br><img src="https://img-blog.csdnimg.cn/2020092022170032.png#pic_center" alt="在这里插入图片描述"><br>一个64B的缓存行最多能装8个long。拿空间换时间，保证x，y一定不位于同一行。通知次数减少。<br>缓存一致性协议不好使时（缓存行装不下，或缓存行数据不允许再往里面装的时候）就要</strong>锁总线**。<br>上锁等情况会强制刷新，其他情况下不一定。</p>
<p>上述可知，两个都需要保持线程一致性，就要保持数据可见性。在这种情况下，两个数字存在一起的时候，反而容易产生伪共享现象，效率反而降低。</p>
<blockquote>
<p><strong>伪共享</strong><br>“我这里改了x通知你，你这里改了y又通知我”的现象。</p>
</blockquote>
<p>因此诞生了编程模式。叫做“<font color = #F9000>缓存行对齐</font>”。<br>对于有些特别敏感的数字，会存在线程高竞争访问。为了保证不发生伪共享，可以使用缓存行对齐的编程方式。</p>
<p><strong>disruptor 框架</strong><br><img src="https://img-blog.csdnimg.cn/20200920222514489.png#pic_center" alt="在这里插入图片描述"><br>是一个并发框架，核心是一个环形 buffer<br>前面、后面各有七个long，这样无论怎么截取，保证整个缓存行只有它一个数据。</p>
<p>JDK7中，很多采用long padding提高效率<br>JDK1.8里面，添加了 @Contended 注解，需要加上：JVM -XX:-RestrictContended 可以保证变量不位于同一个缓存行。</p>
]]></content>
      <categories>
        <category>硬件基础知识</category>
        <category>CPU</category>
      </categories>
      <tags>
        <tag>CPU</tag>
        <tag>缓存行</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS样式</title>
    <url>/2021/03/08/CSS%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h2><p><font color='red'><strong>Cascading Style Sheets 层叠样式表</strong></font></p>
<blockquote>
<p>HTML文件想象成房子骨架，里面的<strong>标签</strong>（块元素、行内元素）就是搭房子的<strong>砖</strong>，<strong>CSS</strong>负责装修(<strong>美化页面</strong>)，让静态页面好看一些。</p>
</blockquote>
<h3 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h3><pre><code>放置在style中的是内部样式</code></pre><h4 id="1-1体验样式："><a href="#1-1体验样式：" class="headerlink" title="1.1体验样式："></a>1.1体验样式：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;体验样式&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;!-- 样式一般是放置在style标签里面 --&gt;</span><br><span class="line">	&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">		div&#123;</span><br><span class="line">			color: yellow；&#x2F;*文字颜色*&#x2F;</span><br><span class="line"> 			font-size:30px;&#x2F;*文字大小*&#x2F;</span><br><span class="line">			background-color: red;&#x2F;*背景色*&#x2F;</span><br><span class="line">			text-align: center; &#x2F;*字体居中*&#x2F;</span><br><span class="line">			border: 5px solid black; &#x2F;*</span><br><span class="line">			边框颜色粗细*&#x2F;</span><br><span class="line">			opacity: .5; &#x2F;*透明度*&#x2F;</span><br><span class="line">	&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div&gt;祖国花朵&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-2标签选择器"><a href="#1-2标签选择器" class="headerlink" title="1.2标签选择器"></a>1.2标签选择器</h4><pre><code>标签选择器：常用样式中选择匹配标签</code></pre><p>web领域样式分为三种：</p>
<ul>
<li>外部样式</li>
<li><font color='red'><strong>内部样式</strong></font></li>
<li>行内样式</li>
</ul>
<p>内部样式需要书写在head中，利用子元素<font color='red'><strong>双闭合标签style</strong></font>完成。<br>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">    标签名字&#123;</span><br><span class="line">        属性:属性值;</span><br><span class="line">        属性:属性值;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p><strong>常用属性</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*文字颜色设置*&#x2F;</span><br><span class="line">color: orange;</span><br><span class="line">&#x2F;*设置字号，最小12px，最大上不封顶*&#x2F;</span><br><span class="line">font-size: 14px;</span><br><span class="line">&#x2F;*背景颜色设置*&#x2F;</span><br><span class="line">background-color: red;</span><br><span class="line">&#x2F;*文本对齐方式*&#x2F;</span><br><span class="line">text-align: center;</span><br><span class="line">&#x2F;*字体样式设置*&#x2F;</span><br><span class="line">font-style: italic;</span><br><span class="line">&#x2F;*透明度设置，0~1*&#x2F;</span><br><span class="line">opacity: 0.3;</span><br><span class="line">&#x2F;*光标放到该标签中，会变为小手*&#x2F;</span><br><span class="line">cursor: pointer;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-id选择器"><a href="#1-3-id选择器" class="headerlink" title="1.3 id选择器"></a>1.3 id选择器</h4><p>上面案例是通过标签名字匹配页面中对应标签设置（内部样式），除此之外还可以通过id选择器匹配标签（节点element）</p>
<blockquote>
<p>命名标识符规范<br>可以是数字、字母、下划线、$<br>不能以数字开头<br>不能是关键字和保留字</p>
</blockquote>
<p><strong>一般情况下，id不重名，即属性值唯一</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;10id选择器&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">		#box&#123;</span><br><span class="line">			color: cyan;</span><br><span class="line">			&#x2F;*文本的描述 没用下划线*&#x2F;</span><br><span class="line">			text-decoration: none;</span><br><span class="line">		&#125;</span><br><span class="line">		#box1&#123;</span><br><span class="line">			&#x2F;*列表默认样式设置*&#x2F;</span><br><span class="line">			list-style: square;&#x2F;*变成正方形*&#x2F;</span><br><span class="line">		&#125;</span><br><span class="line">		#cur&#123;</span><br><span class="line">			color: cyan;</span><br><span class="line">		&#125;</span><br><span class="line">		#box2&#123;</span><br><span class="line">			&#x2F;*列表默认样式设置*&#x2F;</span><br><span class="line">			list-style: circle;&#x2F;*变成空心圆*&#x2F;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.taobao.com&quot; id&#x3D;&quot;box&quot;&gt;淘宝&lt;&#x2F;a&gt;</span><br><span class="line">	&lt;ul id&#x3D;&quot;box1&quot;&gt;</span><br><span class="line">		&lt;li&gt;初三&lt;&#x2F;li&gt;</span><br><span class="line">		&lt;li id&#x3D;&quot;cur&quot;&gt;初三&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;&#x2F;ul&gt;</span><br><span class="line">	&lt;ol id&#x3D;&quot;box2&quot;&gt;</span><br><span class="line">		&lt;li&gt;初一&lt;&#x2F;li&gt;</span><br><span class="line">		&lt;li id&#x3D;&quot;box2&quot;&gt;初一&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;&#x2F;ol&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在标签（开始标签）这里添加一个id属性，对应右侧属性值</li>
<li>在style标签里面（内部样式）# + 对应节点id的属性值</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">属性值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">text-decoration</td>
<td align="center">none、underline、overline、line-through</td>
</tr>
<tr>
<td align="center">list-style</td>
<td align="center">none、circle、square</td>
</tr>
</tbody></table>
<h4 id="1-4-class选择器"><a href="#1-4-class选择器" class="headerlink" title="1.4 class选择器"></a>1.4 class选择器</h4><p>注意：id选择器属性值一般唯一，class选择器可重名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;类选择器&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">		.current&#123;</span><br><span class="line">			color: skyblue;</span><br><span class="line">			background-color: red;</span><br><span class="line">			text-align: center;</span><br><span class="line">		&#125;</span><br><span class="line">		.cur&#123;</span><br><span class="line">			color: cyan;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;current&quot;&gt;</span><br><span class="line">		祖国花朵</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		祖国花朵1</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		祖国花朵2</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;current&quot;&gt;</span><br><span class="line">		祖国花朵</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		祖国花朵11</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		祖国花朵22</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div&gt; 今天是&lt;span class&#x3D;&quot;cur&quot;&gt;3.9 &lt;&#x2F;span&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-背景系列样式"><a href="#1-5-背景系列样式" class="headerlink" title="1.5 背景系列样式"></a>1.5 背景系列样式</h4><p>背景系列属性有如下几个：<br>background-color：背景颜色<br>background-img：背景图<br>background-repeat：背景图重复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;背景样式&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">		div &#123;</span><br><span class="line">			&#x2F;*宽高设置*&#x2F;</span><br><span class="line">			width: 720px;</span><br><span class="line">			height: 720px;</span><br><span class="line">			&#x2F;*背景色*&#x2F;</span><br><span class="line">			&#x2F;*background-color: red;*&#x2F;</span><br><span class="line">			&#x2F;*设置背景图*&#x2F;</span><br><span class="line">			&#x2F;*background-image: url(2.jpg);*&#x2F;</span><br><span class="line">			&#x2F;*背景重复设置*&#x2F;</span><br><span class="line">			&#x2F;*background-repeat: no-repeat;*&#x2F;</span><br><span class="line">			&#x2F;*简写*&#x2F;</span><br><span class="line">			background: red url(2.jpg) no-repeat;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><p>在前端web开发中样式可以放置在css文件里面，在页面中通过<font color='red'><strong>link标签</strong></font>可以引入<font color='red'><strong>外部文件样式</strong></font>。</p>
<p>比如：我们在程序中创建css文件夹，这个文件夹中有一个default.css文件，这个文件里面可以写你的样式。像这种样式前端工程师称为<strong>外部样式</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*静态页面*&#x2F;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;外部样式&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;css&#x2F;default.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">		&lt;p&gt;昨天下雨了，&lt;span id&#x3D;&quot;cur&quot;&gt;冷&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果想要引入外部css文件，需要通过link标签进行引入。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*default.css*&#x2F;</span><br><span class="line">.box&#123;</span><br><span class="line">	width: 280px;</span><br><span class="line">	height: 280px;</span><br><span class="line">	background: red;</span><br><span class="line">&#125;</span><br><span class="line">#cur&#123;</span><br><span class="line">	color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><p>在给标签设置样式的时候，可以选择外部样式、内部样式、行内样式（web开发很用）<br>行内样式：直接在开始标签里设置，通过style进行属性设置<br>行内样式写法：<br>&lt;标签名字 style=”属性:属性值;属性:属性值;”&gt;文本&lt;/标签名字&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;行内样式&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p style&#x3D;&quot;width: 600px;height: 300px;font-size: 30px;color: red;&quot;&gt;最近热门话题是暴力裁员&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="center">样式</th>
<th align="center">写法</th>
<th align="center">优先级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">外部样式</td>
<td align="center">link标签引入</td>
<td align="center">最低</td>
</tr>
<tr>
<td align="center">内部样式</td>
<td align="center">&lt;style&gt;&lt;/style&gt;</td>
<td align="center">第二</td>
</tr>
<tr>
<td align="center">行内样式</td>
<td align="center">&lt;标签名字 style=”属性:属性值;属性:属性值;”&gt;文本&lt;/标签名字&gt;</td>
<td align="center">最高</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
        <category>Web前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas基本使用</title>
    <url>/2021/03/10/Canvas%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Canvas简介"><a href="#Canvas简介" class="headerlink" title="Canvas简介"></a>Canvas简介</h2><p>canvas是<strong>html5中新增的</strong>、<strong>结构层</strong>中的一个<strong>双闭合标签</strong>。我们可在行为层中操作画布，可以在canvas中绘制一些简单图形、对于图片进行裁切、可以实现一些简单2D动画、显示视频。</p>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;&lt;device-width&gt;, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;canvas&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        canvas&#123;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;canvas width&#x3D;&quot;600&quot; height&#x3D;&quot;400&quot;&gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 获取canvas标签</span><br><span class="line">    var canvas &#x3D; document.querySelector(&quot;canvas&quot;);</span><br><span class="line">    &#x2F;&#x2F; 画布中任何操作必须通过2D上下文进行操作[画笔]</span><br><span class="line">    var ctx &#x3D; canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    console.log(ctx);</span><br><span class="line">    &#x2F;&#x2F; 一定注意，画布中任何操作都是通过ctx的属性或者方法进行操作</span><br><span class="line">    &#x2F;&#x2F; 绘制矩形</span><br><span class="line">    ctx.fillStyle&#x3D; &quot;skyblue&quot;;</span><br><span class="line">    ctx.fillRect(100,200,100,100);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制圆</span><br><span class="line">&#x2F;&#x2F;通过绘制路径形式绘制圆</span><br><span class="line">ctx.beginPath();</span><br><span class="line">&#x2F;&#x2F; x,y,半径,从0~2pi,顺时针</span><br><span class="line">ctx.arc(200,300,50,0,Math.PI*2,true);</span><br><span class="line">ctx.fillStyle &#x3D; &quot;red&quot;;</span><br><span class="line">&#x2F;&#x2F; 开始填充</span><br><span class="line">ctx.fill();</span><br><span class="line">&#x2F;&#x2F; 边框设置</span><br><span class="line">ctx.lineWidth &#x3D; 20;</span><br><span class="line">ctx.strokeStyle &#x3D; &quot;pink&quot;;</span><br><span class="line">&#x2F;&#x2F; 开始绘制</span><br><span class="line">ctx.stroke();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210310143112867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>浏览器认为canvas是一张图片</li>
<li>canvas标签有默认宽（300）和高（150），不用加px单位</li>
<li>canvas宽和高<font color='red'><strong>不要写样式，会变形</strong></font>。务必要用属性进行设置</li>
<li>canvas标签文本、子标签都没有任何意义，必须要用ctx画笔进行操作</li>
<li>canvas最基本的功能是绘图，需要注意画布任何操作都是通过2d上下文进行渲染</li>
</ul>
<blockquote>
<p>任何标签都有id和name属性</p>
</blockquote>
<blockquote>
<p>three.js 函数库<br>炫酷的3d效果，底层是WebJL实现的,，是webGL中一个实用函数库</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Web前端</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>DAY0-摸爬滚打</title>
    <url>/2020/09/13/DAY0-%E6%91%B8%E7%88%AC%E6%BB%9A%E6%89%93/</url>
    <content><![CDATA[<p>&emsp; 上学期学完操作系统，特别想做一个出来玩玩，但是一脸懵逼。因为本邮os的课程全理论，实操才发现，这其中的鸿沟有多大。<br>&emsp; 我首先查了下知乎、百度，看别人是怎么做的。开始我打算尝试清华ucore实验课，c语言写的os是15年的，而20年新课程主要用了Rust语言。我想先用c语言写，但15年的集成环境包已经找不到了，只能自己下载配置环境，但具体的操作课程很模糊，我对这些软件工具又不熟悉，整了一天装了个大概，之后的操作就很艰难。所以我又打算换一个方向。<br>&emsp; 很多人推荐《自己动手写操作系统》这本书，我翻了一下，发现基本全是用的汇编，我想锻炼下c语言能力，所以也放弃了。<br>&emsp; 之后也看了一下《30天》，但这时候发现了网易云课堂李志军老师的操作系统课，感觉豁然开朗。计划在一个月内完成这个操作系统，会在博客上跟进这个小项目。</p>
]]></content>
      <categories>
        <category>自制操作系统</category>
      </categories>
      <tags>
        <tag>hit-oslab</tag>
        <tag>os</tag>
        <tag>linux-0.11</tag>
      </tags>
  </entry>
  <entry>
    <title>DAY1-操作系统的引导（附环境搭建）</title>
    <url>/2020/09/13/DAY1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC%EF%BC%88%E9%99%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%89/</url>
    <content><![CDATA[<h2 id="实验二-操作系统的引导-环境搭建"><a href="#实验二-操作系统的引导-环境搭建" class="headerlink" title="实验二 操作系统的引导 + 环境搭建"></a>实验二 操作系统的引导 + 环境搭建</h2><p>主要学习网易云课堂上哈工大李志军的(操作系统基础)和(操作系统原理与实践)[<a href="https://www.lanqiao.cn/courses/115/learning/?id=568]" target="_blank" rel="noopener">https://www.lanqiao.cn/courses/115/learning/?id=568]</a><br>(实验说明书)[<a href="https://hoverwinter.gitbooks.io/hit-oslab-manual/content/bochs-manual.html]" target="_blank" rel="noopener">https://hoverwinter.gitbooks.io/hit-oslab-manual/content/bochs-manual.html]</a></p>
<p>注：我是Ubuntu16.04环境下，按照下面步骤进行的，但是到<code>../../run</code>这步时，会出现下面情况。<br><img src="https://img-blog.csdnimg.cn/20200913210747834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>按照(Ubuntu18.04搭建linux0.11实验环境)[<a href="https://blog.csdn.net/qq_40758751/article/details/88707214?utm_medium=distribute.pc_relevant.none-task-blog-blogcommendfrommachinelearnpai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-blogcommendfrommachinelearnpai2-3.channel_param]这篇博客，最终成功。里面安装包百度云：" target="_blank" rel="noopener">https://blog.csdn.net/qq_40758751/article/details/88707214?utm_medium=distribute.pc_relevant.none-task-blog-blogcommendfrommachinelearnpai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-blogcommendfrommachinelearnpai2-3.channel_param]这篇博客，最终成功。里面安装包百度云：</a><br>链接：<a href="https://pan.baidu.com/s/1gePywI5Q2vOGiZu0ZBwKQg" target="_blank" rel="noopener">https://pan.baidu.com/s/1gePywI5Q2vOGiZu0ZBwKQg</a><br>提取码：cwnz</p>
<ol>
<li><p><a href="https://gitee.com/ivan_allen/hit-oslab/tree/master/" target="_blank" rel="noopener">https://gitee.com/ivan_allen/hit-oslab/tree/master/</a>   clone到Ubuntu16.04虚拟机中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;gitee.com&#x2F;ivan_allen&#x2F;hit-oslab.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据readme解压安装，执行完下面句子后，Home中会出现oslab目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd hit-oslab</span><br><span class="line">$ .&#x2F;setup.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入oslab目录下的boot</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd  ~&#x2F;oslab&#x2F;linux-0.11&#x2F;boot&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行下面两个命令编译和链接 bootsect.s：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ as86 -0 -a -o bootsect.o bootsect.s</span><br><span class="line">$ ld86 -0 -s -o bootsect bootsect.o</span><br></pre></td></tr></table></figure>
</li>
<li><p>用<code>ls -l</code>查看到bootsect有544字节（bootsect 是编译、链接后的目标文件），但引导程序必须要正好占用一个磁盘扇区，即 512 个字节。所以在 Ubuntu 下用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dd bs&#x3D;1 if&#x3D;bootsect of&#x3D;Image skip&#x3D;32</span><br></pre></td></tr></table></figure>
<p>生成的 Image 就是去掉文件头的 bootsect。</p>
</li>
<li><p>run</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 当前的工作路径为 &#x2F;home&#x2F;shiyanlou&#x2F;oslab&#x2F;linux-0.11&#x2F;boot&#x2F;</span><br><span class="line"></span><br><span class="line"># 将刚刚生成的 Image 复制到 linux-0.11 目录下</span><br><span class="line">$ cp .&#x2F;Image ..&#x2F;Image</span><br><span class="line"></span><br><span class="line"># 执行 oslab 目录中的 run 脚本</span><br><span class="line">$ ..&#x2F;..&#x2F;run</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="6-3的实验结果"><a href="#6-3的实验结果" class="headerlink" title="6.3的实验结果"></a>6.3的实验结果</h3><p><strong>代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">！&#x2F;home&#x2F;ly&#x2F;oslab&#x2F;linux-0.11&#x2F;boot&#x2F;bootsect.s</span><br><span class="line">.globl begtext, begdata, begbss, endtext, enddata, endbss</span><br><span class="line">.text</span><br><span class="line">begtext:</span><br><span class="line">.data</span><br><span class="line">begdata:</span><br><span class="line">.bss</span><br><span class="line">begbss:</span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">BOOTSEG  &#x3D; 0x07c0			! boot-sector的原始地址(段基址)</span><br><span class="line">INITSEG  &#x3D; 0x9000			! 将bootsect移到这里</span><br><span class="line"></span><br><span class="line">entry _start				! 告知链接程序，从start标号开始执行</span><br><span class="line">_start:</span><br><span class="line">	! 首先读入光标位置</span><br><span class="line">	mov		ah,#0x03</span><br><span class="line">	xor 	bh,bh</span><br><span class="line">	int	0x10</span><br><span class="line">	! 显示字符串 “Hello OS world, my name is LY”</span><br><span class="line">	mov 	cx,#35</span><br><span class="line">    mov 	bx,#0x0007</span><br><span class="line">   	mov 	bp,#msg1</span><br><span class="line">	</span><br><span class="line">	! es:bp 是显示字符串的地址</span><br><span class="line">	mov	ax,#BOOTSEG</span><br><span class="line">	mov	es,ax</span><br><span class="line">	mov	ax,#0x1301		! write string, move cursor</span><br><span class="line">	int	0x10	</span><br><span class="line">inf_loop:</span><br><span class="line">    	jmp inf_loop</span><br><span class="line"></span><br><span class="line">msg1:</span><br><span class="line">	.byte 13,10</span><br><span class="line">	.ascii &quot;Hello OS world, my name is LY&quot;</span><br><span class="line">	.byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">	.word 0xAA55</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">endtext:</span><br><span class="line">.data</span><br><span class="line">enddata:</span><br><span class="line">.bss</span><br><span class="line">endbss:</span><br></pre></td></tr></table></figure>

<p><strong>截图：</strong><br><img src="https://img-blog.csdnimg.cn/20200913224835616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
  </entry>
  <entry>
    <title>DAY2-操作系统的引导(二)</title>
    <url>/2020/09/13/DAY2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC(%E4%BA%8C)/</url>
    <content><![CDATA[<h3 id="6-4-bootsect-s读入setup-s"><a href="#6-4-bootsect-s读入setup-s" class="headerlink" title="6.4 bootsect.s读入setup.s"></a>6.4 bootsect.s读入setup.s</h3><ol>
<li><p>首先编写一个 setup.s，基本copy前面的bootsect.s代码，调整显示信息改成“Now we are in SETUP”。</p>
</li>
<li><p>编写 bootsect.s 中载入 setup.s 的关键代码load_setup和ok_load_setup部分，并去掉之前的无限循环代码。</p>
</li>
</ol>
<h3 id="6-5-再次编译"><a href="#6-5-再次编译" class="headerlink" title="6.5 再次编译"></a>6.5 再次编译</h3><ol>
<li>进入 linux-0.11 目录后<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make BootImage</span><br></pre></td></tr></table></figure>
此时会遇到<code>ERROR</code>，因为make根据Makefile指引执行了tools/build.c，而这里面会向我们要“system”的核心代码，所以我们先打个补丁。</li>
</ol>
<h3 id="6-6-修改-build-c"><a href="#6-6-修改-build-c" class="headerlink" title="6.6 修改 build.c"></a>6.6 修改 build.c</h3><ol>
<li><p>build.c 从命令行参数得到 bootsect、setup 和 system 内核的文件名，将三者做简单的整理后一起写入 Image。<br>所以我们注释掉 build.c 的尾部，忽略所有与system相关的工作。</p>
</li>
<li><p>再次编译运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~&#x2F;oslab&#x2F;linux-0.11</span><br><span class="line">$ make BootImage</span><br><span class="line">$ ..&#x2F;run</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="6-6实验结果"><a href="#6-6实验结果" class="headerlink" title="6.6实验结果"></a>6.6实验结果</h3><p><strong>运行截图：</strong><br><img src="https://img-blog.csdnimg.cn/20200914182406115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>相关代码：</strong><br>build.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//	if ((id=open(argv[3],O_RDONLY,0))&lt;0)</span></span><br><span class="line"><span class="comment">//		die("Unable to open 'system'");</span></span><br><span class="line"><span class="comment">//	if (read(id,buf,GCC_HEADER) != GCC_HEADER)</span></span><br><span class="line"><span class="comment">//		die("Unable to read header of 'system'");</span></span><br><span class="line"><span class="comment">//	if (((long *) buf)[5] != 0)</span></span><br><span class="line"><span class="comment">//		die("Non-GCC header of 'system'");</span></span><br><span class="line"><span class="comment">//	for (i=0 ; (c=read(id,buf,sizeof buf))&gt;0 ; i+=c )</span></span><br><span class="line"><span class="comment">//		if (write(1,buf,c)!=c)</span></span><br><span class="line"><span class="comment">//			die("Write call failed");</span></span><br><span class="line"><span class="comment">//	close(id);</span></span><br><span class="line"><span class="comment">//	fprintf(stderr,"System is %d bytes.\n",i);</span></span><br><span class="line"><span class="comment">//	if (i &gt; SYS_SIZE*16)</span></span><br><span class="line"><span class="comment">//		die("System is too big");</span></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setup.s</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! &#x2F;home&#x2F;ly&#x2F;oslab&#x2F;linux-0.11&#x2F;boot&#x2F;setup.s</span><br><span class="line">.globl begtext, begdata, begbss, endtext, enddata, endbss</span><br><span class="line">.text</span><br><span class="line">begtext:</span><br><span class="line">.data</span><br><span class="line">begdata:</span><br><span class="line">.bss</span><br><span class="line">begbss:</span><br><span class="line">.text</span><br><span class="line">entry _start				! 告知链接程序，从start标号开始执行</span><br><span class="line">_start:</span><br><span class="line">	! 首先读入光标位置</span><br><span class="line">	mov	ah,#0x03</span><br><span class="line">	xor 	bh,bh</span><br><span class="line">	int	0x10</span><br><span class="line">	</span><br><span class="line">	! 显示字符串“Now we are in SETUP”</span><br><span class="line">	mov	cx,#25</span><br><span class="line">	mov	bx,#0x0007</span><br><span class="line">	mov	bp,#msg2</span><br><span class="line">	mov	ax,cs</span><br><span class="line">	mov	es,ax</span><br><span class="line">	! es:bp 是显示字符串的地址</span><br><span class="line">	mov	ax,#0x1301		! write string, move cursor</span><br><span class="line">	int	0x10	</span><br><span class="line"></span><br><span class="line">inf_loop:</span><br><span class="line">    	jmp inf_loop</span><br><span class="line"></span><br><span class="line">msg2:</span><br><span class="line">	.byte 13,10</span><br><span class="line">	.ascii &quot;Now we are in SETUP&quot;</span><br><span class="line">	.byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">	.word 0xAA55</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">endtext:</span><br><span class="line">.data</span><br><span class="line">enddata:</span><br><span class="line">.bss</span><br><span class="line">endbss:</span><br></pre></td></tr></table></figure>

<p>bootsect.s</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! &#x2F;home&#x2F;ly&#x2F;oslab&#x2F;linux-0.11&#x2F;boot&#x2F;bootsect.s</span><br><span class="line">.globl begtext, begdata, begbss, endtext, enddata, endbss</span><br><span class="line">.text</span><br><span class="line">begtext:</span><br><span class="line">.data</span><br><span class="line">begdata:</span><br><span class="line">.bss</span><br><span class="line">begbss:</span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">SETUPLEN &#x3D; 2				! setup程序的扇区(boot-sector)数</span><br><span class="line">SETUPSEG &#x3D; 0x07e0			! 因为我们没有将bootsect移到0x9000</span><br><span class="line"></span><br><span class="line">entry _start				! 告知链接程序，从start标号开始执行</span><br><span class="line">_start:</span><br><span class="line">	! 首先读入光标位置</span><br><span class="line">	mov	ah,#0x03</span><br><span class="line">	xor 	bh,bh</span><br><span class="line">	int	0x10</span><br><span class="line">	! 显示字符串 “Hello OS world, my name is LY”</span><br><span class="line">	mov 	cx,#35</span><br><span class="line">    	mov 	bx,#0x0007</span><br><span class="line">   	mov 	bp,#msg1</span><br><span class="line"></span><br><span class="line">	! es:bp 是显示字符串的地址</span><br><span class="line">	mov	ax,#0x07c0		! boot-sector的原始地址(段基址)</span><br><span class="line">	mov	es,ax</span><br><span class="line">	mov	ax,#0x1301		! write string, move cursor</span><br><span class="line">	int	0x10	</span><br><span class="line"></span><br><span class="line">load_setup:</span><br><span class="line">   	mov dx,#0x0000			! 设置驱动器和磁头</span><br><span class="line">   	mov cx,#0x0002			! 设置扇区号和磁道</span><br><span class="line">   	mov bx,#0x0200			! 设置读入的内存地址:偏移512字节</span><br><span class="line">   	mov ax,#0x0200+SETUPLEN</span><br><span class="line">	int 0x13			! 读入2个setup.s扇区</span><br><span class="line">	jnc ok_load_setup		! 读入成功跳转</span><br><span class="line">	mov dx,#0x0000</span><br><span class="line">	mov ax,#0x0000</span><br><span class="line">	int 0x13</span><br><span class="line">	jmp load_setup			! 重复循环，再次尝试读取</span><br><span class="line"></span><br><span class="line">ok_load_setup:</span><br><span class="line">    	jmpi    0,SETUPSEG		! 跳到setup执行</span><br><span class="line"></span><br><span class="line">msg1:</span><br><span class="line">	.byte 13,10</span><br><span class="line">	.ascii &quot;Hello OS world, my name is LY&quot;</span><br><span class="line">	.byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">	.word 0xAA55</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">endtext:</span><br><span class="line">.data</span><br><span class="line">enddata:</span><br><span class="line">.bss</span><br><span class="line">endbss:</span><br></pre></td></tr></table></figure>

<h3 id="6-7-setup-s-获取基本硬件参数"><a href="#6-7-setup-s-获取基本硬件参数" class="headerlink" title="6.7 setup.s 获取基本硬件参数"></a>6.7 setup.s 获取基本硬件参数</h3><ol>
<li>将硬件参数取出来放在内存 0x90000</li>
</ol>
<h3 id="6-8-显示获得的参数"><a href="#6-8-显示获得的参数" class="headerlink" title="6.8 显示获得的参数"></a>6.8 显示获得的参数</h3><ol>
<li>显示 16 进制数</li>
</ol>
<p>setup.s代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! &#x2F;home&#x2F;ly&#x2F;oslab&#x2F;linux-0.11&#x2F;boot&#x2F;setup.s</span><br><span class="line">.globl begtext, begdata, begbss, endtext, enddata, endbss</span><br><span class="line">.text</span><br><span class="line">begtext:</span><br><span class="line">.data</span><br><span class="line">begdata:</span><br><span class="line">.bss</span><br><span class="line">begbss:</span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">INITSEG &#x3D; 0x9000			! 原来bootsect所处到段</span><br><span class="line">entry _start				! 告知链接程序，从start标号开始执行</span><br><span class="line">_start:</span><br><span class="line">! 首先读入光标位置</span><br><span class="line">	mov		ah,#0x03</span><br><span class="line">	xor 	bh,bh</span><br><span class="line">	int		0x10</span><br><span class="line">! 显示字符串“Now we are in SETUP”</span><br><span class="line">	mov		cx,#25</span><br><span class="line">	mov		bx,#0x0007</span><br><span class="line">	mov		bp,#msg2</span><br><span class="line">	mov		ax,cs</span><br><span class="line">	mov		es,ax</span><br><span class="line">	! es:bp 是显示字符串的地址</span><br><span class="line">	mov		ax,#0x1301		! write string, move cursor</span><br><span class="line">	int		0x10	</span><br><span class="line"></span><br><span class="line">	mov 	ax,cs</span><br><span class="line">	mov		es,ax</span><br><span class="line"></span><br><span class="line">! 获得参数。设置ds&#x3D;0x9000,重置一下</span><br><span class="line">	! 读入光标位置</span><br><span class="line">	mov		ax,#INITSEG</span><br><span class="line">	mov		ds,ax</span><br><span class="line">	mov     ah,#0x03</span><br><span class="line">	xor     bh,bh</span><br><span class="line">	! 调用 0x10 中断</span><br><span class="line">	int     0x10</span><br><span class="line">	! 获取光标位置 &#x3D;&gt;  0x9000:0</span><br><span class="line">	mov     [0],dx</span><br><span class="line"></span><br><span class="line">	! 获取拓展内存大小 &#x3D;&gt; 0x9000:2</span><br><span class="line">	mov    ah,#0x88</span><br><span class="line">	int    0x15</span><br><span class="line">	mov    [2],ax					! 将扩展内存存到0x90002处(1个字)</span><br><span class="line"></span><br><span class="line">	! 从 0x41 处拷贝 16 个字节（磁盘参数表）</span><br><span class="line">	! 获取硬盘参数 &#x3D;&gt; 0x9000:80  大小：16B</span><br><span class="line">	mov    ax,#0x0000</span><br><span class="line">	mov    ds,ax</span><br><span class="line">	lds    si,[4*0x41]</span><br><span class="line">	mov    ax,#INITSEG</span><br><span class="line">	mov    es,ax</span><br><span class="line">	mov    di,#0x0004</span><br><span class="line">	mov    cx,#0x10</span><br><span class="line">	! 重复16次</span><br><span class="line">	rep</span><br><span class="line">	movsb</span><br><span class="line"></span><br><span class="line">! 准备打印</span><br><span class="line">	mov 	ax,cs</span><br><span class="line">	mov 	es,ax</span><br><span class="line">	mov 	ax,#INITSEG</span><br><span class="line">	mov 	ds,ax</span><br><span class="line"></span><br><span class="line">! 打印</span><br><span class="line">! Cursor Position</span><br><span class="line">	mov 	ah,#0x03</span><br><span class="line">	xor 	bh,bh</span><br><span class="line">	int 	0x10</span><br><span class="line">   	mov 	cx,#18</span><br><span class="line">    mov 	bx,#0x0007</span><br><span class="line">    mov 	bp,#msg_cursor</span><br><span class="line">    mov 	ax,#0x1301</span><br><span class="line">    int 	0x10</span><br><span class="line">    mov 	dx,[0]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Memory Size</span><br><span class="line">    mov 	ah,#0x03</span><br><span class="line">    xor 	bh,bh</span><br><span class="line">    int 	0x10</span><br><span class="line">    mov 	cx,#14</span><br><span class="line">    mov 	bx,#0x0007</span><br><span class="line">    mov 	bp,#msg_memory</span><br><span class="line">    mov 	ax,#0x1301</span><br><span class="line">    int 	0x10</span><br><span class="line">    mov 	dx,[2]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Add KB</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#2</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_kb</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">! Cyles</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#7</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_cyles</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[4]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Heads</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#8</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_heads</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[6]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Sectors</span><br><span class="line">    mov 	ah,#0x03</span><br><span class="line">    xor 	bh,bh</span><br><span class="line">    int 	0x10</span><br><span class="line">    mov 	cx,#10</span><br><span class="line">    mov 	bx,#0x0007</span><br><span class="line">    mov 	bp,#msg_sectors</span><br><span class="line">    mov 	ax,#0x1301</span><br><span class="line">    int 	0x10</span><br><span class="line">    mov 	dx,[12]</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">inf_loop:</span><br><span class="line">    	jmp inf_loop</span><br><span class="line"></span><br><span class="line">! 以16进制方式打印栈顶的16位数</span><br><span class="line">print_hex:</span><br><span class="line">    mov    cx,#4				! 4个十六进制数字</span><br><span class="line">print_digit:</span><br><span class="line">    rol    dx,#4</span><br><span class="line">    mov    ax,#0xe0f</span><br><span class="line">    and    al,dl</span><br><span class="line">    add    al,#0x30</span><br><span class="line">    cmp    al,#0x3a</span><br><span class="line">    jl     outp					! 是一个不大于十的数字</span><br><span class="line">    add    al,#0x07				! 是a~f,要多加7</span><br><span class="line">outp:</span><br><span class="line">    int    0x10</span><br><span class="line">    loop   print_digit</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">! 打印回车换行</span><br><span class="line">print_nl:</span><br><span class="line">    mov    ax,#0xe0d     		! CR</span><br><span class="line">    int    0x10</span><br><span class="line">    mov    al,#0xa     			! LF</span><br><span class="line">    int    0x10</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">msg2:</span><br><span class="line">	.byte 13,10</span><br><span class="line">	.ascii &quot;Now we are in SETUP&quot;</span><br><span class="line">	.byte 13,10,13,10</span><br><span class="line">msg_cursor:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cursor position:&quot;</span><br><span class="line">msg_memory:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Memory Size:&quot;</span><br><span class="line">msg_cyles:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cyls:&quot;</span><br><span class="line">msg_heads:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Heads:&quot;</span><br><span class="line">msg_sectors:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Sectors:&quot;</span><br><span class="line">msg_kb:</span><br><span class="line">    .ascii &quot;KB&quot;</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">	.word 0xAA55</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">endtext:</span><br><span class="line">.data</span><br><span class="line">enddata:</span><br><span class="line">.bss</span><br><span class="line">endbss:</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200914225554788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>自制操作系统</category>
      </categories>
      <tags>
        <tag>hit-oslab</tag>
        <tag>os</tag>
        <tag>linux-0.11</tag>
      </tags>
  </entry>
  <entry>
    <title>DBUtils及数据库连接池</title>
    <url>/2021/02/15/DBUtils/</url>
    <content><![CDATA[<h2 id="DBUtil"><a href="#DBUtil" class="headerlink" title="DBUtil"></a>DBUtil</h2><p>查看一条记录</p>
<ul>
<li>BeanHandler</li>
<li>ArrayHandler</li>
<li>MapHandler</li>
<li>ScalarHandler</li>
</ul>
<p>查看集合</p>
<ul>
<li>BeanListHandler </li>
<li>ArrayListHandler</li>
<li>MapListHandler</li>
</ul>
<details><summary>DBUtilTest.java</summary>
<pre><code>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BeanHandler 查看一条记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        connection = MySQLDButil.getConnection();</span><br><span class="line">        String sql = <span class="string">"select * from emp where empno=?"</span>;</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Emp query = runner.query(connection, sql, <span class="keyword">new</span> BeanHandler&lt;Emp&gt;(Emp<span class="class">.<span class="keyword">class</span>), 7369)</span>;</span><br><span class="line">        System.out.println(query);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BeanListHandler 查看集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        connection = MySQLDButil.getConnection();</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        List&lt;Emp&gt; query = runner.query(connection, sql, <span class="keyword">new</span> BeanListHandler&lt;Emp&gt;(Emp<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : query) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  ArrayHandler 查看一条记录</span></span><br><span class="line"><span class="comment">     *  每一行的值会组成一个数组对象放进去</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArray</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        connection = MySQLDButil.getConnection();</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Object[] query = runner.query(connection, sql, <span class="keyword">new</span> ArrayHandler());</span><br><span class="line">        <span class="keyword">for</span> (Object o: query) &#123;</span><br><span class="line">            System.out.println(o); <span class="comment">//查看的是第一条记录</span></span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayListHandler 查看集合</span></span><br><span class="line"><span class="comment">     * 把表中的所有记录的值一条条放到List中，而每条具体值是放到Object[]中的</span></span><br><span class="line"><span class="comment">     * 7369--SMITH</span></span><br><span class="line"><span class="comment">     * 7499--ALLEN</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArrayList</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        connection = MySQLDButil.getConnection();</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        List&lt;Object[]&gt; query = runner.query(connection, sql, <span class="keyword">new</span> ArrayListHandler());</span><br><span class="line">        <span class="keyword">for</span> (Object[] o: query) &#123;</span><br><span class="line">            System.out.println(o[<span class="number">0</span>] +<span class="string">"--"</span>+o[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MapHandler 查看一条记录</span></span><br><span class="line"><span class="comment">     * 将一条记录中列名和对应的值作为一整个键值对元素放到Map中</span></span><br><span class="line"><span class="comment">     * EMPNO----7369</span></span><br><span class="line"><span class="comment">     * ENAME----SMITH</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tesMap</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        connection = MySQLDButil.getConnection();</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Map&lt;String, Object&gt; query = runner.query(connection, sql, <span class="keyword">new</span> MapHandler());</span><br><span class="line">        Set&lt;Map.Entry&lt;String,Object&gt;&gt; entries = query.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String ,Object&gt; entry : entries) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">"----"</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MapListHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tesMapList</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        connection = MySQLDButil.getConnection();</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; query = runner.query(connection, sql, <span class="keyword">new</span> MapListHandler());</span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; q: query) &#123;</span><br><span class="line">            Set&lt;Map.Entry&lt;String,Object&gt;&gt; entries = q.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String,Object&gt; entry : entries) &#123;</span><br><span class="line">                System.out.println(entry.getKey()+<span class="string">"----"</span>+entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ScalarHandler 单值查询</span></span><br><span class="line"><span class="comment">     * 15</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tesScalar</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        connection = MySQLDButil.getConnection();</span><br><span class="line">        String sql = <span class="string">"select count(*) from emp"</span>;</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Object query = runner.query(connection, sql, <span class="keyword">new</span> ScalarHandler&lt;&gt;());</span><br><span class="line">        System.out.println(query);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;   </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义handler对象</span></span><br><span class="line"><span class="comment">     * Emp&#123;empno=7369, ename='SMITH', job='CLERK', mrg=7902, hiredate=1980-12-17, sal=800.0, comm=0.0, deptno=20&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tesMyHandler</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        connection = MySQLDButil.getConnection();</span><br><span class="line">        String sql = <span class="string">"select * from emp where empno=?"</span>;</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Emp query = runner.query(connection, sql, <span class="keyword">new</span> ResultSetHandler&lt;Emp&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Emp <span class="title">handle</span><span class="params">(ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                Emp e = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">                    e = <span class="keyword">new</span> Emp();</span><br><span class="line">                    e.setEmpno(resultSet.getInt(<span class="string">"empno"</span>));</span><br><span class="line">                    e.setEname(resultSet.getString(<span class="string">"ename"</span>));</span><br><span class="line">                    e.setJob(resultSet.getString(<span class="string">"job"</span>));</span><br><span class="line">                    e.setMrg(resultSet.getInt(<span class="string">"mgr"</span>));</span><br><span class="line">                    e.setHiredate(resultSet.getString(<span class="string">"hiredate"</span>));</span><br><span class="line">                    e.setSal(resultSet.getDouble(<span class="string">"sal"</span>));</span><br><span class="line">                    e.setComm(resultSet.getDouble(<span class="string">"comm"</span>));</span><br><span class="line">                    e.setDeptno(resultSet.getInt(<span class="string">"deptno"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">7369</span>);</span><br><span class="line">        System.out.println(query);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into emp(empno,ename) values(?,?)"</span>;</span><br><span class="line">        connection = MySQLDButil.getConnection();</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        queryRunner.update(connection,sql,<span class="number">1234</span>,<span class="string">"msb"</span>);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String sql = <span class="string">"update emp set ename=? where empno=?"</span>;</span><br><span class="line">        connection = MySQLDButil.getConnection();</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        queryRunner.update(connection,sql,<span class="string">"msb123"</span>,<span class="number">1234</span>);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String sql = <span class="string">"delete from emp where empno=?"</span>;</span><br><span class="line">        connection = MySQLDButil.getConnection();</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        queryRunner.update(connection,sql,<span class="number">1234</span>);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">//        testQuery();</span></span><br><span class="line">        testList();</span><br><span class="line"><span class="comment">//        testArray();</span></span><br><span class="line"><span class="comment">//        testArrayList();</span></span><br><span class="line"><span class="comment">//        tesMap();</span></span><br><span class="line"><span class="comment">//        tesMapList();</span></span><br><span class="line"><span class="comment">//        tesScalar();</span></span><br><span class="line"><span class="comment">//        tesMyHandler();</span></span><br><span class="line"><span class="comment">//        insert();</span></span><br><span class="line"><span class="comment">//        update();</span></span><br><span class="line">        delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</details>

<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>数据库连接池的目的是为了减少频繁开关连接的时间，提高整个系统的响应能力。<br>通过分析发现应该具备几个属性值：<br>1、初始大小<br>2、每次扩容的大小<br>3、连接池的最大个数<br>3、空闲连接的死亡时间</p>
<p>各种数据库连接池：<br>DBCP<br>C3P0<br>Druid<br>hikariCP</p>
<h3 id="DBCP-几乎不用"><a href="#DBCP-几乎不用" class="headerlink" title="DBCP(几乎不用)"></a>DBCP(几乎不用)</h3><p><a href="https://commons.apache.org/proper/commons-dbcp/configuration.html" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-dbcp/configuration.html</a></p>
<table>
<thead>
<tr>
<th align="center">Parameter</th>
<th align="center">Default</th>
<th align="center">desc</th>
</tr>
</thead>
<tbody><tr>
<td align="center">initialSize</td>
<td align="center">0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">maxTotal</td>
<td align="center">8</td>
<td align="center">可以同时从此池分配的活动连接的最大数量，或者为无限制的最大数量。</td>
</tr>
<tr>
<td align="center">maxIdle</td>
<td align="center">8</td>
<td align="center">池中可以保持空闲（不释放多余连接）的最大连接数，或者为无限制的最大连接数。</td>
</tr>
<tr>
<td align="center">minIdle</td>
<td align="center">0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">maxWaitMillis</td>
<td align="center">indefinitely（不明确）</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="c3p0"><a href="#c3p0" class="headerlink" title="c3p0"></a>c3p0</h3><p>c3p0的<strong>配置方式</strong>分为三种，分别是<br>1.直接在<strong>类的方法中</strong>设置连接参数，一般没人使用，最好使用配置文件<br>2.类路径下提供一个<code>c3p0.properties</code>文件<br>3.类路径下提供一个<code>c3p0-config.xml</code>文件</p>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">    cpds.setDriverClass(<span class="string">"com.mysql.cj.jdbc.Driver"</span>); <span class="comment">// load the jdbc driver</span></span><br><span class="line">    cpds.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/demo"</span>);</span><br><span class="line">    cpds.setUser(<span class="string">"root"</span>);</span><br><span class="line">    cpds.setPassword(<span class="string">"512"</span>);</span><br><span class="line">    Connection connection = cpds.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式二-properties"><a href="#方式二-properties" class="headerlink" title="方式二 properties"></a>方式二 properties</h4><ol>
<li>文件必须放到<code>src</code>目录。</li>
<li>文件必须叫做<code>c3p0.properties</code>  （源码层面<code>C3P0Config</code>规定好了 否则无法识别）</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># c3p0.properties</span></span><br><span class="line"><span class="meta">c3p0.driverClass</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">c3p0.jdbcUrl</span>=<span class="string">jdbc:mysql://localhost:3306/demo</span></span><br><span class="line"><span class="meta">c3p0.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">c3p0.password</span>=<span class="string">512</span></span><br></pre></td></tr></table></figure>

<p>c3p0.driverClass写错，找不到驱动类，也能把结果打印出来。<br>原因：JDBC具有自己的规范。JDBC4之前，驱动必须要写名字的，JDBC4及以后不写名称也会自动进行查找（<font color='orange'><strong>SPI机制</strong></font>）</p>
<h4 id="方式三-xml"><a href="#方式三-xml" class="headerlink" title="方式三 xml"></a>方式三 xml</h4><ol>
<li>文件必须放到<code>src</code>目录。</li>
<li>文件必须叫做<code>c3p0-config.xml</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方式三 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql://localhost:3306/demo<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>获取连接池和获取连接</strong>:</p>
<ol>
<li>使用ComboPooledDataSource</li>
<li>通过工厂方法来完成操作<br>静态工厂类DataSources，这个类可以创建未池化的数据源对象，可以将未池化的数据源池化,当然，这种方式也会去自动加载配置文件</li>
<li>通过JNDI获取数据源。在C3P0基础上，自己定义自己的DataSource的源，来满足自己要求。</li>
</ol>
<details><summary>C3P0Test.java</summary>
<pre><code>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pool.c3p0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : LiuYan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/2/16 10:01</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 第一种 使用ComboPooledDataSource</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ComboPooledDataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queryData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection=dataSource.getConnection();</span><br><span class="line">            String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">            PreparedStatement pstmt = connection.prepareStatement(sql);</span><br><span class="line">            ResultSet resultSet = pstmt.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                System.out.println(resultSet.getString(<span class="string">"ename"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 方式一 直接在**类的方法中**设置连接参数，一般没人使用，最好使用配置文件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        ComboPooledDataSource cpds = new ComboPooledDataSource();</span></span><br><span class="line"><span class="comment">//        cpds.setDriverClass("com.mysql.cj.jdbc.Driver"); // load the jdbc driver</span></span><br><span class="line"><span class="comment">//        cpds.setJdbcUrl("jdbc:mysql://localhost:3306/demo");</span></span><br><span class="line"><span class="comment">//        cpds.setUser("root");</span></span><br><span class="line"><span class="comment">//        cpds.setPassword("512");</span></span><br><span class="line"><span class="comment">//        Connection connection = cpds.getConnection();</span></span><br><span class="line"><span class="comment">//        System.out.println(connection);</span></span><br><span class="line"><span class="comment">//        connection.close();</span></span><br><span class="line">        getConnection();</span><br><span class="line">        queryData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</details>

<details><summary>C3P0Test2.java</summary>
<pre><code>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pool.c3p0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.DataSources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : LiuYan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/2/16 11:04</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 第二种 通过工厂方法来完成操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取未池化数据源对象</span></span><br><span class="line">        DataSource ds_unpooled = DataSources.unpooledDataSource(<span class="string">"jdbc:mysql://localhost:3306/demo"</span>,</span><br><span class="line">                <span class="string">"root"</span>,</span><br><span class="line">                <span class="string">"512"</span>);</span><br><span class="line">        <span class="comment">// 2.将未池化数据源对象进行池化</span></span><br><span class="line">        <span class="comment">//不能搭参数</span></span><br><span class="line"><span class="comment">//        DataSource ds_pooled = DataSources.pooledDataSource(ds_unpooled);</span></span><br><span class="line">        <span class="comment">// 用map可以写入参数</span></span><br><span class="line">        Map overrides = <span class="keyword">new</span> HashMap();</span><br><span class="line">        overrides.put(<span class="string">"maxStatements"</span>,<span class="string">"200"</span>);</span><br><span class="line">        overrides.put(<span class="string">"maxPoolSize"</span>,<span class="keyword">new</span> Integer(<span class="number">50</span>));</span><br><span class="line">        DataSource ds_pooled = DataSources.pooledDataSource(ds_unpooled,overrides);</span><br><span class="line">        <span class="comment">// 3.获取连接</span></span><br><span class="line">        Connection connection = ds_pooled.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</details>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="Basic-Pool-Configuration"><a href="#Basic-Pool-Configuration" class="headerlink" title="Basic Pool Configuration"></a>Basic Pool Configuration</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当没有空闲连接可用时，批量创建连接的个数</span></span><br><span class="line"><span class="comment"># 默认3</span></span><br><span class="line"><span class="meta">c3p0.acquireIncrement</span>=<span class="string">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化连接个数</span></span><br><span class="line"><span class="comment"># 默认3</span></span><br><span class="line"><span class="meta">c3p0.initialPoolSize</span>=<span class="string">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大连接个数</span></span><br><span class="line"><span class="comment"># 默认15</span></span><br><span class="line"><span class="meta">c3p0.maxPoolSize</span>=<span class="string">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小连接个数</span></span><br><span class="line"><span class="comment"># 默认3</span></span><br><span class="line"><span class="meta">c3p0.minPoolSize</span>=<span class="string">3</span></span><br></pre></td></tr></table></figure>

<h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最大空闲时间。超过将被释放</span></span><br><span class="line"><span class="comment"># 默认0，即不限制。单位秒</span></span><br><span class="line"><span class="meta">c3p0.maxIdleTime</span>=<span class="string">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 失败重试时间</span></span><br><span class="line"><span class="comment"># 默认30。如果非正数，则将一直阻塞地去获取连接。单位毫秒。</span></span><br><span class="line"><span class="meta">c3p0.acquireRetryAttempts</span>=<span class="string">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大存活时间。超过将被释放</span></span><br><span class="line"><span class="comment"># 默认0，即不限制。单位秒</span></span><br><span class="line"><span class="meta">c3p0.maxConnectionAge</span>=<span class="string">1800</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>DBUtils</tag>
      </tags>
  </entry>
  <entry>
    <title>DDL建表操作和相关约束</title>
    <url>/2021/02/10/DDL%E5%BB%BA%E8%A1%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E7%9B%B8%E5%85%B3%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h3 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h3><p><strong>一、标准的建表语法</strong>：<br>CREATE TABLE [schema.]table<br>(column datatype [DEFAULT expr] , …<br>);<br>schema：不同数据库对应意义不一样。表示的是相应模式的规范。<br>datatype：对应的类型匹配</p>
<p>▪ 在创建新表时，指定的表名<strong>必须不存在</strong>，否则将出错。<br>▪ 使用默认值：当插入行时如果不给出值，dbms将自动采用<strong>默认值</strong>。<br>▪ 在用Create语句创建基本表时，最初只是一个空的框架，用户可<br>以使用insert命令把数据插入表中。</p>
<p><strong>案例：</strong><br>设计要求：建立一张用来存储学生信息的表，表中的字段包含了学生的学号、姓名、年龄、入学日期、年级、班级、email等信息，<br>–并且为grade指定了默认值为1，如果在插入数据时不指定grade的值，就代表是一年级的学生</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student</span><br><span class="line">(</span><br><span class="line">stu_id <span class="built_in">number</span>(<span class="number">10</span>),</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar2</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="built_in">number</span>(<span class="number">3</span>),</span><br><span class="line">hiredate <span class="built_in">date</span>,</span><br><span class="line">grade <span class="built_in">varchar2</span>(<span class="number">10</span>) <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line">classes <span class="built_in">varchar2</span>(<span class="number">10</span>),</span><br><span class="line">email <span class="built_in">varchar2</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">20191109</span>,<span class="string">'zhangsan'</span>,<span class="number">22</span>,<span class="keyword">to_date</span>(<span class="string">'2019-11-09'</span>,<span class="string">'yyyy-mm-dd'</span>),<span class="string">'2'</span>,<span class="string">'1'</span>,<span class="string">'123@qq.com'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(stu_id,<span class="keyword">name</span>,age,hiredate,classes,email) <span class="keyword">values</span>(<span class="number">20191109</span>,<span class="string">'zhangsan'</span>,<span class="number">22</span>,<span class="keyword">to_date</span>(<span class="string">'2019-11-09'</span>,<span class="string">'yyyy-mm-dd'</span>),<span class="string">'2'</span>,<span class="string">'123@qq.com'</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>

<p><strong>二、使用子查询创建表的语法：</strong><br>CREATE TABLE table [column(, column…)]<br>AS subquery;</p>
<ol>
<li>新表的字段列表必须与子查询中的字段列表匹配</li>
<li>字段列表可以省略<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp2 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="表结构的修改"><a href="#表结构的修改" class="headerlink" title="表结构的修改"></a>表结构的修改</h3><p>▪ 在基本表建立并使用一段时间后，可以根据实际需要对基本表的结构进行修改</p>
<ul>
<li>增加新的列用“alter table … add …”语句</li>
<li>删除原有的列用“alter table … drop…”语句，语法格式：alter table 表名 drop column 列名</li>
<li>修改字段“alter table…modify…”<br>▪ 在基本表不需要时，可以使用“drop table”语句撤消。在一个基<br>本表撤消后，所有的数据都丢弃。所有相关的索引被删除。<br>&emsp;<font color=red>drop table emp cascade constraints</font><blockquote>
<p><strong>级联删除</strong>：A表中dept=10，B表中dept=10，它们两个是一一对应的关系（B表中包含了其他表的一些列）。如果现在想把B表进行删除的话，那对应A表中的字段就不在了，肯定会报错的。级联删除就是先删除A，才能删除B。<br>▪ 可以使用RENAME语句改变表名（视图）</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--正规的表结构设计需要使用第三方工具 powerdesigner</span></span><br><span class="line"><span class="comment">--在添加表的列的时候，不能允许设置成not null</span></span><br><span class="line"><span class="keyword">alter</span>  <span class="keyword">table</span> student <span class="keyword">add</span> address <span class="built_in">varchar</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> <span class="keyword">column</span> address;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">modify</span>(email <span class="built_in">varchar2</span>(<span class="number">100</span>));</span><br><span class="line"><span class="comment">--重新命名表</span></span><br><span class="line"><span class="keyword">rename</span> student <span class="keyword">to</span> stu;</span><br><span class="line"><span class="comment">--删除表</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在删除表的时候，经常会遇到多个表关联的情况。多个表关联的时候，不能随意删除，需要使用级联删除。</span></span><br><span class="line"><span class="comment">cascade：如果A,B，A中的某个字段和B中的某一个字段做关联，那么删除A表的时候，需要将B表先删除</span></span><br><span class="line"><span class="comment">set null：在删除的时候，把表的关联字段设成空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> stu;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="约束-constraint"><a href="#约束-constraint" class="headerlink" title="约束 constraint"></a>约束 constraint</h3><p>▪ 当我们创建表的时候，同时可以指定所插入数据的一些规则，比如说某个字段不能为空值，某个字段的值（比如年龄）不能小于零等等，<strong>这些规则称为约束</strong>。约束是在表上强制执行的<strong>数据校验规则</strong>。<br>▪ Oracle 支持下面<strong>五类</strong>完整性约束:</p>
<ol>
<li><p><strong>NOT NULL</strong>非空： 插入数据的时候，某些列不能为空</p>
</li>
<li><p><strong>UNIQUE</strong> 唯一： 可以限定某一个列的值是唯一的，唯一键的列一般被用作索引列</p>
</li>
<li><p><strong>PRIMARY KEY</strong> 主键：非空且唯一，任何一张表最好有主键，用来唯一标识一行记录</p>
</li>
<li><p><strong>FOREIGN KEY</strong> 外键：当多个表之间有关联关系（一个表的某个列的值依赖于另一张表的某个值）的时候），需要使用外键</p>
<blockquote>
<p>作为主键的表称为“<strong>主表</strong>”，作为外键的关系称为“<strong>依赖表</strong>”<br> 外键参照的是主表的<strong>主键</strong>或者<strong>唯一键</strong><br> 对于主表的删除和修改主键值的操作，会对依赖关系产生影响，以删除为例：当要删除主表的某个记录（即删除一个主键值），那么对依赖的影响可采取下列3种做法：</p>
<ol>
<li><strong>RESTRICT</strong>方式：只有当依赖表中没有一个外键值与要删除的主表中主键值相对应时，才可执行删除操作。</li>
<li><strong>CASCADE</strong>方式：将依赖表中所有外键值与主表中要删除的主键值相对应的记录一起删除</li>
<li><strong>SET NULL</strong>方式：将依赖表中所有与主表中被删除的主键值相对应的外键值设为空值<br>FOREIGN KEY (DEPTNO) REFERENCES DEPT(DEPTNO)<br>[ON DELETE [CASCADE|SET NULL]] 如省略on短语，缺省为第一种处理方式。</li>
</ol>
</blockquote>
</li>
<li><p>CHECK 自定义检查约束：可以根据用户自己的需求去限定某些列的值</p>
</li>
</ol>
<p><strong>约束的添加和撤销</strong><br>▪ 可增加或删除约束，但不能直接修改<br>alter table tablename<br>增加<br>add constraint con_name unique(col)<br>删除<br>drop constraint com_name [cascade]</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--执行失败，外键约束</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(empno,ename,deptno) <span class="keyword">values</span>(<span class="number">9999</span>,<span class="string">'hehe'</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student</span><br><span class="line">(</span><br><span class="line">stu_id <span class="built_in">number</span>(<span class="number">10</span>) primary <span class="keyword">key</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar2</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">age <span class="built_in">number</span>(<span class="number">3</span>) <span class="keyword">check</span>(age&gt;<span class="number">0</span> <span class="keyword">and</span> age&lt;<span class="number">126</span>),</span><br><span class="line">hiredate <span class="built_in">date</span>,</span><br><span class="line">grade <span class="built_in">varchar2</span>(<span class="number">10</span>) <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line">classes <span class="built_in">varchar2</span>(<span class="number">10</span>),</span><br><span class="line">email <span class="built_in">varchar2</span>(<span class="number">50</span>) <span class="keyword">unique</span>,</span><br><span class="line">deptno <span class="built_in">number</span>(<span class="number">2</span>),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (DEPTNO) <span class="keyword">REFERENCES</span> DEPT(DEPTNO)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"><span class="comment">--建议在创建表的时候直接将各个表的约束添加好，如果包含外键约束的话，最好把外键关联表的数据优先插入</span></span><br><span class="line"><span class="comment">--失败，非空约束</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(stu_id,age,hiredate,classes,email) <span class="keyword">values</span>(<span class="number">20191109</span>,<span class="number">22</span>,<span class="keyword">to_date</span>(<span class="string">'2019-11-09'</span>,<span class="string">'yyyy-mm-dd'</span>),<span class="string">'2'</span>,<span class="string">'123@qq.com'</span>);</span><br><span class="line"><span class="comment">--失败，唯一约束</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(stu_id,<span class="keyword">name</span>,age,hiredate,classes,email) <span class="keyword">values</span>(<span class="number">20191109</span>,<span class="string">'zhangsan'</span>,<span class="number">22</span>,<span class="keyword">to_date</span>(<span class="string">'2019-11-09'</span>,<span class="string">'yyyy-mm-dd'</span>),<span class="string">'2'</span>,<span class="string">'123@qq.com'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(stu_id,<span class="keyword">name</span>,age,hiredate,classes,email) <span class="keyword">values</span>(<span class="number">20191109</span>,<span class="string">'zhangsan'</span>,<span class="number">22</span>,<span class="keyword">to_date</span>(<span class="string">'2019-11-09'</span>,<span class="string">'yyyy-mm-dd'</span>),<span class="string">'2'</span>,<span class="string">'123@qq.com'</span>);</span><br><span class="line"><span class="comment">--失败，主键约束</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(stu_id,<span class="keyword">name</span>,age,hiredate,classes,email) <span class="keyword">values</span>(<span class="number">20191109</span>,<span class="string">'zhangsan'</span>,<span class="number">22</span>,<span class="keyword">to_date</span>(<span class="string">'2019-11-09'</span>,<span class="string">'yyyy-mm-dd'</span>),<span class="string">'2'</span>,<span class="string">'123@qq.com'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(<span class="keyword">name</span>,age,hiredate,classes,email) <span class="keyword">values</span>(<span class="string">'lisi'</span>,<span class="number">22</span>,<span class="keyword">to_date</span>(<span class="string">'2019-11-09''yyyy-mm-dd'</span>),<span class="string">'2'</span>,<span class="string">'124@qq.com'</span>);</span><br><span class="line"><span class="comment">--失败，检查约束</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(stu_id,<span class="keyword">name</span>,age,hiredate,classes,email) <span class="keyword">values</span>(<span class="number">20191110</span>,<span class="string">'zhangsan'</span>,<span class="number">144</span>,<span class="keyword">to_date</span>(<span class="string">'2019-11-09'</span>,<span class="string">'yyyy-mm-dd'</span>),<span class="string">'2'</span>,<span class="string">'124@qq.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--添加后，如果想删除dept表中的dept=10的那条记录，会失败。因为外键关联了.但是可以直接删除student中这条记录 </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(stu_id,<span class="keyword">name</span>,age,hiredate,classes,email,deptno) <span class="keyword">values</span>(<span class="number">20191109</span>,<span class="string">'zhangsan'</span>,<span class="number">22</span>,<span class="keyword">to_date</span>(<span class="string">'2019-11-09'</span>,<span class="string">'yyyy-mm-dd'</span>),<span class="string">'2'</span>,<span class="string">'123@qq.com'</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">--可以选择后续额外添加</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> <span class="keyword">constraint</span> fk_0001 <span class="keyword">foreign</span> <span class="keyword">key</span>(deptno) <span class="keyword">references</span> dept(deptno);</span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>▪ 索引是为了加快对数据的搜索速度而设立的。<br>▪ 索引的作用：在数据库中用来加速对表的查询,通过使用<strong>快速路径访问方法</strong>快速定位数据,减少了<strong>磁盘的I/O</strong></p>
<blockquote>
<p>索引：指针，偏移量。索引不存放在内存（内存一开关机就不存在了。）所以<strong>索引数据是存放在磁盘中的</strong>。<br>1、<strong>局部性原理</strong>：（时间、空间）经常访问的数据和代码都经常聚在一起<br>2、<strong>磁盘预读</strong>：磁盘1T数据，从中读取1字节数据，怎么读？每次其实是读入的多个字节（一个块空间，一般是4k）。<br>3、减少I/O：一个是减少访问的次数，一个是减少IO的量。<br>4、索引是有数据结构的，每次读数据不是把所有数据都加到内存，而是需要哪快加哪快。（<strong>B+树</strong>）<br><font color=red>什么叫回表？<br>什么叫覆盖索引？<br>什么叫字符匹配？<br>什么叫组合索引？</font></p>
</blockquote>
<p>▪ <strong>索引的创建</strong>有两种情况<br>&emsp;1、自动：当在表上定义一个PRIMARY KEY 或者UNIQUE 约束条件时,Oracle数据库自动创建一个对应的唯一索引<br>&emsp;2、手动：用户可以创建索引以加速查询</p>
<p>▪ 开发中使用索引的要点：<br>&emsp;1、索引改善检索操作的性能，但<font color=red>降低数据插入、修改和删除的性能</font>。在执行这些操作时，DBMS必须动态地更新索引<br>&emsp;2、索引数据可能要占用大量的存储空间<br>&emsp; 可以在索引中定义多个列（如省加城市）先限定死大的范围</p>
<p>▪ 在一列或者多列上创建索引<br>CREATE INDEX index ON table (column[, column]…);<br>▪ 下面的索引将会提高对EMP表基于 ENAME 字段的查询速度.<br>CREATE INDEX emp_last_name_idx<br>ON emp (ename)<br>▪ 通过DROP INDEX 命令删掉一个索引.<br>– DROP INDEX index;<br>▪ 删掉 UPPER_LAST_NAME_IDX 索引.<br>– DROP INDEX upper_last_name_idx;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> i_ename <span class="keyword">on</span> emp(ename);</span><br><span class="line"><span class="comment">--删除索引</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> i_ename;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> ename=<span class="string">'SMITH'</span>;</span><br></pre></td></tr></table></figure>

<p>为什么加索引比没有加索引时间更长？</p>
<ol>
<li>数据量太小</li>
<li>回表</li>
<li>覆盖索引</li>
<li>组合索引</li>
<li>最左匹配</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle表设计</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM</title>
    <url>/2021/03/10/DOM/</url>
    <content><![CDATA[<h2 id="一、节点树"><a href="#一、节点树" class="headerlink" title="一、节点树"></a>一、节点树</h2><p>节点（Element）即为标签<br>静态页面骨架是由标签组成，把标签之间的关系叫做<strong>节点树</strong>。<br><img src="https://img-blog.csdnimg.cn/20210310164317240.png" alt="在这里插入图片描述"></p>
<h2 id="1-1-认识DOM"><a href="#1-1-认识DOM" class="headerlink" title="1.1 认识DOM"></a>1.1 认识DOM</h2><p>DOM（document object model，文档对象模型），其实就是系统内置引用类型对象document。可以认为是整个节点树的‘<font color='red'>根元素</font>’【真正的是html，只是认为】，JS中的DOM对象可以通过一些手段<font color='red'>操作结构层中的标签</font>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// DOM是引用类型数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">document</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210310164901793.png" width=30% height=30% align=center>

<h3 id="1-1-2-DOM四个小属性"><a href="#1-1-2-DOM四个小属性" class="headerlink" title="1.1.2 DOM四个小属性"></a>1.1.2 DOM四个小属性</h3><ul>
<li><code>documentElement</code>属性：可以获取到html根标签</li>
<li><code>head</code>属性：可以获取到head标签</li>
<li><code>body</code>属性：可以获取到body标签</li>
<li><code>title</code>属性：可以操作title标签文本</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.documentElement);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.head);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.body);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.title);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210310165350893.png" width=30% height=30% align=center>

<h3 id="1-1-3-DOM方法"><a href="#1-1-3-DOM方法" class="headerlink" title="1.1.3 DOM方法"></a>1.1.3 DOM方法</h3><p>如果想获取其他页面中的标签，需要通过一些方法获取，DOM方法有很多。<br><strong>getElementById</strong>：DOM这个方法可以通过id匹配任意节点树上的标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span> = <span class="string">"box1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>吃饭<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"box2"</span>&gt;</span>睡觉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//getElementById:DOM方法</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> meta = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(meta);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(ul);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> li = <span class="built_in">document</span>.getElementById(<span class="string">"box2"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(li);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210310184727370.png" alt="在这里插入图片描述"></p>
<ul>
<li>getElementById可以通过标签<strong>ID</strong>属性值获取任意节点</li>
<li>script标签一般放在程序最下方。因为加载的先后顺序问题。</li>
</ul>
<h2 id="1-2-操作标签文本"><a href="#1-2-操作标签文本" class="headerlink" title="1.2 操作标签文本"></a>1.2 操作标签文本</h2><p>我们可以通过DOM方法获取节点树上任意节点。除此之外，获取的节点经常操作自己的文本内容。</p>
<ul>
<li>如果是<mark><strong>表单元素</strong></mark>，需要通过<code>value</code>属性操作文本</li>
<li>如果是<mark><em>非表单元素*</em></mark>，需要通过<code>innerHTML</code>属性操作文本</li>
</ul>
<blockquote>
<p>标签文本指的是标签内的文本：<br><code>&lt;div&gt;我是标签文本&lt;/div&gt;</code></p>
</blockquote>
<blockquote>
<p>表单元素：经常结合form标签一起使用的input</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        我是表单元素：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"cur"</span> <span class="attr">value</span>=<span class="string">"默认文本内容"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span>跳转到百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"box1"</span>&gt;</span>欢迎光临<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//如果操作表单元素文本，需要使用标签的value属性</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//操作文本：即为可以在js中获取已有文本，但也可以重新设置文本</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 第一步，获取表单元素</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">"cur"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(input);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//获取表单元素文本</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(input.value);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 重新设置表单元素文本</span></span></span><br><span class="line"><span class="actionscript">    input.value = <span class="string">"修改文本"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//非表单元素（不是input即可）</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//非表单元素操作文本：需要通过innerHTML属性</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//获取非表单元素文本</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(a.innerHTML);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//重新设置非表单元素文本</span></span></span><br><span class="line"><span class="actionscript">    a.innerHTML = <span class="string">"你好"</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//获取p标签</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//获取非表单元素文本</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(p.innerHTML);</span></span><br><span class="line"><span class="actionscript">    p.innerHTML = <span class="string">"最近下雨"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-操作标签属性"><a href="#1-3-操作标签属性" class="headerlink" title="1.3 操作标签属性"></a>1.3 操作标签属性</h2><blockquote>
<p>下面高亮部分称为<strong>属性</strong>：<br>&lt;img <mark>src=”./1.jpg”</mark>&gt;</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/1.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cur"</span> <span class="attr">id</span>=<span class="string">"ha"</span>&gt;</span>粉刷匠<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//获取img标签</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//获取标签属性值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(img.src); <span class="comment">//file:///D:/OtherFiles/mashibing/web%E5%89%8D%E7%AB%AF%E6%A1%88%E4%BE%8B/Day04/img/1.jpg</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//重新修改属性值</span></span></span><br><span class="line"><span class="actionscript">    img.src = <span class="string">"./img/2.jpg"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">     <span class="comment">//获取div标签</span></span></span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"ha"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//获取标签属性值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(div.id); <span class="comment">//ha</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(div.className); <span class="comment">//cur</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//重新修改属性值</span></span></span><br><span class="line"><span class="actionscript">    div.className = <span class="string">"rewrite"</span>;</span></span><br><span class="line"><span class="actionscript">    div.id = <span class="string">"ga"</span>;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    console.log(div); //<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rewrite"</span> <span class="attr">id</span>=<span class="string">"ga"</span>&gt;</span>粉刷本领强<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//修改文本</span></span></span><br><span class="line"><span class="actionscript">    div.innerHTML = <span class="string">"粉刷本领强"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>大多情况下，操作标签的属性就是<code>标签.属性名</code> 进行操作</li>
<li>有特例：class属性，class是ES6关键字，所以是className</li>
</ul>
<h2 id="2-4-操作标签的样式"><a href="#2-4-操作标签的样式" class="headerlink" title="2.4 操作标签的样式"></a>2.4 操作标签的样式</h2><p>web中的样式分为三种：</p>
<ol>
<li>link：称为外部样式</li>
<li>style：称为内部样式</li>
<li>放在标签上的称为行内样式</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>【Oracle创建数据库】Database Configuration Assistant：警告</title>
    <url>/2021/02/04/Database%20Configuration%20Assistant%EF%BC%9A%E8%AD%A6%E5%91%8A/</url>
    <content><![CDATA[<p>Oracle创建数据库的时候，Database Configuration Assistant警告：<br><img src="https://img-blog.csdnimg.cn/20210204211958620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>解决</strong>：<br>点击确定<br>选择口令管理<br>找到SCOTT，解锁账户，然后输入新口令（我的是tiger）</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>DateUtils工具类的使用</title>
    <url>/2021/02/04/DateUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day04</a></p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>1.public static Date <code>addDay</code>(Date date, int n)<br>在日期上增加天数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d =  <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d); <span class="comment">// Thu Feb 04 11:06:09 CST 2021</span></span><br><span class="line">System.out.println(DateUtils.addDay(d,<span class="number">20</span>)); <span class="comment">// Wed Feb 24 11:06:09 CST 2021</span></span><br></pre></td></tr></table></figure>

<p>2.public static Date <code>addMonth</code>(Date date, int n)<br>在日期上增加数个整月</p>
<p>3.public static int <code>countDays</code>(String date)<br>按默认格式的字符串距离今天的天数<br>&emsp;public static int countDays(String date, String format)<br>按用户格式字符串距离今天的天数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(DateUtils.countDays(<span class="string">"2021-02-03 11:06:09"</span>)); <span class="comment">// 1</span></span><br><span class="line">System.out.println(DateUtils.countDays(<span class="string">"2021-02-03"</span>,<span class="string">"yyyy-MM-dd"</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>4.public static String <code>date2Str</code>(Calendar c) {// yyyy-MM-dd HH:mm:ss<br>&emsp;public static String date2Str(Calendar c, String format)<br>&emsp;public static String date2Str(Date d) {// yyyy-MM-dd HH:mm:ss<br>&emsp;public static String date2Str(Date d, String format)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">System.out.println(c.getTime());<span class="comment">// Thu Feb 04 11:26:24 CST 2021</span></span><br><span class="line">System.out.println(DateUtils.date2Str(c.getTime()));<span class="comment">// 2021-02-04 11:26:24</span></span><br><span class="line">System.out.println(DateUtils.date2Str(c.getTime(),<span class="string">"yyyy-MM"</span>));<span class="comment">// 2021-02</span></span><br><span class="line"></span><br><span class="line">System.out.println(DateUtils.date2Str(<span class="keyword">new</span> Date())); <span class="comment">// 2021-02-04 11:19:33</span></span><br><span class="line">System.out.println(DateUtils.date2Str(<span class="keyword">new</span> Date(),<span class="string">"yyyy-MM-dd"</span>)); <span class="comment">// 2021-02-04</span></span><br></pre></td></tr></table></figure>

<p>5.public static String <code>getCurDateStr</code>()<br>获得当前日期的字符串格式<br>&emsp;public static String getCurDateStr(String format) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(DateUtils.getCurDateStr());<span class="comment">// 2021-2-4 11:28:53</span></span><br><span class="line">System.out.println(DateUtils.getCurDateStr(<span class="string">"yyyy-MM"</span>));<span class="comment">// 2021-02</span></span><br></pre></td></tr></table></figure>

<p>6.public static String <code>getDatePattern</code>()<br>获得默认的 date pattern</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(DateUtils.getDatePattern()); <span class="comment">//yyyy-MM-dd HH:mm:ss</span></span><br></pre></td></tr></table></figure>

<p>7.public static int <code>getDay</code>(Date date)<br>返回日份</p>
<p>8.public static int <code>getMonth</code>(Date date)<br>返回月份</p>
<p>9.public static int <code>getHour</code>(Date date)<br>返回小时</p>
<p>10.public static int <code>getMinute</code>(Date date)<br>返回分钟</p>
<p>11.public static int <code>getSecond</code>(Date date)<br>返回秒钟</p>
<p>12.public static long <code>getMillis</code>(Date date)<br>返回date转换为毫秒的值，和date.getTime()相同</p>
<p>13.public static String <code>getDay</code>(long time)<br>返回当前的日期，格式yyyy-MM-dd</p>
<p>14.public static String <code>getMillon</code>(long time)<br>格式到秒<br>返回当前的日期，格式yyyy-MM-dd HH:mm:ss</p>
<p>15.public static String <code>getSMillon</code>(long time)<br>格式到毫秒<br>返回当前的日期，格式yyyy-MM-dd HH:mm:ss.SSS</p>
<p>16.public static String <code>getTimeString</code>()<br>获取时间戳,格式yyyy-MM-dd HH:mm:ss.SSS</p>
<p>public static String <code>getNextHour</code>(String format, int h)<br>获取距现在某h小时的时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d1 =  <span class="keyword">new</span> Date(); <span class="comment">//Thu Feb 04 11:53:36 CST 2021</span></span><br><span class="line">System.out.println(DateUtils.getDay(d1)); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d1.getTime()); <span class="comment">//1612410816115</span></span><br><span class="line">System.out.println(DateUtils.getDay(d1.getTime())); <span class="comment">// 2021-02-04</span></span><br><span class="line">System.out.println(DateUtils.getMonth(d1)); <span class="comment">// 2</span></span><br><span class="line">System.out.println(DateUtils.getHour(d1) + <span class="string">":"</span>+ DateUtils.getMinute(d1) +<span class="string">":"</span>+DateUtils.getSecond(d1)); <span class="comment">// 11:53:36</span></span><br><span class="line"><span class="comment">//2021-02-04 11:53:36</span></span><br><span class="line"><span class="comment">//2021-02-04 11:53:36.115</span></span><br><span class="line">System.out.println(DateUtils.getMillon(d1.getTime())+<span class="string">"\n"</span>+</span><br><span class="line">        DateUtils.getSMillon(d1.getTime()));</span><br><span class="line">System.out.println(DateUtils.getMillis(d1)); <span class="comment">//1612410816115</span></span><br><span class="line"></span><br><span class="line">System.out.println(DateUtils.getTimeString()); <span class="comment">// 2021-02-04 11:53:36.115</span></span><br><span class="line">System.out.println(DateUtils.getNextHour(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>,-<span class="number">2</span>)); <span class="comment">// 2021-02-04 09:53:36</span></span><br></pre></td></tr></table></figure>

<p>17.public static Date <code>parse</code>(String strDate)<br>使用预设格式提取字符串日期<br>&emsp;public static Date parse(String strDate, String pattern)<br>使用用户格式提取字符串日期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(DateUtils.parse(<span class="string">"2021-02-04 10:03:59"</span>)); <span class="comment">// Thu Feb 04 10:03:59 CST 2021</span></span><br><span class="line">System.out.println(DateUtils.parse(<span class="string">"2021-02-04"</span>,<span class="string">"yyyy-MM-dd"</span>)); <span class="comment">// Thu Feb 04 00:00:00 CST 2021</span></span><br></pre></td></tr></table></figure>

<p>18.public static Calendar <code>str2Calendar</code>(String str)<br>&emsp;public static Calendar str2Calendar(String str, String format)<br>将str转换成Calendar</p>
<p>19.public static Date str2Date(String str)<br>&emsp;public static Date str2Date(String str, String format)<br>将str转换成Date</p>
<p>和parse()类似，不同的是，str2Date()可以传入null或者””，返回null，而parse()会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(DateUtils.parse(<span class="string">"2021-02-04 10:03:59"</span>)); <span class="comment">// Thu Feb 04 10:03:59 CST 2021</span></span><br><span class="line">System.out.println(DateUtils.parse(<span class="string">"2021-02-04"</span>,<span class="string">"yyyy-MM-dd"</span>)); <span class="comment">// Thu Feb 04 00:00:00 CST 2021</span></span><br><span class="line"><span class="comment">//        System.out.println(DateUtils.parse("")); // 报错</span></span><br><span class="line"></span><br><span class="line">System.out.println(DateUtils.str2Calendar(<span class="string">"2021-02-04 10:08:50"</span>).getTime()); <span class="comment">// Thu Feb 04 10:08:50 CST 2021</span></span><br><span class="line">System.out.println(DateUtils.str2Calendar(<span class="string">"2021-02-04 10:08:50"</span>,<span class="string">"yyyy-MM-dd"</span>).getTime());<span class="comment">// Thu Feb 04 00:00:00 CST 2021</span></span><br><span class="line">System.out.println(DateUtils.str2Date(<span class="string">"2021-02-04 10:08:50"</span>));<span class="comment">// Thu Feb 04 10:08:50 CST 2021</span></span><br><span class="line">System.out.println(DateUtils.str2Date(<span class="string">"2021-02-04 10:08:50"</span>,<span class="string">"yyyy-MM-dd"</span>));<span class="comment">// Thu Feb 04 00:00:00 CST 2021</span></span><br><span class="line">System.out.println(DateUtils.str2Date(<span class="string">""</span>)); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>异常+常用类</category>
      </categories>
      <tags>
        <tag>DateUtils</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-Bash中设置命令</title>
    <url>/2020/06/22/Git-Bash%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>参考博文：<br><a href="https://blog.csdn.net/weixin_35955795/article/details/54880336" target="_blank" rel="noopener">两步实现在Git Bash中用Sublime打开文件</a></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>在<code>Git\mingW64\bin</code>下新建一个文本，命名为想要的命令名称。<br>内容：</p>
<pre><code>#!/bin/sh
&quot;C:\Program Files\Sublime Text3\sublime_text.exe&quot; $1 &amp;</code></pre><ul>
<li>第一行表示这是个 shell 脚本</li>
<li>第二行的字符串是打开工具的安装目录</li>
<li>$1 是取的命令之后输入的参数</li>
<li>&amp;是此命令在后台打开，打开后不影响git bash的继续使用</li>
</ul>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code>命令名 xxxx</code></pre><p>如果xxxx不存在，新建。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>GitBash</category>
      </categories>
      <tags>
        <tag>GitBash</tag>
        <tag>命令</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集</title>
    <url>/2020/09/14/GC%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>垃圾寻找的方式是Root Searching。从根节点（GC roots）开始捋引用，没有被寻到的都是垃圾。</p>
<p>垃圾收集算法主要有三种：</p>
<ol>
<li>Mark-Sweep（标记清除）：直接标记清除。</li>
<li>Copying(拷贝）：划分区域，把一个区域中存活的对象移动到另一个区域，然后清除掉这个区域。</li>
<li>Mark-Compact（标记压缩）：将存活的移动到最前面，然后把后面直接清除。</li>
</ol>
<p>垃圾收集器就是对这三种算法的应用。一共有10种：<br>分代的有6种，最常见的三种搭配是：(新生代，老年代)</p>
<ol>
<li>Serial，Serial Old：单线程收集</li>
<li>Parallel Scavenge，Parallel Old：多线程收集  </li>
<li>ParNew，CMS：在标记时候，垃圾收集和标记并发<br>不分代分区的有三种：</li>
<li>G1</li>
<li>ZGC</li>
<li>Shenandoah<br>啥都没有的：<br>Epsilon</li>
</ol>
<p>分代收集器里面Young中有Eden，Survivor，达到阈值后从Survivor中移到Old区。</p>
<p>当我们new一个对象出来时，首先看能否在栈上分配。进行<strong>逃逸分析</strong>，然后进行<strong>标量替换</strong>，就在栈上分配（当方法弹出栈时，对象直接清除）。如果太大（参数确定），直接分配到堆的老年代（老年代中的垃圾回收直接<strong>FGC</strong>）。如果大小合适，但栈上又分配不下，优先TLAB（线程本地）</p>
<p>JDK 1.8主要是分代模型，默认Parallel Scavenge，Parallel Old，比较好的是G1。</p>
]]></content>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>GC基础知识</title>
    <url>/2021/03/13/GC%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>C语言申请内存：malloc free</p>
<p>C++： new delete</p>
<p>Java: new ？</p>
<p>自动内存回收，编程上简单，系统不容易出错，手动释放内存，容易出两种类型的问题：</p>
<ol>
<li>忘记回收</li>
<li>多次回收</li>
</ol>
</blockquote>
<h3 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h3><p>没有任何引用指向的<strong>一个对象</strong>或者<strong>多个对象</strong>（多个对象之间是循环引用）<br>浮动垃圾：这次没有回收，下次再回收</p>
<h3 id="如何定义垃圾？"><a href="#如何定义垃圾？" class="headerlink" title="如何定义垃圾？"></a>如何定义垃圾？</h3><ol>
<li><p>reference count（引用计数）<br>但是如果有循环引用的多个对象，是找不到的，就会发生内存泄漏。</p>
</li>
<li><p>Root Searching（根可达算法）<br>java的hotspot正在使用的算法。<br>GC roots：根对象。包括<br>一个程序运行起来以后，通过根找不到的全是垃圾。<br>object o = new Object();这个new Object()一定不是垃圾。<br>根对象指的是，我们现在正在跑的这个栈里面的局部变量（就是main方法中的局部变量）【<strong>线程栈变量</strong>】，以及我们从class里面引进的<strong>静态变量</strong>，还有一些常量池和JNI指针引用到的变量。<br><img src="https://img-blog.csdnimg.cn/20210313220753949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
<h3 id="常见的GC算法"><a href="#常见的GC算法" class="headerlink" title="常见的GC算法"></a>常见的GC算法</h3><ol>
<li><strong>标记-清除</strong>（Mark-Sweep）<br>首先标记出想要回收的对象，接着统一进行清除。<br><font color='red'>位置不连续，产生碎片</font></li>
<li><strong>拷贝</strong>（Copying）<br>“半区复制”：将内存分为两部分（1：1），每次只使用其中一块。用完一块，就将存后的对象复制到另一块上，清理掉这一块内存空间。<br> <font color='red'>不产生碎片，内存拷贝很快，浪费空间。</font><br> “Appel式回收”：每次只使用Eden和一块Survivor空间，用完后复制到另一块Survivor空间上。</li>
<li><strong>标记压缩</strong>（Mark-Compact）<br>与复制算法相似，区别是先让所有存活的对象都向内存一端移动，再清理掉后面的内存空间。<br>不产生碎片，但效率低，因为任何一块的挪动都需要进行线程同步。</li>
</ol>
<h3 id="JVM内存分代模型（用于分代垃圾回收算法）"><a href="#JVM内存分代模型（用于分代垃圾回收算法）" class="headerlink" title="JVM内存分代模型（用于分代垃圾回收算法）"></a>JVM内存分代模型（用于分代垃圾回收算法）</h3><ol>
<li><p>部分垃圾回收器使用的模型</p>
</li>
<li><p>新时代 + 老年代 + 永久代（1.7）/ 元数据区(1.8) Metaspace<br>· 永久代和元数据都是装<strong>Class对象</strong>的；<br>· 永久代必须指定大小限制，但是元数据区可以设置，也可以不设置。无上限（受限于物理内存）；<br>· 字符串常量 1.7 - 永久代； 1.8 - 堆<br>· <code>MethodArea</code>是一个逻辑概念，对应的是永久代/元数据区</p>
</li>
<li><p>新生代 = Eden + 2个suvivor区<br><img src="https://img-blog.csdnimg.cn/20210313224255973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）YGC回收之后，eden区大部分对象都会被回收。活的对象拷贝进survivor区。<br>（2）再次YGC，eden活着的对象 +s0 -&gt; s1<br>（3）再次YGC，eden活着的对象 +s1 -&gt; s0<br>（4）<strong>年龄足够</strong> -&gt; 老年代 （老一点的垃圾回收器是15岁， CMS是6岁）<br>（5）s区装不下 -&gt; l老年代</p>
</li>
<li><p>老年代<br>（1）顽固分子<br>（2）老年代满了FGC【Full GC】 新生代老年代同时进行回收<br>尽量减少产生FGC，因为使用到了标记压缩算法</p>
<blockquote>
<p><strong>动态对象年龄判定</strong><br>年龄从小到大进行累加，当加入某个年龄段后，累加和超过survivor区域*TargetSurvivorRatio的时候，就从这个年龄段网上的年龄的对象进行晋升。<br>例子：年龄1的占用了33%，年龄2的占用了33%，累加和超过默认的TargetSurvivorRatio（50%），年龄2和年龄3的对象都要晋升。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>MinorGC = YGC<br>MajarGC =FGC</p>
</blockquote>
<h3 id="常见的垃圾回收器"><a href="#常见的垃圾回收器" class="headerlink" title="常见的垃圾回收器"></a>常见的垃圾回收器</h3><p><img src="https://img-blog.csdnimg.cn/2021031322552917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>Epsilon是测试使用的空的GC，调试JDK的。<br>Serial和Parallel可以看成是同样的种类用在不同的区域上。</p>
</blockquote>
<ol>
<li><p><strong>Serial</strong> 运行在年轻代 单线程回收【串行回收】<br>垃圾回收的时候，应用程序是没办法运行的（STW，Stop the world）出现卡顿<br><img src="https://img-blog.csdnimg.cn/20210313231705691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>Parallel Scavenge</strong>  年轻代 并行回收<br><img src="https://img-blog.csdnimg.cn/20210313231902498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>ParNew</strong> 年轻代 配合CMS并行回收</p>
</li>
<li><p><strong>SerialOld</strong></p>
</li>
<li><p><strong>ParallelOld</strong></p>
</li>
<li><p><strong>ConcurrentMarkSweep（CMS）</strong> 并发的 垃圾回收和应用程序同时运行，降低STW时间（200ms内）</p>
<blockquote>
<p>前面长的甚至有几小时STW</p>
</blockquote>
</li>
<li><p><strong>G1</strong>（10ms）</p>
</li>
<li><p><strong>ZGC</strong> （1ms PK C++）</p>
</li>
<li><p><strong>Shenandoah</strong></p>
</li>
<li><p><strong>Epsilon</strong></p>
</li>
</ol>
<blockquote>
<p>调优主要是1，2和4，5<br>因为1.8默认回收器是 PS+ parallelOld</p>
</blockquote>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>承上启下垃圾回收器。第一款并发垃圾回收器。<br>有巨大问题：最长时间的STW就是CMS产生的。因为cms失败了，就要shang</p>
<p><strong>从线程角度</strong><br><img src="https://img-blog.csdnimg.cn/20210313232406536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>初始标记会把根对象标出来。</p>
<h5 id="错标"><a href="#错标" class="headerlink" title="错标"></a>错标</h5><p>如果已经标记好了要清除的对象，结果在并发标记中，有的垃圾又被引用到了，这时候清除垃圾就会产生<strong>错标现象</strong>。</p>
<p>很多算法就是为了高效率解决算法问题。重新标记就会修正错标</p>
<p><strong>并发清理</strong>可能会产生浮动垃圾，就是标记好了要清除的对象，结果在这时候又出现了垃圾。这些垃圾会留到下一次清理的时候清理。</p>
<h5 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h5><p><strong>黑色</strong>：自己已经标记，fields都标记完成（即接下来的遍历不会再遍历到它了，它的孩子都已经遍历完了）<br><strong>灰色</strong>：自己已经标记，还没来得及标记fields<br><strong>白色</strong>：没有遍历到的节点<br>如果灰色B&gt;白色C的引用消失了，黑色A-&gt;白色C的引用出现了。此时就会把C当成垃圾，出现了错标。</p>
<h6 id="CMS解决方案——Incremental-Update"><a href="#CMS解决方案——Incremental-Update" class="headerlink" title="CMS解决方案——Incremental Update"></a>CMS解决方案——Incremental Update</h6><p>把黑色B变为灰色。（写屏障）</p>
<h3 id="了解生产环境下的垃圾回收器组合"><a href="#了解生产环境下的垃圾回收器组合" class="headerlink" title="了解生产环境下的垃圾回收器组合"></a>了解生产环境下的垃圾回收器组合</h3><ul>
<li>JVM命令行参数参考：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></li>
<li><strong>JVM命令参数分类</strong><br>标准：<code>-</code>开头 ，所有HotSpot都支持 <code>java -version</code><br>非标准：<code>-X</code>开头 <code>Java -X</code><br>不稳定：<code>-XX</code>开头<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags  设置值（启动了哪些参数）</span><br><span class="line">java -XX:+PrintFlagsFinal 最终默认值</span><br><span class="line">java -XX:+PrintFlagsInitial 默认参数值</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="分配和垃圾回收大致流程"><a href="#分配和垃圾回收大致流程" class="headerlink" title="分配和垃圾回收大致流程"></a>分配和垃圾回收大致流程</h3><ol>
<li>尝试在栈中分配对象，如果能分就分【<strong>逃逸分析</strong>，不能有逃逸，野指针问题；<strong>标量替换</strong>：把聚合量分解成为标量（原始数据类型）】方法结束，栈帧弹出的时候，对象顺带直接销毁，不需要垃圾回收。</li>
<li>如果逃逸分析失败，有引用指向它，就放到堆上。如果大对象，直接放老年代。老年代垃圾回收：<strong>FGC</strong></li>
<li>假如不够大，<strong>TLAB</strong>（Thread Local Allocation Buffer，线程本地分配缓存区）一般是直接放到Eden区的。但是为啥有TLAB呢？因为一个程序开始，为许多线程分配资源的时候，一定会发生资源争用。JVM就要对这些线程进行管理、同步。所以效率偏低。为了提高效率，JVM设置了一种机制：JVM启动的每个线程都可以有私有的一块空间（放在eden区里面），以后new对象就new到自己的空间，满了再抢占。YGC最后到老年代。<br><img src="https://img-blog.csdnimg.cn/20210314103038488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo】 Error:Spawn failed at ChildProcess</title>
    <url>/2020/11/25/HexoError%20SpawnfailedatChildProcess/</url>
    <content><![CDATA[<p><code>hexo d -g</code>执行后报错：Spawn failed</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</span><br><span class="line">fatal: the remote end hung up unexpectedly</span><br><span class="line">fatal: the remote end hung up unexpectedly</span><br><span class="line">Everything up-to-date</span><br><span class="line">FATAL Something&#39;s wrong. Maybe you can find the solution here: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\OtherFiles\blog\myblog\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">    at ChildProcess.emit (events.js:203:13)</span><br><span class="line">    at ChildProcess.cp.emit (D:\OtherFiles\blog\myblog\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:272:12)</span><br></pre></td></tr></table></figure>



<p>在.git文件夹下打开config配置文件，在[core]中添加上下面两句话：<br>autocrlf = false<br>safecrlf = false</p>
<p>成功。</p>
]]></content>
      <categories>
        <category>安装和踩坑</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA快捷键和系统设置</title>
    <url>/2021/01/28/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p><img src="https://img-blog.csdnimg.cn/20210128190731666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>回到上一步  ctrl + alt + &lt;-<br>回到下一步 ctrl + alt + -&gt;</p>
<p>psvm ： public static void main（String[] args）<br>Sout ：system.out.println();<br>.sout 可以将内容包裹起来之后完成打印操作</p>
<h3 id="Serializable-自动生成UID的设置"><a href="#Serializable-自动生成UID的设置" class="headerlink" title="Serializable 自动生成UID的设置"></a>Serializable 自动生成UID的设置</h3><p>IDEA 实现<code>Serializable</code>接口时，系统随机生成UID值的方法。<br>File –&gt; Settings –&gt; Editor –&gt; Inspections –&gt; Java –&gt; Serialization issues –&gt; 勾选“Serializable class without ‘serialVersionUID’”<br>之后选择类名，按”alt + enter”，可以随机生成数字作为UID</p>
<h3 id="地沟图标设置"><a href="#地沟图标设置" class="headerlink" title="地沟图标设置"></a>地沟图标设置</h3><p>File –&gt; Settings –&gt; Editor –&gt; General –&gt; Gutter Icons –&gt; 勾选想要显示的相关图标<br><img src="https://img-blog.csdnimg.cn/20210201141727898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=30% height=30% align=center></p>
<h3 id="author-模板"><a href="#author-模板" class="headerlink" title="@author 模板"></a>@author 模板</h3><ol>
<li><p>File –&gt; Settings –&gt; Editor –&gt;  File and Code Templates –&gt; Includes –&gt; File Header</p>
<p><strong>内容：</strong></p>
<pre><code>/**
* Created by IntelliJ IDEA.
* @Author : LiuYan
* @create ${DATE} ${TIME}
*/</code></pre><img src="https://img-blog.csdnimg.cn/2021020211574798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=60% height=60% align=center>
</li>
<li><p>File -&gt; Settings -&gt; Editor -&gt; Live Templates<br>1）点击+新建一个template group，组名为user，并在组中创建<code>live template</code>。Abbreviation是缩略语（我定义的act），写自定义快捷键名称，description可以添加备注。<br><strong>test：</strong></p>
<pre><code>Created by IntelliJ IDEA.
* @author: LiuYan
* @Created: $DATE$ $TIME$</code></pre><p> 2）点击<code>Edit variables</code>，填写Expression</p>
 <img src ="https://img-blog.csdnimg.cn/20210202115525328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=60% height=60% align=center>
 3）底下Define选择Java-Comment
 <img src ="https://img-blog.csdnimg.cn/20210202115621650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=60% height=60% align=center>
</li>
<li><p>使用。先输入<code>/**</code>，再按回车。在第一行写<code>act</code>，然后按Tab，即可自动生成。</p>
<img src ="https://img-blog.csdnimg.cn/20210202121307689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=80% height=80% align=center>

</li>
</ol>
<h3 id="idea鼠标光标变黑块解决"><a href="#idea鼠标光标变黑块解决" class="headerlink" title="idea鼠标光标变黑块解决"></a>idea鼠标光标变黑块解决</h3><p>按一下ins键(Insert键)即可切换正常情况<br>Mac 电脑是 fn + Enter 组合键切换输入模式</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML标签</title>
    <url>/2021/03/08/HTML%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p><a href="https://github.com/two-fire/Web-front-end" target="_blank" rel="noopener">https://github.com/two-fire/Web-front-end</a></p>
<h3 id="一、HTML简介"><a href="#一、HTML简介" class="headerlink" title="一、HTML简介"></a>一、HTML简介</h3><p>HyperText Markuo Language 超文本标记语言，是世界上最简单的编程，利用<font color='red'><strong>标签</strong>（element）</font>进行页面布局（静态页面）<br>&lt;标签名字&gt;文本内容&lt;/标签名字&gt;</p>
<p>注：</p>
<ol>
<li>超文本标记语言（HTML）又称为web开发。</li>
<li>最近一次2014称为HTML5（第五次重大变化）</li>
</ol>
<h3 id="二、开发工具"><a href="#二、开发工具" class="headerlink" title="二、开发工具"></a>二、开发工具</h3><p>Sublime、Vscode、Webstorm<br>我使用的是sublime</p>
<h3 id="三、标签学习"><a href="#三、标签学习" class="headerlink" title="三、标签学习"></a>三、标签学习</h3><p>HTML静态页面由标签组成，最主要的一部分就是块元素：明显特征：独占一行</p>
<h4 id="3-1-常用块元素"><a href="#3-1-常用块元素" class="headerlink" title="3.1 常用块元素"></a>3.1 常用块元素</h4><h5 id="3-1-1-静态页面骨架"><a href="#3-1-1-静态页面骨架" class="headerlink" title="3.1.1 静态页面骨架"></a>3.1.1 静态页面骨架</h5><p>快捷键：<code>! + tab</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  &#x2F;&#x2F; 第五次重大变化文档声明方式</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;  &#x2F;&#x2F;charset 设置字符集 UTF-8 （万国编码）</span><br><span class="line">	&lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>HTML标签是整个网页<strong>根元素</strong>（嵌入内部）</li>
<li>HTML右侧有一个lang属性，代表是在哪种语言下开发</li>
</ul>
<h5 id="3-1-2-常用标签–块元素"><a href="#3-1-2-常用标签–块元素" class="headerlink" title="3.1.2 常用标签–块元素"></a>3.1.2 常用标签–块元素</h5><ul>
<li>在书写这些标签（块元素），一定要在body内写。</li>
<li>块元素<font color='purple'><strong>独占一行</strong></font></li>
</ul>
<p>技巧：打出标签名，再打ctrl+E，会自动补齐<br>运行方式：右键+复制路径-&gt;打开浏览器</p>
<ul>
<li><strong>h1~h6</strong>：一级到六级<strong>标题</strong></li>
<li><strong>div</strong> 布局标签(<strong>盒子标签</strong>) 字体大小跟h3差不多，但没用h3黑，一般情况下，是div中嵌套别的标签</li>
<li><strong>p</strong> <strong>段落标签</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;二级标题&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;!-- 注释 --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    布局标签，独占一行</span><br><span class="line">    &lt;h3&gt;三级标题&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;p&gt;独占一行（一个段落）&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>address</strong>：经常放地址</li>
</ul>
<h5 id="3-1-3-常用块元素——列表"><a href="#3-1-3-常用块元素——列表" class="headerlink" title="3.1.3 常用块元素——列表"></a>3.1.3 常用块元素——列表</h5><p>无序列表ul 前面是●<br>有序列表ol 前面是1. 2.……<br>经常结合li元素一起使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;a&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;b&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;c&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-行内元素"><a href="#3-2-行内元素" class="headerlink" title="3.2 行内元素"></a>3.2 行内元素</h4><p>前端开发中，行内元素（内联元素）有：<br>span：黑色不加粗字体<br>img：用来显示图片<strong>单闭合</strong>标签 如果没用图片，显示alt内容<br>a：超链接 蓝字体有下划线</p>
<p>行内元素特征：不是独占一行，是<font color='purple'><strong>从左到右进行排列</strong></font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.taobao.com&quot;&gt;淘宝&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.sina.com&quot;&gt;新浪&lt;&#x2F;a&gt;</span><br><span class="line">&lt;span&gt;我是行内元素span&lt;&#x2F;span&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;img.jpg&quot; alt&#x3D;&quot;默认文字&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：</p>
<ul>
<li>在web中有单闭合标签和标签（双闭合标签）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 2014年新增的，用来显示地址 --&gt;</span><br><span class="line">&lt;address&gt;我是一个地址&lt;&#x2F;address&gt;</span><br></pre></td></tr></table></figure></li>
<li>address不是行内元素，是<strong>块元素</strong> （义化标签） 里面文字是黑色斜体<blockquote>
<p>网页中显示地图<br>搜索百度地图api -&gt; 地图名片 -&gt; 制作好后复制代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;我是一个地址</span><br><span class="line">	&lt;iframe width&#x3D;&quot;204&quot; height&#x3D;&quot;619&quot; frameborder&#x3D;&quot;0&quot; scrolling&#x3D;&quot;no&quot; marginheight&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; src&#x3D;&quot;http:&#x2F;&#x2F;j.map.baidu.com&#x2F;s&#x2F;k-KHFb&quot;&gt;&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210308172925126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="3-3-表单元素"><a href="#3-3-表单元素" class="headerlink" title="3.3 表单元素"></a>3.3 表单元素</h4><p>注册时候的框框就是表单元素：<br><img src="https://img-blog.csdnimg.cn/20210308173842145.png" alt="在这里插入图片描述"></p>
<ul>
<li>前端中比较重要的标签：表单元素，经常用来收集输入信息，将用户输入信息提交给服务器</li>
<li>表单元素即为<strong>input标签</strong>（单闭合标签），这个标签经常集合<strong>form标签</strong>一起使用</li>
</ul>
<h4 id="3-4-音频标签"><a href="#3-4-音频标签" class="headerlink" title="3.4 音频标签"></a>3.4 音频标签</h4><p><font color='purple'><strong>不是块标签，是行内标签</strong></font><br>想在网页中显示音频，我们利用audio标签显示音频。Web领域中音频audio标签，<font color='red'>只能播放下面三种<strong>音频格式</strong></font>：<br>MP3：一种音频压缩技术，最常见<br>OGG：音频压缩格式，完全免费<br>WAV：微软创建出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;下面是音频&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;audio src&#x3D;&quot;b.mp3&quot; controls muted autoplay&#x3D;&quot;autoplay&quot; loop&gt;&lt;&#x2F;audio&gt;</span><br></pre></td></tr></table></figure>
<p>controls：显示加上才有图标显示<br>muted：开始静音<br>autoplay：可以自动播放，但不同浏览器有兼容问题<br>loop：循环播放</p>
<ul>
<li>我们可以使用audio标签播放音频（mp3，OGG，wav）</li>
<li>video视频标签和audio几乎类似，也有三种格式：<br>mp4：最常用的视频格式<br>ogg<br>webM：Google提出媒体视频格式</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Web前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML标签</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流——字节、字符、输入、输出流</title>
    <url>/2020/11/18/IO%E6%B5%81%E2%80%94%E2%80%94%E5%AD%97%E8%8A%82%E3%80%81%E5%AD%97%E7%AC%A6%E3%80%81%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day07</a></p>
<mark>
对于程序来说：<br>
读（Reader）进来（InputStream）（in）
写（Writer）出去（OutputStream/PrintStream）（out）</mark>

<p>流表示一个文件将数据返送到另一个文件，包含一个流向的问题<br>当前所写的代码作为参照物：<br>&emsp;从一个文件中读取数据到程序叫输入流<br>&emsp;从程序写入文件叫输出流</p>
<p>字符是一个逻辑概念。<br>纯文本的，用字符流多一点，如果有图片，只能用字节流。</p>
<p><img src="https://img-blog.csdnimg.cn/20201119082602876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>注意：每次编写IO流的时候一定要注意关闭流。原因：一个进程最多打开1024个文件。如果不关闭流对象，会占用系统资源，并发执行会卡死。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>选择合适的IO流对象</li>
<li>创建对象</li>
<li>传输数据</li>
<li>关闭流对象</li>
</ol>
<h2 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>处理图片、视频，其他文件格式的时候，最好还是使用字节流处理。<br><img src="https://img-blog.csdnimg.cn/20210120132752891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><h6 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h6><p><strong>FileInputStream构造函数：</strong><br><code>FileInputStream(File file)</code><br>通过打开与实际文件的连接创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </p>
<p><strong>字节流</strong>读取数据的方式：<br><code>InputStream inputStream = new FileInputStream(&quot;abc.txt&quot;);</code></p>
<ol>
<li><code>inputStream.read()</code> 返回值为数据的下一个字节，如果达到流的末尾， -1。每次读取一个字节。直接(char)强制类型转换进行字符读取。</li>
<li><code>inputStream.read(byte[] b)</code> 返回值为读取到缓冲区的总字节数，已经到达流的末尾，那么 -1。添加缓冲区方式进行读取，每次将数据添加到缓冲区，满了之后一次读取，而不是每个字节读取。</li>
<li><code>inputStream.read(byte[] b,off,len)</code> 返回值为读取到缓冲区的总字节数，已经到达流的末尾，那么 -1。第一个字节读取存储在元素b[off]…这些字节将存储在元素b[off]至b[off+ k -1]。</li>
</ol>
<h6 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h6><p>ByteArrayInputStream包含一个内部缓冲区，其中包含可以从流中读取的字节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"www.baidu.com"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] buffer = str.getBytes();</span><br><span class="line">ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(buffer);</span><br><span class="line"><span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((read = byteArrayInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    byteArrayInputStream.skip(<span class="number">4</span>);</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><h6 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h6><p><strong>字节流</strong>写入数据的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"aaa.txt"</span>);</span><br><span class="line">OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">outputStream.write(<span class="number">99</span>);</span><br><span class="line">outputStream.write(<span class="string">"\r\nliu"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<h6 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h6><p>该类实现了将数据写入字节数组的输出流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="comment">// write()将指定的字节写入此字节数组输出流 &#123;</span></span><br><span class="line">byteArrayOutputStream.write(<span class="number">123</span>);</span><br><span class="line">byteArrayOutputStream.write(<span class="string">"www.baidu.com"</span>.getBytes()); <span class="comment">// 无返回值</span></span><br><span class="line">System.out.println(byteArrayOutputStream.toString());</span><br></pre></td></tr></table></figure>

<h6 id="BufferedInputStream-和-BufferedOutputStream"><a href="#BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="BufferedInputStream 和 BufferedOutputStream"></a>BufferedInputStream 和 BufferedOutputStream</h6><p><strong>BufferedInputStream构造方法：</strong><br><code>BufferedInputStream(InputStream in)</code><br>创建一个 BufferedInputStream并保存其参数（输入流 in） ，供以后使用<br><strong>注：</strong></p>
<ul>
<li>一个BufferedInputStream为另一个输入流添加了功能。当创建好流对象后，在内部会创建一个<strong>内部缓冲区数组</strong>，当从流中读取或跳过（skip）字节时，内部缓冲区将根据需要从所包含的输入流中重新填充。</li>
<li>中文的时候必须用Reader，用字节流是没有办法进行处理的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"abc.txt"</span>);</span><br><span class="line">FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((read = bufferedInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// bufferedInputStream.skip(10);</span></span><br><span class="line">        System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure>
<p>读出的中文部分是乱码。</p>
<p><strong>BufferedOutputStream构造方法：</strong><br><code>BufferedOutputStream(OutputStream out)</code><br>创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"123.txt"</span>);</span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">BufferedOutputStream bufferedOutputStream = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(fileOutputStream);</span><br><span class="line">    bufferedOutputStream.write(<span class="number">98</span>);</span><br><span class="line">    bufferedOutputStream.write(<span class="string">"www.aidu.com"</span>.getBytes());</span><br><span class="line">&#125; </span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h6 id="DataInputStream-和-DataOutputStream"><a href="#DataInputStream-和-DataOutputStream" class="headerlink" title="DataInputStream 和 DataOutputStream"></a>DataInputStream 和 DataOutputStream</h6><p>用来装饰其他输入流，以从底层输入流中读取基本java数据类型。即可以<strong>指定</strong>输入输出的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">DataInputStream dataInputStream = <span class="keyword">null</span>;</span><br><span class="line">DataOutputStream dataOutputStream = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 向文件中写入数据流</span></span><br><span class="line">    fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"abc.txt"</span>);</span><br><span class="line">    dataOutputStream = <span class="keyword">new</span> DataOutputStream(fileOutputStream);</span><br><span class="line">    dataOutputStream.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">    dataOutputStream.writeInt(<span class="number">1</span>);</span><br><span class="line">    dataOutputStream.writeShort(<span class="number">222</span>);</span><br><span class="line">    dataOutputStream.writeDouble(<span class="number">22.33</span>);</span><br><span class="line">    dataOutputStream.writeUTF(<span class="string">"www.baidu百度"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件读取数据流</span></span><br><span class="line">    fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"abc.txt"</span>);</span><br><span class="line">    dataInputStream = <span class="keyword">new</span> DataInputStream(fileInputStream);</span><br><span class="line">    <span class="comment">// 读写必须一致</span></span><br><span class="line">    System.out.println(dataInputStream.readBoolean());</span><br><span class="line">    System.out.println(dataInputStream.readInt());</span><br><span class="line">    System.out.println(dataInputStream.readShort());</span><br><span class="line">    System.out.println(dataInputStream.readDouble());</span><br><span class="line">    System.out.println(dataInputStream.readUTF());</span><br><span class="line">&#125; </span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h6 id="ObjectInputStream-和-ObjectOutputStream-（用的少）"><a href="#ObjectInputStream-和-ObjectOutputStream-（用的少）" class="headerlink" title="ObjectInputStream 和 ObjectOutputStream （用的少）"></a>ObjectInputStream 和 ObjectOutputStream （用的少）</h6><blockquote>
<blockquote>
<p><strong>序列化</strong> :把Java对象转换为字节序列的过程<br><strong>反序列化</strong>：字节序列–&gt;Java对象<br><strong>作用</strong>：（1）序列化：在传递和保存对象时，保证对象的完整性和可传递性。对象转换为字节流以便在网络上传输或者保存在本地文件中。<br>（2）反序列化：根据字节流中保存的对象状态和描述信息，通过反序列化重建对象。<br><strong>核心</strong>：整个过程核心点就是字节流中所保存的对象状态及描述信息</p>
</blockquote>
</blockquote>
<p><font color=red><strong>注意：</strong></font><br>如果需要通过io流进行传输，必须要实现以下两点：</p>
<ol>
<li>实现序列化接口。<code>ObjectOutputStream</code>使用<code>writeObject()</code>时，里面的自定义类必须实现<code>Serializable</code>，否则会保错。</li>
<li>需要在自定义类中声明<code>long serialVersionUID = 1L;</code>这个值只是起标志作用，多少无所谓，只要写死就OK。</li>
</ol>
<p>如果不想被人可见的属性比如密码，可以加上<code>transient</code>关键字。</p>
<blockquote>
<p><strong>transient</strong>：瞬时。使用它修饰的变量，在进行序列化的时候，不会被序列化。写入文件时，打开并没有密码，读取时候也不会显示。</p>
</blockquote>
<p>通过ObjectOutputStream的write相关方法写入到文件中的，打开来会发现是乱码，人无法看懂。</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><img src="https://img-blog.csdnimg.cn/20210120135927114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>字符流</strong>读取数据的方式：<br> 一个中文汉字占的字节数要看具体编码。</p>
<p> 如果用字符流能够正确读出中文汉字，而字节流在处理的时候会出现中午文乱码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"abc.txt"</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><pre><code class="java"><span class="comment">// 读的是字符</span>
<span class="keyword">int</span> read = reader.read();
<span class="comment">// 可以读取汉字</span>
System.out.println((<span class="keyword">char</span>)read);
&lt;!--￼<span class="number">7</span>--&gt;</code></pre>
</li>
<li><pre><code class="java"><span class="keyword">int</span> length = <span class="number">0</span>;
<span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];
<span class="keyword">while</span> ((length = reader.read(chars)) != -<span class="number">1</span>) {
    System.out.println(<span class="keyword">new</span> String(chars,<span class="number">0</span>,length));
}
&lt;!--￼<span class="number">8</span>--&gt;
</code></pre>
</li>
</ol>
<p>注：什么时候需要加flush？</p>
<ul>
<li>保险起见，<font color=orange>在输出流关闭之前，每次都进行flush再关闭。</font></li>
<li>当某个输出流对象中带有缓冲区的时候就需要进行flush。</li>
</ul>
<h2 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h2><p>本来要按照一个字节一个<strong>字节</strong>进行处理，现在通过<strong>处理流</strong>在字节外包了一层，相当于是一个对应的<strong>字符</strong>了。现在处理的时候是按照字符为单位进行处理的，而不是再按照字节为单位的。</p>
<blockquote>
<p><strong>字符流优点</strong><br>1）效率。如果是纯文本，用字符流处理效率相对是比较高的。<br>2）灵活性。如果用字符流进行输出的时候，在<code>new</code>的时候可以指定对应的<strong>编码格式</strong>。</p>
</blockquote>
<p><font color=red>InputStreamReader</font> 是<strong>字节流</strong>通向<strong>字符流</strong>的桥梁：它使用指定的 charset 读取字节并将其解码为字符。<br>它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。</p>
<p><font color=red>OutputStreamWriter</font> 是<strong>字符流</strong>通向<strong>字节流</strong>的桥梁</p>
<p><strong>InputStreamReader构造函数：</strong><br><code>InputStreamReader(InputStream in)</code><br>创建一个使用默认字符集的InputStreamReader。 </p>
<p><strong>处理流的使用</strong><br>例如下面将字节流包裹后进行读写。关闭流对象时候建议按照创建时的逆序关闭。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">  outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(fileOutputStream,<span class="string">"jbk"</span>);</span><br><span class="line">  outputStreamWriter.write(<span class="number">99</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"> inputStreamReader = <span class="keyword">new</span> InputStreamReader(fileInputStream,<span class="string">"gbk"</span>);</span><br><span class="line"> <span class="comment">// 数据较少无法占用1024个缓冲区时,不用循环方式，读取一次即可</span></span><br><span class="line"> <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"> <span class="keyword">int</span> len = inputStreamReader.read(chars);</span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(chars,<span class="number">0</span>,len));</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>为什么需要这样的处理流？</strong><br><font color = red><strong>网络传输</strong></font>的数据肯定是纯文本，此时获取到的就是<code>InputStream</code>或者<code>OutputStream</code>的对象。但它们都是根据字节流来处理的，非常低效。因为以知都是纯文本，所以我们包装成<code>InputStreamReader</code>或者<code>OutputStreamReader</code>对象，可以提高效率。<br>Socket中函数只有<code>getOutputStream()</code>和<code>getInputStream()</code>,没有<code>getWriter()</code>,<code>getReader()</code>。想要高效处理，需要在上面套字符流。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流——总结</title>
    <url>/2021/01/21/IO%E6%B5%81%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><mark>万能大法：<br>如果不知道用什么，就用<code>InputStream</code>和<code>OutputStream</code>，字节流是万能的</mark></p>
<p>面试的时候I/O流用的稍微多一点，实际公司一般调用封装好的接口和方法实现功能即可。</p>
<p><img src="https://img-blog.csdnimg.cn/20210121121513279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>掌握：这些IO流对象的API会用，进行一些基本操作即可。</p>
<p><code>org.apache.commons.io</code>包中的FileUtils可以对文件进行操作，如获取文件大小，显示文件名等。<br>jar包获取网址：<a href="https://commons.apache.org/proper/commons-io/download_io.cgi，下载里面的zip压缩包，解压后里面会包括jar包。网址中的doc可以查看API相关内容。" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-io/download_io.cgi，下载里面的zip压缩包，解压后里面会包括jar包。网址中的doc可以查看API相关内容。</a></p>
<p>导入jar包的方法：<br>Project Structure –&gt; Dependencies –&gt; + –&gt; 选择下载好的jar包 </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流——标准输入、输出、打印流</title>
    <url>/2021/01/19/IO%E6%B5%81%E2%80%94%E2%80%94%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day07</a></p>
<p><img src="https://img-blog.csdnimg.cn/20210120135927114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="CharArrayReader-和-CharArrayWriter"><a href="#CharArrayReader-和-CharArrayWriter" class="headerlink" title="CharArrayReader 和 CharArrayWriter"></a>CharArrayReader 和 CharArrayWriter</h3><p>与字节流中<code>ByteArrayStream</code>类似。<br>再次强调，在I/O流中，字节是万能的。而如果是纯文本可以采取字符方式，效率相对更高。</p>
<p><strong>CharArrayReader构造方法：</strong><br><code>CharArrayReader(char[] buf)</code><br>从指定的字符数组中创建CharArrayReader。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="string">"土家族民族自治区ww1"</span>.toCharArray();</span><br><span class="line">CharArrayReader charArrayReader = <span class="keyword">new</span> CharArrayReader(chars);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((read = charArrayReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p><strong>CharArrayWriter构造方法：</strong><br><code>CharArrayWriter()</code><br>创建一个新的CharArrayWriter。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CharArrayWriter charArrayWriter = <span class="keyword">new</span> CharArrayWriter();</span><br><span class="line">charArrayWriter.write(<span class="number">97</span>);</span><br><span class="line">charArrayWriter.write(<span class="number">98</span>);</span><br><span class="line">System.out.println(charArrayWriter);</span><br><span class="line">charArrayWriter.close();</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong><br>输出时候可以直接打印对象显示。输入时候不可以，需要用read方法</p>
<h3 id="FilterReader-（少）"><a href="#FilterReader-（少）" class="headerlink" title="FilterReader （少）"></a>FilterReader （少）</h3><p>用于读取已过滤的字符流，可以指定自己的规则。</p>
<h3 id="BufferedReader-和BufferedWriter-（相对较多）"><a href="#BufferedReader-和BufferedWriter-（相对较多）" class="headerlink" title="BufferedReader 和BufferedWriter （相对较多）"></a>BufferedReader 和BufferedWriter （相对较多）</h3><p>与BufferedInputStream 和 BufferedOutputStream类似。</p>
<p><code>buffered</code>本身是带缓冲区的意思，所以我们可以从一个文件里面读取对应的数据。</p>
<p><strong>BufferedReader构造方法：</strong><br><code>BufferedReader(Reader in)</code><br>创建使用默认大小的输入缓冲区的缓冲字符输入流。 参数是一个Reader对象。</p>
<p>下面第二句会划红线报错，因为Reader和InputStream不匹配（字节是无法直接匹配我们对应的一个字符的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">inputStream = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"aaa.txt"</span>));</span><br></pre></td></tr></table></figure>

<p>改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reader reader = <span class="keyword">null</span>;</span><br><span class="line">reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"aaa.txt"</span>));</span><br></pre></td></tr></table></figure>

<p>接下来取数据，最简单的一种方式，每次读取一个字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> read = reader.read();</span><br><span class="line">System.out.println((<span class="keyword">char</span>)read);</span><br></pre></td></tr></table></figure>

<p>字符读取效率比较低，BuferedReader多了一个<code>readline()</code>，可以按行读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String read = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((read = reader.readLine())!= <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BufferedWriter构造方法：</strong><br><code>BufferedWriter(Writer out)</code><br>创建使用默认大小的输出缓冲区的缓冲字符输出流。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedWriter bufferedWriter = <span class="keyword">null</span>;</span><br><span class="line">FileWriter fileWriter = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fileWriter = <span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">"abc.txt"</span>));</span><br><span class="line">    bufferedWriter = <span class="keyword">new</span> BufferedWriter(fileWriter);</span><br><span class="line">    bufferedWriter.write(<span class="string">"mashibing"</span>); <span class="comment">// 写，返回值是null</span></span><br><span class="line">    bufferedWriter.newLine(); <span class="comment">// 换行</span></span><br><span class="line">    bufferedWriter.append(<span class="string">"m马士兵"</span>); <span class="comment">// 追加,返回值是Writer</span></span><br><span class="line">    bufferedWriter.flush();</span><br><span class="line">&#125; </span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><p>要求：从控制台（标准输入标准输出）进行一个数据读取。</p>
<blockquote>
<p>system类中:<br><img src="https://img-blog.csdnimg.cn/20210120164250469.png" alt="在这里插入图片描述"><br>Stream 一定是针对字节的，而不是字符。<br><strong>如何把字节转为字符？</strong><br>利用<strong>处理流</strong>（字节–&gt;字符）。<br>System.out本身归属于<code>PrintSteam</code>，而<code>PrintStream</code>又归属<code>OutputStream</code><br><img src="https://img-blog.csdnimg.cn/20210120170022807.png" alt="在这里插入图片描述"><br>所以最终可以当成一个OutputStream的子类了，所以可以写成<code>new OutputStreamReader(System.out)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(System.out);</span><br><span class="line">BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(outputStreamWriter);</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String str = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (!str.equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">        str = bufferedReader.readLine();</span><br><span class="line">        bufferedWriter.write(str);</span><br><span class="line">        bufferedWriter.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>关闭四个流非常麻烦，可采取以下方式简化，之后就不需要再关闭I/O流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">             OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(System.out);</span><br><span class="line">             BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(outputStreamWriter);</span><br><span class="line">             BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);) &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><p>要求：例如发送一个请求（输入网址），服务器一定是要返回一个数据的。而这中间也是包含一个I/O流。试想能通过JAVA的I/O流来访问百度并且把首页相关信息返回给我吗？</p>
<p>只要经过网络传输，一般情况下都需要<code>InputStreamReader</code>进行字节转字符和<code>OutputStreamWriter</code>进行字符转字节的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">BufferedWriter bufferedWriter = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>).openStream(),<span class="string">"UTF-8"</span>));</span><br><span class="line">    bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"baidu.html"</span>)));</span><br><span class="line">    String msg =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((msg = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bufferedWriter.write(msg);</span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure>

<h3 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h3><p><code>PrintWriter</code>构造方法：<br>创建一个新的打印流，参数可以是<code>File file</code>，可以是<code>String fileName</code>，也可以是<code>OutputStream out</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream printStream = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    printStream = <span class="keyword">new</span> PrintStream(System.out);</span><br><span class="line"><span class="comment">//            printStream = new PrintStream(new FileOutputStream("123.txt"));</span></span><br><span class="line">    printStream.write(<span class="string">"hello world"</span>.getBytes());</span><br><span class="line">    printStream.println(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(); <span class="comment">// 所以此时printStream就是相当于`System.out`</span></span><br><span class="line">    <span class="comment">// 格式化输出</span></span><br><span class="line">    System.out.printf(<span class="string">"%s--%d---%.2f"</span>,<span class="string">"abc"</span>,<span class="number">123</span>,<span class="number">11.1</span>);</span><br><span class="line">    <span class="comment">// 错误输出 标红打印</span></span><br><span class="line">    System.err.println(<span class="string">"mashibing"</span>);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p><code>System.out</code>归属于<code>printStream</code>。</p>
<h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p>文件类可以对文件进行相关的操作。<br><strong>构造方法：</strong></p>
<ol>
<li><code>RandomAccessFile(File file, String mode)</code><br>创建一个随机访问文件流从File参数指定的文件中读取，并可选地写入文件。  </li>
<li><code>RandomAccessFile(String name, String mode)</code><br>创建随机访问文件流，以从中指定名称的文件读取，并可选择写入文件。<br>mode参数指定要打开文件的访问模式。 允许的值:r,w,s,d</li>
</ol>
<p>通过<code>RandomAccessFile</code>可以利用块来进行一个文件数据的读取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> File file = <span class="keyword">new</span> File(<span class="string">"doc.txt"</span>);</span><br><span class="line"><span class="comment">// 整个文件大小</span></span><br><span class="line"><span class="keyword">long</span> length = file.length();</span><br><span class="line"><span class="comment">// 规定块的大小</span></span><br><span class="line"><span class="keyword">int</span> blockSize = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// 文件可以被切分成多少个块</span></span><br><span class="line"><span class="keyword">int</span> size = (<span class="keyword">int</span>) Math.ceil(length * <span class="number">1.0</span> / blockSize);</span><br><span class="line">System.out.printf(<span class="string">"要被切成%d个块\n"</span>,size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> beginPos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> actualSize = blockSize &gt; length ? (<span class="keyword">int</span>) length : blockSize;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="comment">// 每次读取块的时候的起始偏移量</span></span><br><span class="line">    beginPos = i*blockSize;</span><br><span class="line">    <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">        actualSize = (<span class="keyword">int</span>) length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        actualSize = blockSize;</span><br><span class="line">        length -= actualSize;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i + <span class="string">"--&gt;起始位置是："</span> + beginPos + <span class="string">"--&gt;读取的大小是："</span> + actualSize);</span><br><span class="line">    readSplit(i, beginPos, actualSize); <span class="comment">// 分块读取文件内容</span></span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readSplit</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> beginPos, <span class="keyword">int</span> actualSize)</span> </span>&#123;</span><br><span class="line">RandomAccessFile randomAccessFile = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"doc.txt"</span>),<span class="string">"r"</span>);</span><br><span class="line">    <span class="comment">// 表示从哪个偏移量开始读取数据</span></span><br><span class="line">    randomAccessFile.seek(beginPos);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1020</span>];</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((length = randomAccessFile.read(bytes))!= -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (actualSize &gt; length) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, length));</span><br><span class="line">            actualSize -= length;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, actualSize));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java String intern()原理及其底层相关</title>
    <url>/2021/02/03/Java%20String%20intern()%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%95%E5%B1%82%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<ol>
<li>程序中只有直接写上双引号字符串，才在字符串常量池中</li>
<li>常量池在1.7之后，放置在了堆空间之中。</li>
<li>String类中对象两种实例化的区别：<br>1）直接赋值只会开辟一块堆内存空间，且字符串对象可以保存在对象池中以供下次使用；<br>2）采用构造方法会开辟两块堆内存空间，使用intern()方法后可以手工入池。</li>
</ol>
<blockquote>
<p><code>String s = &quot;Hello world!&quot;;</code>这个语句声明的是一个指向对象的引用，名为“s”，可以指向类型为String的任何对象，目前指向”Hello world!”这个String类型的对象，s保存的是”Hello world!”在常量池中的地址。我们并没有声明一个String对象，我们只是声明了一个只能指向String对象的<strong>引用变量</strong>。<br><code>String string = s;</code>我们只是声明了另外一个只能指向String对象的引用，名为string，并没有第二个对象产生，string还是指向原来那个对象，也就是，和s指向同一个对象。</p>
</blockquote>
<p><strong>案例1</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(str == str2); <span class="comment">// false 地址空间的比较</span></span><br><span class="line">System.out.println(str.equals(str2)); <span class="comment">// true</span></span><br><span class="line">str2 = str2.intern();</span><br><span class="line">System.out.println(str == str2); <span class="comment">// true</span></span><br><span class="line">String str3 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(str == str3); <span class="comment">// true</span></span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;);</span><br><span class="line">System.out.println(str == str4); <span class="comment">// false</span></span><br><span class="line">System.out.println(str4 == str2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>分析：<br><img src="https://img-blog.csdnimg.cn/20210203212739392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=55% height=55% align=center><br>当new String(“abc”)时，在常量池中会创建一个“abc”常量，然后再使用该值对堆中对象初始化。所以不仅是String a = “abc”，直接赋值时会在常量池中产生“abc”字符串。</p>
<p><img src="https://img-blog.csdnimg.cn/20210203213205288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当intern()方法被调用的时候，如果在字符串常量池中已经包含了这个String对象，那么就返回该String对象。否则这个String对象就会被添加到常量池中，然后返回该对象的一个<strong>引用</strong>。并且保证常量池中不会重复。</p>
<p><strong>案例2</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s0&#x3D;&quot;java No.1&quot;;</span><br><span class="line">String s1&#x3D;&quot;java &quot;;</span><br><span class="line">String s2&#x3D;&quot;No.1&quot;;</span><br><span class="line">String s3&#x3D;&quot;java &quot;+&quot;No.1&quot;;</span><br><span class="line">String s4&#x3D;s1+&quot;No.1&quot;;</span><br><span class="line">String s5&#x3D;s1+s2;</span><br><span class="line">System.out.println(s3&#x3D;&#x3D;s0);</span><br><span class="line">System.out.println(s4&#x3D;&#x3D;s0);</span><br><span class="line">System.out.println(s5&#x3D;&#x3D;s0);</span><br><span class="line">System.out.println(s5&#x3D;&#x3D;s4);</span><br><span class="line">System.out.println(&quot;---------&quot;);</span><br><span class="line">final String s6&#x3D;&quot;I am &quot;;</span><br><span class="line">final String s7&#x3D;&quot;guYue&quot;;</span><br><span class="line">String s8&#x3D;&quot;I am guYue&quot;;</span><br><span class="line">String s9&#x3D;s6+s7;</span><br><span class="line">System.out.println(s8&#x3D;&#x3D;s9);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<blockquote>
<p>true<br>false<br>false<br>false<br>----------<br>true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="keyword">new</span> String(<span class="string">"a"</span>)+<span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">s = s.intern();</span><br><span class="line">String s1=<span class="string">"ab"</span>;</span><br><span class="line">System.out.println(s==s1);</span><br></pre></td></tr></table></figure>
<p>我们知道对象s调用intern()方法时，字符串常量池中并没有对象”ab”，所以我们就需要执行将”ab”添加到字符串常量池的的操作。而这时在不同的jdk版本可能就有不同的操作。<br>①jdk6及之前在常量池中创建一个String对象并返回该对象的引用。<br>②jdk7及之后在常量池中保存常量池外String对象的引用，并返回该引用。<br><img src="https://img-blog.csdnimg.cn/20210203223001716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>总结：<br>① “?”+”?”<br>底层<strong>直接优化</strong>为“??”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s0=<span class="string">"java No.1"</span>;</span><br><span class="line">String s1=<span class="string">"java "</span>;</span><br><span class="line">String s2=<span class="string">"No.1"</span>;</span><br><span class="line">String s3=<span class="string">"java "</span>+<span class="string">"No.1"</span>;</span><br></pre></td></tr></table></figure>
<p>查看字节码会发现s0和s3加载过程完全相同。<font color="red">所以是同一个对象</font>。</p>
<p>②“?”+si ，si+”?” , si+sj<br>我把这三种归为一类因为都有引用类型加入运算。</p>
<p>这时候底层会new一个StringBuilder再调用append方法，最后调用toString方法完成拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s4=s1+<span class="string">"No.1"</span>;</span><br></pre></td></tr></table></figure>
<p>查看字节码会发现与上述过程一致。最后再看一下StringBuilder的toString()方法源码，可以发现它返回的是new String，所以<font color="red">肯定不是同一个对象</font>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuilder的toString()方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③final s1+final s2<br>这是两个final修饰的String引用的拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String s6=<span class="string">"I am "</span>;</span><br><span class="line"><span class="keyword">final</span> String s7=<span class="string">"guYue"</span>;</span><br><span class="line">String s8=<span class="string">"I am guYue"</span>;</span><br><span class="line">String s9=s6+s7;</span><br></pre></td></tr></table></figure>
<p>查看代码的字节码，会发现 最后两行的字节码操作过程是<font color="red">完全相同</font>的，即直接从<strong>字符串常量池</strong>中取。</p>
<p><strong>案例3</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回的是4个对象</span></span><br><span class="line">String f = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;</span><br><span class="line">String a1 =<span class="string">"a"</span>;</span><br><span class="line">String a2 =<span class="string">"b"</span>;</span><br><span class="line">String a3 =<span class="string">"c"</span>;</span><br><span class="line">String f1 = a1+a2+a3;</span><br></pre></td></tr></table></figure>
<p>常量池中，不允许有重复字符串。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2021/02/13/JDBC/</url>
    <content><![CDATA[<blockquote>
<p>ODBC（Open Database Connectivity）是一组对数据库访问的标准API。ODBC的最大优点是能以统一的方式处理所有的数据库。</p>
</blockquote>
<p>▪ JDBC(Java Database Connectivity)是基于JAVA语言访问数据库的一种技术。<br>▪ JDBC（Java Data Base Connectivity,<strong>java数据库连接</strong>）是一种用于执行SQL语句的Java API<br>▪ JDBC的设计思想：由sun公司提供的访问数据库的接口，由数据库厂商提供对这些接口的实现，程序员编程时都是针对接口进行编程的。<br>▪ JDBC可以做些什么？<br>&emsp;– 连接到数据库<br>&emsp;– 在Java app中执行SQL命令<br>&emsp;– 处理结果</p>
<p><strong>一、jdbc职责</strong><br>1、java: 客户端 :接收数据、拼接sql 、发送sql、分析结果、返回结果browser<br>2、db: 服务器 :接收sql, 分析处理，返回结果给java</p>
<p><strong>二、jdbc操作</strong><br>把<code>D:\oracle\product\11.2.0\dbhome_1\jdbc\lib</code>中<code>ojdbc6.jar</code>，或者<code>D:\oracle\product\11.2.0\dbhome_1\oui\jlib</code>中的<code>classes12.jar</code>加入到idea中：<br><img src="https://img-blog.csdnimg.cn/20210214092415561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在Driver中可以发现有对应的实现方式：<br><img src="https://img-blog.csdnimg.cn/20210214092553810.png" alt="在这里插入图片描述"><br>这就意味着此时我们已经能够找到对应的实现方式了。当我们把jar包加入后，我们已经能够进行数据库的连接操作了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">//1. 加载驱动</span></span><br><span class="line">   Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line">   <span class="comment">//2. 建立连接</span></span><br><span class="line">   Connection connection = DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@192.168.12.1:1521:orcl"</span>,</span><br><span class="line">            <span class="string">"scott"</span>, <span class="string">"tiger"</span>);</span><br><span class="line">   <span class="comment">//3. 测试是否成功</span></span><br><span class="line">   System.out.println(connection);</span><br><span class="line">   <span class="comment">//4. 定义sql语句</span></span><br><span class="line">   String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">   <span class="comment">//5. 准备静态处理块对象，将sql语句放置到静态处理块中，理解为sql语句放置对象</span></span><br><span class="line">   Statement statement = connection.createStatement();</span><br><span class="line">   <span class="comment">//6. 执行sql语句，返回值对象是结果集合</span></span><br><span class="line">   ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">   <span class="comment">//7. 循环处理</span></span><br><span class="line">   <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">      <span class="keyword">int</span> anInt = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">      System.out.println(anInt);</span><br><span class="line">      String ename = resultSet.getString(<span class="string">"ename"</span>);</span><br><span class="line">      System.out.println(ename);</span><br><span class="line">      System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 8. 关闭连接</span></span><br><span class="line">   statement.close();</span><br><span class="line">   connection.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ol>
<li><p><strong>加载驱动</strong></p>
<blockquote>
<p><font color='red'><strong>Java SPI机制</strong></font><br>SPI(Service Provider Interface)是一种<strong>动态替换发现</strong>的机制， 比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。我们经常遇到的就是java.sql.Driver接口,其他不同厂商可以针对同一接口做出不同的实现，比如oracle和mysql都有不同的实现提供给用户，而Java的SPI机制可以<font color='red'><strong>为某个接口寻找服务实现</strong></font>。<br>spi接口定义在调用方。<br><img src="https://img-blog.csdnimg.cn/20210214102055476.png" alt="在这里插入图片描述"><br>接口对应的抽象SPI接口；实现方实现SPI接口；调用方依赖SPI接口<br>当服务的提供者提供了接口的实现后，需要在指定目录创建以服务接口命名的文件【配置文件】，当程序需要这个服务的时候，就可以通过查找这个jar包的配置文件，里面有接口的具体实现类名，通过这个类名进行加载实例化，就可以使用该服务了。<br>JDK中查找服务实现的工具类是：<code>java.util.ServiceLoader</code>。</p>
</blockquote>
<p>当执行了当前代码后，会返回一个Class对象，在此对象的创建过程中，会调用具体类(OracleDriver)的静态代码块，里面会将当前对象注册进DriverManager</p>
</li>
<li><p><strong>建立连接</strong><br>“jdbc:oracle:thin:@localhost:1521:orcl”<br>thin:不同的数据库连接方式<br>orcl：对应数据库实例（名字）</p>
<blockquote>
<p>数据库DriverManager就用到了SPI机制。<strong>DriverManager</strong>是jdbc里管理和注册不同数据库driver的工具类。针对一个数据库，可能会存在着不同的数据库驱动实现。我们在使用特定的驱动实现时，DriverManager是怎么<font color='red'>获得某确定驱动类</font>的？就是通过第一步把driver静态注册到driverManager中。</p>
</blockquote>
<p>第一步中已经将driver对象注册到了driverManager中，所以此时可以直接通过drivermanager来获取数据库的连接了<br>需要输入连接数据库的参数：</p>
<ul>
<li>url: 数据库的地址</li>
<li>username：用户名</li>
<li>password：密码</li>
</ul>
</li>
<li><p><strong>定义sql语句</strong><br>只要填写正常sql语句即可</p>
</li>
<li><p><strong>准备静态处理块对象，将sql语句放置到静态处理块中，理解为sql语句放置对象</strong><br>在执行sql语句的过程中，需要一个对象来存放sql语句，将对象进行执行的时候，调用的是数据库的服务，数据库会从当前对象中拿到对应的sql语句进行执行。</p>
</li>
<li><p><strong>执行sql语句，返回值对象是结果集合</strong><br>将结果放到resultset中，是返回结果的一个集合,需要经过循环迭代才能获取得到其中的每一条记录.<br>statement在执行的时候可以选择三种方式：<br>1.execute：任何sql语句都可以执行<br>2.executeQuery：只能执行查询语句<br>3.executeUpdate：只能执行DML语句 增删改查</p>
</li>
<li><p><strong>循环处理</strong><br>使用while循环，有两种获取具体值的方式：<br>1.通过下标索引编号来获取 从1开始<br>2.通过列名来获取<br>推荐使用<strong>列名</strong>，列名一般不会发生修改。</p>
</li>
</ol>
<p><strong>查找数据</strong><br>1、存在sql注入问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">getEmpByEname</span><span class="params">(String ename)</span> </span>&#123;</span><br><span class="line">   Connection connection = <span class="keyword">null</span>;</span><br><span class="line">   Statement statement = <span class="keyword">null</span>;</span><br><span class="line">   ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">   Emp emp = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      connection = DButil.getConnection();</span><br><span class="line">      statement = connection.createStatement();</span><br><span class="line">      String sql = <span class="string">"select * from emp where ename = "</span>+ ename;</span><br><span class="line">      System.out.println(sql);</span><br><span class="line">      <span class="comment">// 返回结果</span></span><br><span class="line">      resultSet = statement.executeQuery(sql);</span><br><span class="line">      SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">      <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            emp = <span class="keyword">new</span> Emp(resultSet.getInt(<span class="string">"empno"</span>),resultSet.getString(<span class="string">"ename"</span>),</span><br><span class="line">                  resultSet.getString(<span class="string">"job"</span>),resultSet.getInt(<span class="string">"mgr"</span>),</span><br><span class="line">                  sdf.format(resultSet.getDate(<span class="string">"hiredate"</span>)), resultSet.getDouble(<span class="string">"sal"</span>),</span><br><span class="line">                  resultSet.getDouble(<span class="string">"comm"</span>),resultSet.getInt(<span class="string">"deptno"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">      throwables.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      DButil.closeConnection(connection,statement,resultSet);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> emp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">   EmpDao empDao = <span class="keyword">new</span> EmpDaoImpl();</span><br><span class="line">   Emp emp1 = empDao.getEmpByEname(<span class="string">"'SMITH' or 1 = 1"</span>); </span><br><span class="line">   System.out.println(emp1);<span class="comment">//会打印出emp表中最后一条记录</span></span><br><span class="line">   Emp emp2 = empDao.getEmpByEname(<span class="string">"'SMITH'"</span>);</span><br><span class="line">   System.out.println(emp2);<span class="comment">//会打印出emp表对应的记录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、防止sql注入问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">getEmpByEname</span><span class="params">(String ename)</span> </span>&#123;</span><br><span class="line">   Connection connection = <span class="keyword">null</span>;</span><br><span class="line">   PreparedStatement pstmt = <span class="keyword">null</span>; <span class="comment">// 预处理块</span></span><br><span class="line">   ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">   Emp emp = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      connection = DButil.getConnection();</span><br><span class="line">      String sql = <span class="string">"select * from emp where ename = ?"</span>;</span><br><span class="line">      pstmt = connection.prepareStatement(sql);</span><br><span class="line">      pstmt.setString(<span class="number">1</span>,ename);</span><br><span class="line">      System.out.println(sql);</span><br><span class="line">      <span class="comment">// 返回结果</span></span><br><span class="line">      resultSet = pstmt.executeQuery();</span><br><span class="line">      SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">      <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            emp = <span class="keyword">new</span> Emp(resultSet.getInt(<span class="string">"empno"</span>),resultSet.getString(<span class="string">"ename"</span>),</span><br><span class="line">                  resultSet.getString(<span class="string">"job"</span>),resultSet.getInt(<span class="string">"mgr"</span>),</span><br><span class="line">                  sdf.format(resultSet.getDate(<span class="string">"hiredate"</span>)), resultSet.getDouble(<span class="string">"sal"</span>),</span><br><span class="line">                  resultSet.getDouble(<span class="string">"comm"</span>),resultSet.getInt(<span class="string">"deptno"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">      throwables.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      DButil.closeConnection(connection,pstmt,resultSet);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> emp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">   EmpDao empDao = <span class="keyword">new</span> EmpDaoImpl();</span><br><span class="line">   Emp emp1 = empDao.getEmpByEname(<span class="string">"'SMITH' or 1 = 1"</span>); </span><br><span class="line">   System.out.println(emp1);<span class="comment">//null</span></span><br><span class="line">   Emp emp2 = empDao.getEmpByEname(<span class="string">"SMITH"</span>);</span><br><span class="line">   System.out.println(emp2);<span class="comment">//会打印出emp表对应的记录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>批量提交</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 批量提交 时间比单条插入快</span></span><br><span class="line"><span class="comment">* 中间省略了打开关闭连接过程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertBatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Connection connection = DButil.getConnection();</span><br><span class="line">   String sql = <span class="string">"insert into emp(empno,ename) values(?,?)"</span>;</span><br><span class="line">   PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 准备预处理块对象</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      pstmt = connection.prepareStatement(sql);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pstmt.setInt(<span class="number">1</span>,i);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>,<span class="string">"msb"</span>+i);</span><br><span class="line">            <span class="comment">// 向批处理中添加sql语句</span></span><br><span class="line">            pstmt.addBatch();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span>[] ints = pstmt.executeBatch();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">            System.out.println(anInt);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">      throwables.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      DButil.closeConnection(connection,pstmt);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE复习</title>
    <url>/2021/02/01/JavaSE%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>查看jdk各版本方法<br>方法一 <a href="http://www.oracle.com" target="_blank" rel="noopener">www.oracle.com</a></p>
<ol>
<li>oracle.com –&gt; Products –&gt; Software –&gt; Java</li>
<li>下拖，找到在Oracle Java Products模块下的Java SE</li>
<li>DownLoads Documention 从JDK Release Notes可以点击选择对应版本进行查看</li>
<li>Reference–&gt;Developer Guides可以查看<a href="https://docs.oracle.com/javase/8/docs/index.html" target="_blank" rel="noopener">Java概念图说明</a><br>方法二 jcp.org</li>
<li>点击List of All JSRs<br>前面的编号m就是 JSR m，可以查看对应的一些详细的更改变化</li>
</ol>
<p><strong>动态绑定</strong>：<br>又称为运行时绑定。意思就是说，程序会在运行的时候自动选择调用哪儿个方法<br>例子：</p>
<ol>
<li>子类重写父类中的方法，调用子类中的方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"父类方法："</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类方法"</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Father instance = <span class="keyword">new</span> Son();</span><br><span class="line">        instance.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：子类方法：class Son</span></span><br></pre></td></tr></table></figure></li>
<li>子类没有重写父类中的方法，所以到父类中寻找相应的方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类方法："</span>+<span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Father instance = <span class="keyword">new</span> Son();</span><br><span class="line">        instance.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：父类方法：class Son</span></span><br></pre></td></tr></table></figure></li>
<li>动态绑定只是针对对象的<strong>方法</strong>，对于属性无效。因为<strong>属性不能被重写</strong>。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"父亲属性"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> String name = <span class="string">"孩子属性"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Father instance = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(instance.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：父亲属性</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<img src="https://img-blog.csdnimg.cn/20210202202614472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=80% height=80% align=center>
`new DemoThis().hello();`调用的是当前子类里面的对应方法，或者说子类把父类中的方法继承过来了。
因为父类中的方法也好，子类也好，都已经被子类继承了。

]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2021/03/09/JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="一、JavaScript"><a href="#一、JavaScript" class="headerlink" title="一、JavaScript"></a>一、JavaScript</h2><h3 id="1-1-JavaScript简介"><a href="#1-1-JavaScript简介" class="headerlink" title="1.1 JavaScript简介"></a>1.1 JavaScript简介</h3><p>JavaScript简称JS。它是开发web的<font color='red'><strong>脚本语言</strong></font>。但是它也被用到很多非浏览器环境中【比如：node平台】<br>不同浏览器厂商在浏览器中都内置解析器解析JS语法。<br>Google：V8解析器</p>
<blockquote>
<p>脚本语言：【PHP、JavaScript】<br>一个很大特征：可以嵌套在静态页面中增加动态效果。</p>
</blockquote>
<h3 id="1-2-JavaScript组成"><a href="#1-2-JavaScript组成" class="headerlink" title="1.2 JavaScript组成"></a>1.2 JavaScript组成</h3><p><font color='red'><strong>问题1：前端三层？</strong></font><br>结构层（前面学的标签）<br>样式层（前面学的样式）<br>行为层（JavaScript）<br><font color='red'><strong>问题2：JavaScript组成？</strong></font><br><strong>ECMAScript</strong>（欧洲计算机协会） 每年6月定制语法规范；<br>【<strong>我们学的是2014年规范ES5</strong>】<br><strong>DOM</strong>（document object model 文档对象模型） 常用来操作标签：在JS中<br><strong>BOM</strong>（browser object model 浏览器对象模型）</p>
<h3 id="1-3-JS书写格式"><a href="#1-3-JS书写格式" class="headerlink" title="1.3 JS书写格式"></a>1.3 JS书写格式</h3><p>js属于脚本语言，所以JS语法必须嵌套在静态页面中才可以运行。<br>我们可以利用<script></script>在静态页面中书写JS语法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//这里写js语法</span></span></span><br><span class="line"><span class="actionscript">    alert(<span class="string">"hello world"</span>); <span class="comment">// alert警告</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>js语法必须放置在双闭合标签script里面</li>
<li>双闭合标签script可以放置静态页面中任何地方</li>
<li>程序中可以有多个script标签</li>
</ul>
<h2 id="二、内置功能函数使用"><a href="#二、内置功能函数使用" class="headerlink" title="二、内置功能函数使用"></a>二、内置功能函数使用</h2><h3 id="2-1-警告框——alert"><a href="#2-1-警告框——alert" class="headerlink" title="2.1 警告框——alert"></a>2.1 警告框——alert</h3><p>打开网页后，在浏览器正上方弹出会弹出警告</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">     alert(<span class="string">"aaa"</span>);</span></span><br><span class="line"><span class="actionscript">     alert(<span class="string">"新希望"</span>);   </span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>警告框可以多次使用</li>
<li>js字符串：务必加上单引号或者双引号</li>
</ul>
<h3 id="2-2-提示框——prompt"><a href="#2-2-提示框——prompt" class="headerlink" title="2.2 提示框——prompt"></a>2.2 提示框——prompt</h3><p>在js中内置函数prompt，可以在浏览器正上方弹出提示框</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    prompt(<span class="string">"你的年龄"</span>);</span></span><br><span class="line"><span class="actionscript">    prompt(<span class="string">"你的性别"</span>,<span class="number">123</span>); <span class="comment">//默认值123</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-控制台使用"><a href="#2-3-控制台使用" class="headerlink" title="2.3 控制台使用"></a>2.3 控制台使用</h3><p>consloe.log（打印的数据）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//控制台打印数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"我在控制台打印数据，你看不见"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="number">12306</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h2><p>在js中也有数据类型，也分为：<strong>基本数据类型</strong>（5）、<strong>引用类型</strong>【复杂数据类型】（1）</p>
<p>:—:|:—:|<br>基本数据类型|数值|<br>String:字符串|”helllo”|<br>Number:数字类型|100，3.14|<br>Boolean:布尔类型|true、false|<br>Undefined:未定义|undefined|<br>Null:空对象类型|null|</p>
<p>:—:|:—:|<br>引用数据类型|数值|<br>Object:引用类型|函数、数组、正则、DOM、BOM|</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 字符串是黑色的</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"a你好"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 数值、Boolean是蓝色的</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="number">123.1</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 未定义类型数据、空类型数据也是黑色的</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">undefined</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">null</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>typeof可以检测数据类型</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><font color='purple'><strong>注</strong>：js中存在bug。<br>比如，虽然<code>console.log(typeof null);</code>打印出来是Object（其实不是），但是<strong>null</strong>是属于<strong>Null:空对象类型</strong>。<br>再比如，函数也属于引用类型，但是<code>console.log(typeof 函数名);</code>打印出来是function，但JS中根本没有这个数据类型。<br></font></p>
<h2 id="四、变量"><a href="#四、变量" class="headerlink" title="四、变量"></a>四、变量</h2><p>变量（variable）来源于数学，相当于一个容器，<font color='purple'>可以存储数据</font>。通过<font color='purple'>访问变量名字</font>获取存储数据。<br><strong>JavaScript中变量使用</strong>:<br>1、关键字var声明变量<br>2、给变量赋值<br>3、使用变量            </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//1、声明变量</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> num;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//2、可以给变量进行赋值</span></span></span><br><span class="line">    num = 123;</span><br><span class="line"><span class="actionscript">    <span class="comment">//3、通过访问变量名字获取到对应数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(num);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果只用var声明，不赋值，那默认值就是<code>undefined</code></li>
<li>JS中变量可以声明一次，但可以多次赋值后使用，使用的是最后一次赋值数据。</li>
<li>常把声明和赋值结合一起使用</li>
</ul>
<blockquote>
<p>命名标识符规范<br>可以是数字、英文字母、下划线、美元符号<br>不能以数字开头<br>不能是这门语言中关键字和保留字</p>
</blockquote>
<p><font color='red'>0.1+0.2 == 0.3 是错的。因为遵守IEEE754浮点数标准，所以后面保留17位小数。</font></p>
<h2 id="五、运算符"><a href="#五、运算符" class="headerlink" title="五、运算符"></a>五、运算符</h2><p>JS中有数学运算符、比较运算符、逻辑运算符、赋值运算符等。<br>运算符又称操作符。</p>
<h3 id="5-1-数学运算符（5个）"><a href="#5-1-数学运算符（5个）" class="headerlink" title="5.1 数学运算符（5个）"></a>5.1 数学运算符（5个）</h3><p>JS中<font color='red'>任意类型都可以参与数学运算</font>。除了数字以外的其他类型需要<font color='red'>隐式转换为数字</font>参与数学运算。</p>
<h4 id="5-1-1-数字参与"><a href="#5-1-1-数字参与" class="headerlink" title="5.1.1 数字参与"></a>5.1.1 数字参与</h4><pre><code>+、-、*、/、%</code></pre><p>和数学运算规则相同。注意：<code>console.log(123/10);</code>打印结果是12.3，要是需要取整：<code>parseInt(123/10)</code></p>
<h4 id="5-1-2-布尔参与"><a href="#5-1-2-布尔参与" class="headerlink" title="5.1.2 布尔参与"></a>5.1.2 布尔参与</h4><p>计算机底层自动隐式转换为数字参与。<br>true –&gt; 1<br>false –&gt; 0</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>)); <span class="comment">//1</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>)); <span class="comment">//0</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">true</span>+<span class="number">99</span>);<span class="comment">//100</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-未定义类型参与"><a href="#5-1-3-未定义类型参与" class="headerlink" title="5.1.3 未定义类型参与"></a>5.1.3 未定义类型参与</h4><p>隐式转换为数字参与。<br>undefined –&gt; NaN </p>
<blockquote>
<p><font color='red'><strong>NaN</strong></font> 也是数字类型数值，一般在计算数学运算，但计算不出结果的时候，会返回NaN。<br><code>0 / 0</code>：不会抛异常，而是返回NaN</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">undefined</span>)); <span class="comment">//NaN</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">//NaN</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="literal">NaN</span>*<span class="number">11</span>); <span class="comment">//NaN</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-4-空对象类型参与"><a href="#5-1-4-空对象类型参与" class="headerlink" title="5.1.4 空对象类型参与"></a>5.1.4 空对象类型参与</h4><p>空对象类型（null） 也会隐式转换为数字参与。<br>null –&gt; 0</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">null</span>)); <span class="comment">//0</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">null</span>*<span class="number">99</span>); <span class="comment">//0</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">null</span>+<span class="number">1</span>); <span class="comment">//1</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-5-字符串参与"><a href="#5-1-5-字符串参与" class="headerlink" title="5.1.5 字符串参与"></a>5.1.5 字符串参与</h4><p>字符串也可以参与数学运算，但有些特殊：<br><strong>+ 运算比较特殊</strong>，如果遇到字符串，不是数学中的加法，而是成为<font color='green'><strong>连字符</strong></font>。<br>其他的<code>-、*、/</code>，隐式转换为数字参与。如果字符串是数字，就是对应的数值，如果是字母汉字，就是NaN。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"12"</span> + <span class="number">44</span> +<span class="number">2</span>); <span class="comment">//12442</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"12"</span> - <span class="number">44</span>); <span class="comment">//-32</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"12"</span> / <span class="number">44</span>); <span class="comment">//0.2727272727272727</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"12"</span> * <span class="number">44</span>); <span class="comment">//528</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"zhang三"</span>)); <span class="comment">//NaN</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-比较运算符（8个）"><a href="#5-2-比较运算符（8个）" class="headerlink" title="5.2 比较运算符（8个）"></a>5.2 比较运算符（8个）</h3><p>任意类型数据都可以参与比较运算，比较结果：布尔值true、false。除了数字外，其他类型数据也可以参与比较运算符，但是要转换为数字参与（字符串特殊）。<br>        &gt;、&gt;=、 &lt;、 &lt;=、 == 、!= 、===、!===<br><mark>==：相等判断，看数值是否一样；<br>===：全等，看数值、数据类型</mark></p>
<h4 id="5-2-1-基本数据类型比较"><a href="#5-2-1-基本数据类型比较" class="headerlink" title="5.2.1 基本数据类型比较"></a>5.2.1 基本数据类型比较</h4><p>除了数字类型，其他基本数据类型会先隐式转换为数字，再来参与。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">false</span> == <span class="number">0</span>); <span class="comment">//true</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">false</span> === <span class="number">0</span>); <span class="comment">//false</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="number">0</span> == <span class="number">0</span>); <span class="comment">//true</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="number">0</span> === <span class="number">0</span>); <span class="comment">//true</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="number">666</span> &gt; <span class="literal">null</span>); <span class="comment">//true</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">NaN</span> &gt; <span class="number">100</span>); <span class="comment">//false</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="number">0</span>); <span class="comment">//false</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">null</span> &gt;= <span class="number">0</span>); <span class="comment">//true</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">//false</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>NaN这个数值本身就不能确定。</p>
<h4 id="5-2-2-字符串比较（奇葩）"><a href="#5-2-2-字符串比较（奇葩）" class="headerlink" title="5.2.2 字符串比较（奇葩）"></a>5.2.2 字符串比较（奇葩）</h4><p>字符串参与比较的时候，分为两种情况：<br>第一种，字符串和数字比较<br>第二种，字符串和字符串比较</p>
<p>字符串和数字比较，隐式转换为数字进行比较<br>字符串和字符串比较,比较的是ASCII值：两个字符串从左到右依次进行字符比较，直到某个字符比较出结果，比较结束。<br>        0<del>9 &lt; A</del>Z &lt; a~z 从左到右依次变大</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">   <span class="comment">// 字符串和数字比较</span></span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(<span class="string">"66"</span> == <span class="number">66</span>); <span class="comment">//true</span></span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(<span class="string">"66"</span> === <span class="number">66</span>); <span class="comment">//false</span></span></span><br><span class="line"><span class="actionscript">   <span class="comment">// 字符串和字符串比较</span></span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(<span class="string">"a1"</span>&gt;<span class="string">"A1"</span>); <span class="comment">//true</span></span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(<span class="string">"张三"</span>&gt;<span class="string">"z"</span>); <span class="comment">//true</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-逻辑运算符（3个）"><a href="#5-3-逻辑运算符（3个）" class="headerlink" title="5.3 逻辑运算符（3个）"></a>5.3 逻辑运算符（3个）</h3><pre><code>与、或、非</code></pre><p>JS中任意类型数据都可以参与，但除了布尔值以外的数据需要隐式转换为布尔类型再参与运算。</p>
<h4 id="5-3-1-逻辑与"><a href="#5-3-1-逻辑与" class="headerlink" title="5.3.1 逻辑与"></a>5.3.1 逻辑与</h4><pre><code>A &amp;&amp; B</code></pre><p>两者同为真才为真，结果看B。否则为假，结果看假的那一个。如果都为假，就看A。</p>
<h4 id="5-3-2-逻辑或"><a href="#5-3-2-逻辑或" class="headerlink" title="5.3.2 逻辑或"></a>5.3.2 逻辑或</h4><pre><code>A || B</code></pre><p>两者同为假才为假，结果看B。否则为真，结果看真的那一个。如果都为真，就看A。</p>
<h4 id="5-3-3-逻辑非"><a href="#5-3-3-逻辑非" class="headerlink" title="5.3.3 逻辑非"></a>5.3.3 逻辑非</h4><pre><code>!A</code></pre><p>js中取反可以连续用多个<code>!</code></p>
<h4 id="5-3-4-隐式转换"><a href="#5-3-4-隐式转换" class="headerlink" title="5.3.4 隐式转换"></a>5.3.4 隐式转换</h4><p>:—:|:—:|<br>数据|Boolean|<br>0|false|<br>NaN|false|<br>非0、NaN数字|true|<br>空字符串|false|<br>非空字符串|true|<br>undefined|false|<br>null|false|</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="literal">NaN</span> &amp;&amp; <span class="number">0</span>);<span class="comment">//都假，看前者。NaN</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="literal">NaN</span> &amp;&amp; <span class="number">32</span>);<span class="comment">//NaN</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"张三"</span> &amp;&amp; <span class="string">"李四"</span>);<span class="comment">//都真，看后者。李四</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="literal">NaN</span> || <span class="number">0</span>);<span class="comment">//都假，看后者。0</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"张三"</span> || <span class="string">"李四"</span>);<span class="comment">//都真，看前者。张三</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="六、条件语句"><a href="#六、条件语句" class="headerlink" title="六、条件语句"></a>六、条件语句</h2><p>JS中也有条件语句和循环语句。</p>
<ul>
<li>if中的条件要是布尔值，其他类型会进行隐式转换进行参与。</li>
<li>一行代码可以省略花括号。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> score = prompt(<span class="string">"你的分数："</span>);</span></span><br><span class="line">    if (score&gt;=60) &#123;</span><br><span class="line"><span class="actionscript">        alert(<span class="string">"及格"</span>);</span></span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;=<span class="number">80</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"优秀"</span>);</span></span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"不及格"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="七、循环语句"><a href="#七、循环语句" class="headerlink" title="七、循环语句"></a>七、循环语句</h2><h3 id="7-1-for循环"><a href="#7-1-for循环" class="headerlink" title="7.1 for循环"></a>7.1 for循环</h3><ul>
<li>JS中，for循环头的第一部分（var i = 0;）,认为是<font color='red'><strong>全局变量</strong></font>，可以在循环体外使用。 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;hello&lt;/h1&gt;"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(i); <span class="comment">//会打印出10</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="7-2-while循环"><a href="#7-2-while循环" class="headerlink" title="7.2 while循环"></a>7.2 while循环</h3><p>循环内的变量，当成局部变量，在循环体外依旧能用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> i = <span class="number">10</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">while</span>(i--) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(i); <span class="comment">// 9~0</span></span></span><br><span class="line">       sum += i; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(sum); <span class="comment">//45</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> i = <span class="number">10</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">do</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(i); <span class="comment">// 10~0</span></span></span><br><span class="line">        sum += i; </span><br><span class="line"><span class="actionscript">    &#125;<span class="keyword">while</span>(i--)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(sum); <span class="comment">//45</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>和java中一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">System.out.println(i-- + <span class="string">" "</span>+i); <span class="comment">// 10 9 </span></span><br><span class="line">System.out.println(--i + <span class="string">" "</span>+i); <span class="comment">// 8 8 </span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="7-3-break-和-continue关键字"><a href="#7-3-break-和-continue关键字" class="headerlink" title="7.3 break 和 continue关键字"></a>7.3 break 和 continue关键字</h3><p>用法和java几乎一样。<br>break可以终止就近循环语句（立刻终止）<br>continue可以终止这一次循环，去执行下一次循环。<br>和Java中一样，循环也可以起名字：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> i = <span class="number">3</span>;</span></span><br><span class="line"><span class="actionscript">    waiceng: <span class="keyword">while</span>(i--) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(i); <span class="comment">// 2 1</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="keyword">break</span> waiceng;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h2><p>比如，之前学的内置函数：alert【警告框】、prompt【提示框】<br>js中，函数也分为两部分：声明+调用<br>js中声明方式：关键字function来声明函数、表达式声明函数</p>
<h3 id="8-1-关键字函数"><a href="#8-1-关键字函数" class="headerlink" title="8.1 关键字函数"></a>8.1 关键字函数</h3><blockquote>
<p>语法：<br>//声明部分<br>function 函数名() {<br>    函数体<br>}<br>// 调用部分<br>函数名();</p>
</blockquote>
<p>js中<strong>形参</strong>自动为var类型，不需要自己定义</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 无参</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    fun(); <span class="comment">//打印hello</span></span></span><br><span class="line"><span class="actionscript">    fun(); <span class="comment">//打印hello</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// 有参</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(a,b)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>+a+b);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    sum(<span class="number">2</span>,<span class="string">"zhang三"</span>);  <span class="comment">//打印hello2zhang三</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-全局变量和局部变量"><a href="#8-2-全局变量和局部变量" class="headerlink" title="8.2 全局变量和局部变量"></a>8.2 全局变量和局部变量</h3><p>在js中，<strong>局部变量</strong>只有两种情况：</p>
<ol>
<li>作为函数形参【只能在函数体中使用】</li>
<li>在函数体中声明变量【只能在函数体中使用】</li>
</ol>
<p>其他都是<strong>全局变量</strong>。在js<mark>行为层</mark>中任意地方使用。</p>
<h3 id="8-3-作用域"><a href="#8-3-作用域" class="headerlink" title="8.3 作用域"></a>8.3 作用域</h3><p><strong>作用域</strong>【scope】，是代码的书写范围。<br>js语法最大的作用域就是双标签script之间。也称为<font color='red'><strong>全局作用域</strong></font>。</p>
<p><font color='red'><strong>函数作用域</strong></font>：函数体</p>
<h3 id="8-4-1-5JS当中没有函数重载"><a href="#8-4-1-5JS当中没有函数重载" class="headerlink" title="8.4 1.5JS当中没有函数重载"></a>8.4 1.5JS当中没有函数重载</h3><p>如果有多个重名函数，会调用最后一个，永远是后者覆盖前者。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">(a)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"hello1"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">(a,b)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"hello2"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">(a,b,c)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"hello3"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    fun(<span class="string">"zhang三"</span>); <span class="comment">// hello3</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-5-关键字return"><a href="#8-5-关键字return" class="headerlink" title="8.5 关键字return"></a>8.5 关键字return</h3><p>return经常结合函数一起使用，可以将函数计算完的结果返回。<br>注:<br>return只能在函数体中使用<br>在函数体中return关键字后面的语句不执行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">(a)</span> </span>&#123;</span></span><br><span class="line">        if(a &gt; 2) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span>;</span></span><br><span class="line">        &#125; </span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> a;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(fun(<span class="number">3</span>)); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="九、数组"><a href="#九、数组" class="headerlink" title="九、数组"></a>九、数组</h2><h3 id="9-1-基本使用"><a href="#9-1-基本使用" class="headerlink" title="9.1 基本使用"></a>9.1 基本使用</h3><p>array：数组</p>
<ul>
<li>在JS中也有数组存在，可以存储很多有序数据(可以是任意类型)</li>
<li>数值在JS中是<font color='cycan'><strong>引用类型数据</strong></font>，在JS中数组是用中括号表示<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log([]); <span class="comment">//[]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> []); <span class="comment">//object</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 数组可以一次性存储很多数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]); <span class="comment">//(5) [1, 2, 3, 4, 5] array[5]</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>JS中数组可以存储、读取、修改、新增。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//为了在js中使用数组方便，常将右侧数组赋值给左侧变量（通过变量名访问数组）</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//存储数据</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> arr = [<span class="string">"hello"</span>,<span class="number">123</span>,<span class="literal">true</span>,<span class="literal">NaN</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]];</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//读取数据，通过枚举法 + 下标获取</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr[<span class="number">0</span>]); <span class="comment">//hello</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr[<span class="number">4</span>][<span class="number">1</span>]); <span class="comment">//3</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//修改数组中已有的数据</span></span></span><br><span class="line"><span class="actionscript">    arr[<span class="number">1</span>] = <span class="string">"你好"</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr[<span class="number">1</span>]);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//新增数据</span></span></span><br><span class="line"><span class="actionscript">    arr[<span class="number">5</span>] = <span class="string">"xinz"</span>;</span></span><br><span class="line"><span class="actionscript">    arr[<span class="number">7</span>] = <span class="number">12</span>; <span class="comment">// arr[6] 用undefined进行填充</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr);<span class="comment">//(8) ["hello", "你好", true, NaN, Array(3), "xinz", empty, 12]</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>length属性</strong>  <code>arr.length</code> 活获得数组元素个数</p>
<h3 id="9-2-数组方法"><a href="#9-2-数组方法" class="headerlink" title="9.2 数组方法"></a>9.2 数组方法</h3><p><font color='cycan'><strong>pop</strong></font>：移除元素 在数组尾部移除一个元素并返回删除的元素<br><font color='cycan'><strong>push</strong></font>：新增元素 在数组尾部添加一个或者多个元素并返回length</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr = [<span class="string">"阿文"</span>,<span class="string">"发财"</span>,<span class="string">"核桃"</span>];</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// pop方法</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> res = arr.pop();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr); <span class="comment">//(2) ["阿文", "发财"]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(res); <span class="comment">// 核桃</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//push方法</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> res = arr.push(<span class="string">"曹操"</span>,<span class="string">"饭团"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr);<span class="comment">//(4) ["阿文", "发财", "曹操", "饭团"]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(res);<span class="comment">//4</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><font color='cycan'><strong>shift</strong></font>：在数组头部删一个元素，并返回删除的元素<br><font color='cycan'><strong>unshift</strong></font>：在数组头部增一个或多个元素，并返回length</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var arr &#x3D; [&quot;北京&quot;,&quot;天津&quot;,&quot;南京&quot;,&quot;上海&quot;];</span><br><span class="line">    &#x2F;&#x2F;shift方法</span><br><span class="line">    var res &#x3D; arr.shift();</span><br><span class="line">    console.log(arr); &#x2F;&#x2F;(3) [&quot;天津&quot;, &quot;南京&quot;, &quot;上海&quot;]</span><br><span class="line">    console.log(res); &#x2F;&#x2F;北京</span><br><span class="line">    &#x2F;&#x2F;unshift方法</span><br><span class="line">    var res &#x3D; arr.unshift(&quot;吉林&quot;,&quot;哈尔滨&quot;);</span><br><span class="line">    console.log(arr); &#x2F;&#x2F;(5) [&quot;吉林&quot;, &quot;哈尔滨&quot;, &quot;天津&quot;, &quot;南京&quot;, &quot;上海&quot;]</span><br><span class="line">    console.log(res); &#x2F;&#x2F;5</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><font color='cycan'><strong>reverse</strong></font>：让数组元素进行倒置<br><font color='cycan'><strong>indexof</strong></font>：获取某一个元素的从左到右第一个索引值，如果没有返回-1</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr = [<span class="string">"北京"</span>,<span class="string">"天津"</span>,<span class="string">"南京"</span>,<span class="string">"上海"</span>];</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// reverse方法</span></span></span><br><span class="line">    arr.reverse();</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr);<span class="comment">//(4) ["上海", "南京", "天津", "北京"]</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// indexof方法</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr.indexOf(<span class="string">"北京"</span>)); <span class="comment">// 3</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><font color='cycan'><strong>join</strong></font>：可以通过某一个字符<strong>将数组转换为字符串</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//join方法</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr = [<span class="string">"北京"</span>,<span class="string">"天津"</span>,<span class="string">"南京"</span>,<span class="string">"上海"</span>];</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr.join());<span class="comment">//北京,天津,南京,上海</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr.join(<span class="string">""</span>));<span class="comment">//北京天津南京上海</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><font color='cycan'><strong>concat</strong></font>：合并数组，<strong>对初始数组没有影响</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//concat方法：合并数组</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> c = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(a.concat(b,c)); <span class="comment">//(9) [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(a,b,c); <span class="comment">//(3) [1, 2, 3] (3) [4, 5, 6] (3) [7, 8, 9]</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><font color='cycan'><strong>slice</strong></font>：切片。切割数组[a,b),<strong>对起始数组没有任何影响</strong>。</p>
<blockquote>
<p>语法：<br>arr.slice(起始位置a,结束位置b);</p>
</blockquote>
<p><font color='cycan'><strong>splice</strong></font>：切割数组，也可以插入、替换数据。<strong>对起始数组有影响</strong>。</p>
<blockquote>
<p>语法：<br>arr.slice(起始位置a,长度);</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//slice方法：对起始数组没有影响</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> newArr1 = arr.slice(<span class="number">1</span>);<span class="comment">//从第2个开始切到最后</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> newArr2 = arr.slice(<span class="number">1</span>,<span class="number">3</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> newArr3 = arr.slice(<span class="number">-2</span>);<span class="comment">//从倒数第二个开始切到最后</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr); <span class="comment">//(4) [1, 2, 3, 4]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(newArr1); <span class="comment">//(3) [2, 3, 4]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(newArr2); <span class="comment">//(2) [2, 3]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(newArr3); <span class="comment">//(2) [3, 4]</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//splice方法 ：对起始数组有影响</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr); <span class="comment">//(4) [1, 2, 3, 4]</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> newArr11 = arr.splice(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//从第2个开始,长度为2</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr); <span class="comment">//(2) [1, 4]</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(newArr11); <span class="comment">//(2) [2, 3]</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//插入数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr);<span class="comment">//(2) [1, 4]</span></span></span><br><span class="line"><span class="actionscript">    arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">"哈哈哈"</span>,<span class="number">3</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr); <span class="comment">//(4) [1, "哈哈哈", 3, 4]</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//替换并插入数据</span></span></span><br><span class="line"><span class="actionscript">    arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"咯咯"</span>,<span class="number">6</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(arr); <span class="comment">//(5) [1, "咯咯", 6, 3, 4]</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中子类的访问权限为何比父类大？</title>
    <url>/2021/02/02/Java%E4%B8%AD%E5%AD%90%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%B8%BA%E4%BD%95%E6%AF%94%E7%88%B6%E7%B1%BB%E5%A4%A7%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>向上转型及java程序设计维护的原因</strong></p>
<p>例:<br>假设一个父类A 拥有的方法  public void setXXX(){}   可以被其他任意对象调用<br>这个方法被子类B 覆写后为 protected void setXXX(){}  即 默认的访问权限只能被本类、本包及其子类 所访问</p>
<p>假设 其他包中的对象 C  调用方法为：<br>        get( A  a){<br>            a.setXXX();<br>        }<br>而此时传入的对象为B类对象，假设为b，此时b将转型为a，但是b中的setXXX() 调用权限已经被缩小了，这将造成错误。所以子类的方法的访问权限不能小于父类。</p>
<p>以上只是一个例子还有其他出于<strong>易维护、易代码结构设计</strong>的设计思想原因</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>01-Java基本语法</title>
    <url>/2020/07/10/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li>四类八种基本数据类型，不包括字符串；引用数据类型包括数组……</li>
<li>常量：程序运行期间内容不可改变的量。<br><img src="https://img-blog.csdnimg.cn/20200714145805690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>变量：每次每个变量只能保存一个数据变量，必须确定数据类型，</li>
<li>类型转换：<br>· &emsp;自动类型转换：范围小的类型向范围大的类型提升。<br>byte、short、char -》int -》long-》float-》double<br>&emsp;与字节数不一定相关。<br><img src="https://img-blog.csdnimg.cn/202007141500543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·&emsp;强制类型转换：将 取值范围大的类型 强制转换成 取值范围小的类型<br>&emsp;例如：int i = (int)1.5;</li>
<li>数组：引用数据类型<br>·&emsp; 数组的长度在程序运行期间不可改变。可以改变称号。<br><img src="https://img-blog.csdnimg.cn/20200714150134363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·&emsp;初始化：</li>
<li>动态初始化（指定长度）<br>int[] a = new int[3]; // 定义可以存储3个整数的数组容器<br>可拆分成：<br>int[] a;<br>a = new int[3];</li>
<li>静态初始化（指定内容）自动推算出长度<br>标准格式：<br>int[] a = new int[] {1, 2, 3}; // 一个数组，里面有1，2，3<br>可拆分成：<br>int[] a；<br>a = new int[] {1, 2, 3};<br>省略格式：(不能拆成两个步骤)<br>int[] a = {1, 2, 3}; </li>
<li>java内存划分：<br>Java 内存需要划分成5个部分：</li>
<li>栈（Stack）：存放的都是方法中的局部变量。方法运行一定要在栈当中。<br>局部变量：方法的参数或是方法体内部的变量<br>作用域：一旦超出作用域，立即从栈内存中消失</li>
<li>堆（Heap）：new出来的都在堆中<br>堆内存里面存放的东西都有一个地址值：16进制（0x）</li>
</ol>
<table>
<thead>
<tr>
<th align="center">整数</th>
<th align="center">默认0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">浮点数</td>
<td align="center">0.0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">字符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">布尔</td>
</tr>
<tr>
<td align="center">引用</td>
<td align="center">Null</td>
</tr>
</tbody></table>
<ol start="3">
<li>方法区（Method Area）：存储.class相关信息，包含方法的信息。（名字，参数，返回值）</li>
<li>本地方法栈（Navitive Method Stack）：与操作系统相关</li>
<li>寄存器（pc Register）：与cpu相关</li>
</ol>
<p>一个数组的内存图<br><img src="https://img-blog.csdnimg.cn/20200714150548141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>两个引用指向同一个内存图<br><img src="https://img-blog.csdnimg.cn/20200714150607325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol start="7">
<li>数组的长度：a.length </li>
<li>数组可以作为方法的参数，当调用方法的时候，传参进去的是地址值。</li>
<li>方法只能有一个或者0个返回值。多个数据返回，可用数组。返回的也是数组的地址值。<br>public static int[] calculate(int a, int b, int c) {<br>……<br>int[] array = {sum, avg};<br>return array;<br>}</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程</title>
    <url>/2021/01/27/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day08</a></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>网络</strong></p>
<ol>
<li>多台计算机组成，使用物理线路连接</li>
<li>交换数据，共享资源</li>
</ol>
<p><strong>网络编程三要素</strong></p>
<ol>
<li>IP地址：唯一标识网络上每一台计算机，<br>两台计算机间通信必备要素     <code>ipconfig</code>查看</li>
<li>端口号：计算机中应用程序的编号<br>有效端口0~65536<br>系统使用或保留端口0~1024</li>
<li>通信协议：通信的规则   TCP UDP<br>国际通用协议TCP/IP协议</li>
</ol>
<p><strong>网络分层模型</strong><br>网络模型一：<br><strong>OSI</strong>开发系统互联参考模型</p>
<p>网络模型二：<br>TCP/IP参考模型：Transfer Control Protocol/Internet Protocol传输控制/网际协议<br><img src="https://img-blog.csdnimg.cn/20210127154629160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>IP地址表示方法</strong>：<br>IP地址一共32位。<br>IP地址 = 网络IP + 主机IP</p>
<ul>
<li>网络ID：标识计算机或网络设备所在网段</li>
<li>主机ID：标识特定主机或网络设备</li>
</ul>
<blockquote>
<p>特殊的IP地址<br>0.0.0.0：本机 更多是阻断和外网的通信<br>127.0.0.1：本机回环地址，用于本机测试 localhost 可以通信<br>255.255.255.255：当前子网，一般用于向当前子网广播信息</p>
</blockquote>
<p><strong>IP地址所对应的对象–&gt;InetAddress</strong><br>Java提供了一个对ip地址的访问类<code>java.net.InetAddress</code>。无构造方法。</p>
<details><summary>InetAddressDemo.java</summary>
<pre><code>public class InetAddressDemo {
    public static void main(String[] args) throws UnknownHostException {
        InetAddress localHost = InetAddress.getLocalHost();
        System.out.println(localHost); // 主机名+IP地址

<pre><code>    // 自己局域网内（同一网段内）的主机名才能拿到ip地址
    InetAddress inetAdd = InetAddress.getByName(&quot;LAPTOP-8VFER8KN&quot;);
    System.out.println(inetAdd);

    //拿到百度的ip地址
    InetAddress baidu = InetAddress.getByName(&quot;www.baidu.com&quot;);
    System.out.println(baidu);
    System.out.println(baidu.getHostAddress());
    System.out.println(baidu.getHostName());
}</code></pre><p>}</pre></code></details></p>
<p><strong>端口：port</strong><br>端口是虚拟概念，并不是主机上真的有若干端口。通过端口可以在一个主机上运行多个网络应用程序。</p>
<p><strong>传输协议</strong><br>UDP：</p>
<ul>
<li>相当于发短信（有字数限制），不需要建立连接，效率较高但容易丢包</li>
<li>数据报大小限制在64k内<br>TCP：</li>
<li>相当于打电话，需要建立连接，效率较低但数据传输安全。</li>
<li>三次握手和四次分手。<blockquote>
<p>为什么要三次握手？<br>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。<br>为什么要四次分手？<br>A、B通信，如果三次分手可能会造成：A端已经释放了资源，但B端的资源没有释放。这就会造成我们对应资源的一种浪费。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>视频是用UDP还是TCP？<br>可以先用TCP建立连接，再用UDP传输数据。视频掉帧影响不大</p>
</blockquote>
<p><strong>Socket套接字</strong></p>
<ul>
<li>网络上两个程序通过一个<strong>双向的通信连接</strong>实现数据的交换，这个连接的一端(接收数据的地方，接收IO请求的，可以读写数据的地方)称为一个<strong>Socket</strong>。</li>
<li>比如两台计算机互联，需要个接口，那么这个网线就是socket。两个程序互连，存在网络上，所以是一个<strong>逻辑上</strong>的概念，相当于虚拟接口。</li>
<li>Socket是Java中定义好的一个类，Java中使用Socket完成<strong>TCP</strong>程序的开发，使用它可以方便地建立<font color = red><strong>可靠</strong>、<strong>双向</strong>、<strong>持续性</strong>（消息没发完不可能断）、<strong>点对点</strong></font>的通讯连接。</li>
<li>在Socket的程序开发中，服务器端使用<font color = red><strong>ServerSocket</strong></font>等待客户端的连接（ServerSocket相当于是硬件设备）<br><img src="https://img-blog.csdnimg.cn/20210127171611100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="基于TCP协议的Socket编程"><a href="#基于TCP协议的Socket编程" class="headerlink" title="基于TCP协议的Socket编程"></a>基于TCP协议的Socket编程</h3><p>进行网络通信时，Socket需要借助<strong>数据流</strong>来完成数据的传输工作。</p>
<ol>
<li>通信双方需要建立连接</li>
<li>连接建立时双方存在主次之分。（先服务端再客户端）</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210127172249713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>Socket类</strong><br><code>java.net.Socket</code><br>双端通信：<br>客户端向服务端发送数据</p>
<ul>
<li>先启动<strong>服务端</strong>，如果先启动客户端会报拒绝连接的错误</li>
<li>如果启动两次服务端也会报错（地址被占用），因为端口只能绑定一次<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"> <span class="comment">// 创建客户端的套接字</span></span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">10000</span>);</span><br><span class="line"><span class="comment">//-------------向外进行输出----------------</span></span><br><span class="line"><span class="comment">// 获取输出流对象</span></span><br><span class="line">OutputStream outputStream = client.getOutputStream();</span><br><span class="line"><span class="comment">// 数据输出</span></span><br><span class="line">outputStream.write(<span class="string">"hello java"</span>.getBytes());</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 或者：</span></span><br><span class="line"><span class="comment"> * // 将输出流对象进行包装</span></span><br><span class="line"><span class="comment"> * DataOutputStream dataOutputStream = new DataOutputStream(outputStream);</span></span><br><span class="line"><span class="comment"> * // 传输数据</span></span><br><span class="line"><span class="comment"> * dataOutputStream.writeUTF("hello,你好");</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> <span class="comment">//--------------接受服务器端返回的消息----------------------</span></span><br><span class="line">InputStream inputStream = client.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> length = inputStream.read(buf);</span><br><span class="line">System.out.println(<span class="string">"服务端的响应数据是："</span>+<span class="keyword">new</span> String(buf,<span class="number">0</span>,length));</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭流操作</span></span><br><span class="line">inputStream.close();</span><br><span class="line">outputStream.close();</span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Server.java</span></span><br><span class="line"> <span class="comment">// 创建servertsocket对象</span></span><br><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">10000</span>);</span><br><span class="line"><span class="comment">// 获取服务器的套接字对象</span></span><br><span class="line">Socket server = serverSocket.accept();</span><br><span class="line"><span class="comment">//-------------接受客户端的输入----------------</span></span><br><span class="line"><span class="comment">// 获取输入流对象</span></span><br><span class="line">InputStream inputStream = server.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> length = inputStream.read(buf);</span><br><span class="line">System.out.println(<span class="string">"客户端传输的数据是："</span> +<span class="keyword">new</span> String(buf,<span class="number">0</span>,length));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 或者：</span></span><br><span class="line"><span class="comment"> *  // 对输入流做包装，包装成DataInputStream</span></span><br><span class="line"><span class="comment"> *  DataInputStream dataInputStream = new DataInputStream*(inputStream);</span></span><br><span class="line"><span class="comment"> *  // 读取对应的数据</span></span><br><span class="line"><span class="comment"> *  String s = dataInputStream.readUTF();</span></span><br><span class="line"><span class="comment"> *  System.out.println(s);</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="comment">//-------------向进客户端进行输出----------------</span></span><br><span class="line">OutputStream outputStream = server.getOutputStream();</span><br><span class="line"><span class="comment">// 数据输出</span></span><br><span class="line">outputStream.write(<span class="string">"hello from server"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭流对象</span></span><br><span class="line">outputStream.close();</span><br><span class="line">inputStream.close();</span><br><span class="line">server.close();</span><br><span class="line">serverSocket.close();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><font color=red>注</font>：</p>
<ol>
<li>不能自动关闭流，必须手动进行关闭</li>
<li>当数据比较大的时候，需要添加输入输出流完成的标志<br>shutdownOutput()或者shutdownInput()</li>
<li>如果传输的是对象，需要用到<code>ObjectOutputStream</code>，序列化</li>
</ol>
<blockquote>
<p>IDEA 实现<code>Serializable</code>接口时，自动生成UID值的方法。<br>File –&gt; Settings –&gt; Editor –&gt; Inspections –&gt; Java –&gt; Serialization issues –&gt; 勾选“Serializable class without ‘serialVersionUID’”<br>之后选择类名，按”alt + enter”，可以随机生成数字作为UID</p>
</blockquote>
<h3 id="基于UDP的网络编程（用的少）"><a href="#基于UDP的网络编程（用的少）" class="headerlink" title="基于UDP的网络编程（用的少）"></a>基于UDP的网络编程（用的少）</h3><ol>
<li>通信双方不需要建立连接</li>
<li>通信双方完全平等</li>
</ol>
<p>同样需要用到套接字，只不过变成了<code>DatagramSocket</code>（此类表示用于发送和接收数据报数据包的套接字）</p>
<p><code>DatagramPacket</code>：该类表示数据报包。用于实现无连接传送服务。</p>
<details><summary>UDPClient.java</summary>
<pre><code>/**
 * 客户端向服务端传送消息
 * 先后启动无顺序
 */
public class UDPClient {
    public static void main(String[] args) throws Exception {
        // 创建UDP通信的socket 自己对应的端口
        DatagramSocket datagramSocket = new DatagramSocket(10000);
        // 从控制台读取数据
        Scanner scanner = new Scanner(System.in);
        String str = scanner.nextLine();
        // 远程的地址和端口
        DatagramPacket datagramPacket = new DatagramPacket(str.getBytes(),str.length(),
                InetAddress.getByName("localhost"),10001);
        // 发送数据
        datagramSocket.send(datagramPacket);
        datagramSocket.close();
    }
}</code></pre>
</details>
<details><summary>UDPServer.java</summary>
<pre><code>public class UDPServer {
    public static void main(String[] args) throws Exception {
        DatagramSocket datagramSocket = new DatagramSocket(10001);
        //--------接收数据----------
        byte[] buf = new byte[1024];
        // 用来接收传输过来的数据
        DatagramPacket datagramPacket = new DatagramPacket(buf,buf.length);
        // 利用创建好的数据报包来接收数据
        datagramSocket.receive(datagramPacket);
        // 打印输出信息
        System.out.println(new String(datagramPacket.getData(),0,datagramPacket.getLength()));
        datagramSocket.close();
    }
}</code></pre>
</details>]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>Java网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合总结</title>
    <url>/2020/11/18/Java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20201118144558967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201118150259968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="集合和数组的比较"><a href="#集合和数组的比较" class="headerlink" title="集合和数组的比较"></a>集合和数组的比较</h2><p>数组不是面向对象的，集合弥补了数组缺陷，更灵活实用。不同的集合框架适用于不同场合。具体区别如下：</p>
<ol>
<li>数组能存放基本数据类型和对象，集合类中只能存放对象</li>
<li>数组很难动态改变，集合类容易动态改变</li>
<li>数组无法判断其中实际元素个数，<code>length()</code>只告诉了数组的容量，而集合的<code>size()</code>可以</li>
<li>集合有多种实现方式、不同适用场合，数组仅采用顺序表方式</li>
<li>集合以类的形式存在，具有封装、继承、多态等特性，通过简单方法和属性即可实现各种复杂操作，大大提高了开发效率</li>
</ol>
<h2 id="Collection和Collections的区别"><a href="#Collection和Collections的区别" class="headerlink" title="Collection和Collections的区别"></a>Collection和Collections的区别</h2><ol>
<li><code>Collection</code>是Java提供的集合接口，存储一组<font color = red>不唯一、无序的</font>对象。它有两个子接口<code>List</code>和<code>Set</code>。</li>
<li>Java还有一个<code>Collections</code>类，专门用来操作集合类，它提供了一系列的<code>静态方法</code>实现对各种集合的搜索、排序、线程安全化等操作。</li>
</ol>
<h2 id="ArrayList和LinkedList的联系和区别"><a href="#ArrayList和LinkedList的联系和区别" class="headerlink" title="ArrayList和LinkedList的联系和区别"></a>ArrayList和LinkedList的联系和区别</h2><ul>
<li><p>ArrayList实现了长度可变的<code>数组</code>，在内存中分配连续空间。遍历元素和随机访问元素效率比较高。</p>
</li>
<li><p>LinkedList采用<code>链表</code>存储方式。插入、删除效率比较高。</p>
</li>
</ul>
<h2 id="Vector和ArrayList的联系和区别"><a href="#Vector和ArrayList的联系和区别" class="headerlink" title="Vector和ArrayList的联系和区别"></a>Vector和ArrayList的联系和区别</h2><ul>
<li><p>实现原理相同，功能相同，都是长度可变的数组结构，多数时候可以互用。</p>
</li>
<li><p>区别：</p>
<ol>
<li>Vector是早期的JDK接口，ArrayList是替代Vector的新接口</li>
<li>Vector线程安全，ArrayList重速度轻安全</li>
<li>长度需要增长时，Vector默认增长一倍，ArrayList增长50%（1.5+1）</li>
</ol>
</li>
</ul>
<h2 id="HashMap和Hashtable的联系和区别"><a href="#HashMap和Hashtable的联系和区别" class="headerlink" title="HashMap和Hashtable的联系和区别"></a>HashMap和Hashtable的联系和区别</h2><ul>
<li><p>实现原理相同，功能相同，底层都是哈希表结构，查询速度块，多数时候可以互用。</p>
</li>
<li><p>区别：</p>
<ol>
<li>Hashtable是早期的JDK接口，HashMap是新版的JDK提供的接口</li>
<li>Hashtable继承Dictionary类，HashMap实现Map接口</li>
<li>Hashtable线程安全，HashMap线程非安全</li>
<li>HashMap中key和value都可以为空，Hashtable不允许为空</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>Java集合框架</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机-Ubuntu16.04下添加新硬盘,分区及挂载</title>
    <url>/2020/11/13/Linux%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%A1%AC%E7%9B%98,%E5%88%86%E5%8C%BA%E5%8F%8A%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="添加新硬盘"><a href="#添加新硬盘" class="headerlink" title="添加新硬盘"></a>添加新硬盘</h3><ol>
<li>添加2G硬盘 (选择不立即添加磁盘空间)</li>
<li>重启运行虚拟机</li>
<li>输入<code>fdisk -l</code>查看当前磁盘信息<br><img src="https://img-blog.csdnimg.cn/20201113111300506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><ol>
<li><p><font color=red>用<code>fdisk /dev/sdb</code> 进行分区</font><br>进入fdisk命令，输入<code>m</code>可以看到命令的帮助<br>按<code>n</code> 进行分区</p>
</li>
<li><p>输入p即分为主分区，e即分为逻辑分区<br>我们要将这块盘分为主分区即<font color=red>输入<code>p</code></font>。</p>
</li>
<li><p>接下来输入的是该主分区为第几个主分区，由于是新盘，我们选择<font color=red>输入<code>1</code></font></p>
</li>
<li><p>定义分区大小，<code>+1024m</code>意味着分了1G的空间</p>
</li>
<li><p><font color=red>输入 <code>w</code></font>写入分区，等待结束即可</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201113202517835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol start="6">
<li>再输入<code>fdisk -l</code> 可以看到我们刚才分的一个分区<br><img src="https://img-blog.csdnimg.cn/2020111320255169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><ol>
<li><p><code>mkfs -t ext3 -c /dev/sdb1</code> 进行格式化<br><img src="https://img-blog.csdnimg.cn/2020111320261365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>在根目录下，建一个文件夹，<code>mkdir /newdisk</code>，待会将分区挂载在这个文件夹上，以后要往新硬盘存东西就存在新建文件夹下就可以了。</p>
</li>
<li><p><code>mount /dev/sdb1 /newdisk/</code> 进行挂载</p>
</li>
<li><p><code>df</code> 可以查<br><img src="https://img-blog.csdnimg.cn/20201113202639546.png#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown在VSCode中的语法</title>
    <url>/2020/08/06/MarkDown%E5%9C%A8VSCode%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<pre><code>Markdown，VSCode，Hexo博客</code></pre><h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><p>生成目录示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[第一章 网络](#第一章-网络)</span><br><span class="line">· [2019.6.1](#201961)</span><br><span class="line"></span><br><span class="line"># 第一章 网络</span><br><span class="line">xxxxxx</span><br><span class="line">## 2019.6.1</span><br><span class="line">xxxxx</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://img-blog.csdnimg.cn/20200806100005545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头1|	表头2| </span><br><span class="line">:---:|:---:|</span><br><span class="line">1|	2|</span><br><span class="line">3|	4|</span><br></pre></td></tr></table></figure>
<p><font color = #F9000>注：表格与前面的语句必须间隔一行。</font><br>效果：</p>
<table>
<thead>
<tr>
<th align="center">表头1</th>
<th align="center">表头2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
</tr>
</tbody></table>
<h3 id="上下文高亮和着色"><a href="#上下文高亮和着色" class="headerlink" title="上下文高亮和着色"></a>上下文高亮和着色</h3><p><strong>着色</strong>：(HTML5语法)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font color &#x3D; #F9000&gt; 红色 &lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color &#x3D; green&gt; 绿色 &lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure>
<p><font color = #F9000> 红色 </font><br><font color = green> 绿色 </font></p>
<p><strong>高光</strong>：<code>&lt;mark&gt;高光&lt;/mark&gt;</code><br><mark>高光</mark></p>
<h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><p><strong>效果</strong>：</p>
<hr>
<p><strong>代码</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="代码块折叠"><a href="#代码块折叠" class="headerlink" title="代码块折叠"></a>代码块折叠</h3><p><strong>源码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;details&gt;&lt;summary&gt;CLICK ME&lt;&#x2F;summary&gt;</span><br><span class="line">&lt;pre&gt;&lt;code&gt;Hello world!</span><br><span class="line">&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong><br>details：折叠语法标签<br>summary：折叠语法展示的摘要<br>pre：以原有格式显示元素内的文字是已经格式化的文本<br>code：指定代码块</p>
<p><strong>例子：</strong><br>如果将if语句包含在一个不小于5次的循环中<details><summary>结果：</summary></p>
<pre><code>Thread-1正在出售第5张票
Thread-3正在出售第5张票
Thread-3正在出售第4张票
Thread-3正在出售第3张票
Thread-3正在出售第2张票
Thread-3正在出售第1张票
</code></pre>
</details>
<br>

<p><strong>例子源码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果将if语句包含在一个不小于5次的循环中&lt;details&gt;&lt;summary&gt;结果：&lt;&#x2F;summary&gt;</span><br><span class="line">&lt;pre&gt;&lt;code&gt;Thread-1正在出售第5张票</span><br><span class="line">Thread-3正在出售第5张票</span><br><span class="line">Thread-3正在出售第4张票</span><br><span class="line">Thread-3正在出售第3张票</span><br><span class="line">Thread-3正在出售第2张票</span><br><span class="line">Thread-3正在出售第1张票</span><br><span class="line">&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</span><br><span class="line">&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure>

<h3 id="图片居中和大小设置"><a href="#图片居中和大小设置" class="headerlink" title="图片居中和大小设置"></a>图片居中和大小设置</h3><p><strong>例子：</strong><br><img src="https://img-blog.csdnimg.cn/20210124225558835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=80% height=80% align=center></p>
<p><strong>例子代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20210124225558835.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ&#x3D;&#x3D;,size_16,color_FFFFFF,t_70&quot; width&#x3D;80% height&#x3D;80% align&#x3D;center&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
        <category>VSCode</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/2021/01/31/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day08</a></p>
<h3 id="Lambda表达式介绍"><a href="#Lambda表达式介绍" class="headerlink" title="Lambda表达式介绍"></a>Lambda表达式介绍</h3><p>Lambda表达式是JAVA8中最重要的新功能之一。使用它可以代替<strong>只有一个抽象函数的接口</strong>（<font color=red>函数式接口</font>）实现，告别匿名内部类，简化代码。Lambda表达式同时还提升了对集合、框架的迭代、遍历等操作。<br><strong>特点</strong>：</p>
<ol>
<li>函数式编程</li>
<li>参数类型自动推断</li>
<li>代码量少比较简洁</li>
</ol>
<h3 id="Lambda表达式使用"><a href="#Lambda表达式使用" class="headerlink" title="Lambda表达式使用"></a>Lambda表达式使用</h3><p><code>(object...atgs)-&gt;{函数式接口抽象方法实现逻辑}</code></p>
<ol>
<li>()参数是一个的时候，括号可以省略</li>
<li>当expr逻辑非常简单时，{}和return可以省略</li>
<li>()中可以写类型也可以不写，它可以自行进行类型推断（最好带着）<blockquote>
<p>()-&gt;{return 100;}<br>()-&gt;100<br>(int x)-&gt;{return x+1;}<br>x-&gt;x+1</p>
</blockquote>
</li>
</ol>
<p><strong>告别匿名内部类，简化代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照字符串长度从小到大排序</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"java"</span>,<span class="string">"javascript"</span>,<span class="string">"scala"</span>,<span class="string">"python"</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.length() - o2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(String s:list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"---------"</span>);</span><br><span class="line">Collections.sort(list,(a,b)-&gt;a.length()-b.length());</span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h5 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h5><p>只有<font color=red>一个</font>抽象方法的接口交叫做<strong>函数式接口</strong>。<br>在接口前加上<code>@FunctionalInterface</code>注解，如果定义了两个接口会报错。e.g Runnable接口是一个函数式接口。</p>
<p><strong>常用的函数式接口</strong><br><img src="https://img-blog.csdnimg.cn/20210201121658688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在java中提供了一系列函数式接口，用来接收后续传入的逻辑，</span></span><br><span class="line"><span class="comment"> * 但是对输入输出有要求。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// Function：一个输入一个输出，一般输入输出类型不同</span></span><br><span class="line">Function&lt;String, Integer&gt; f1 = (str) -&gt; &#123;<span class="keyword">return</span> str.length();&#125;;</span><br><span class="line">System.out.println(f1.apply(<span class="string">"abcdefg"</span>));</span><br><span class="line"><span class="comment">// UnaryOperator：一个输入一个输出，类型相同</span></span><br><span class="line">UnaryOperator&lt;String&gt; uo1 = (String u) -&gt; &#123;<span class="keyword">return</span> u.concat(<span class="string">"qqq"</span>);&#125;;</span><br><span class="line">System.out.println(uo1.apply(<span class="string">"unaryOperator"</span>));</span><br><span class="line"><span class="comment">// BiFunction：两个输入一个输出，一般输入输出类型不同</span></span><br><span class="line">BiFunction&lt;Integer, String, String&gt; bf = (a, str) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a.toString()+str;&#125;;</span><br><span class="line">System.out.println(bf.apply(<span class="number">1</span>,<span class="string">"bifunction"</span>));</span><br><span class="line"><span class="comment">// BinaryOperator：两个输入一个输出，输入输出类型相同</span></span><br><span class="line">BinaryOperator&lt;String&gt; bo = (st1,st2) -&gt; &#123;<span class="keyword">return</span> st1+st2;&#125;;</span><br><span class="line">System.out.println(bo.apply(<span class="string">"Binary"</span>,<span class="string">"operator"</span>));</span><br><span class="line"><span class="comment">// Supplier：代表一个输出</span></span><br><span class="line">Supplier&lt;String&gt; s1 = ()-&gt;&#123;<span class="keyword">return</span> <span class="string">"Supplier"</span>;&#125;;</span><br><span class="line">System.out.println(s1.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer：代表一个输入</span></span><br><span class="line">Consumer&lt;String&gt; c11 = (str) -&gt; System.out.println(str);</span><br><span class="line">c11.accept(<span class="string">"Consumer"</span>);</span><br><span class="line"><span class="comment">// BiConsumer：代表两个输入</span></span><br><span class="line">BiConsumer&lt;String, Integer&gt; bc1 = (str, i) -&gt; System.out.println(str+<span class="string">","</span>+i);</span><br><span class="line">bc1.accept(<span class="string">"BiConsumer"</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://img-blog.csdnimg.cn/20210201120852457.png" alt="在这里插入图片描述"></p>
<p>在main方法外定义三个函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"find"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    find();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对方法进行基本调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不管是get()还是exec()，都是在run()中进行一个具体执行的。</span></span><br><span class="line"><span class="comment"> * 只不过返回值没有进行一个处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 如果想要打印get方法返回值</span></span><br><span class="line"><span class="comment">// Runnable runnable4 = () -&gt; &#123;</span></span><br><span class="line"><span class="comment">//   int i = get();</span></span><br><span class="line"><span class="comment">//   System.out.println(i);&#125;;</span></span><br><span class="line">Runnable runnable5 = () -&gt; get();</span><br><span class="line">Runnable runnable5 = () -&gt; exec();</span><br><span class="line"><span class="comment">// 错误，因为run()明确没有返回值</span></span><br><span class="line"><span class="comment">//  Runnable runnable6 = () -&gt; 100;</span></span><br><span class="line">runnable4.run();</span><br><span class="line">runnable5.run();</span><br></pre></td></tr></table></figure>
<p>再加一个自定义函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LambdaInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对该接口方法进行调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaInterface li1 = () -&gt; get(); <span class="comment">// 调用的是staitc int get()</span></span><br><span class="line"><span class="comment">//        LambdaInterface li2 = () -&gt; find(); // 错误，接口明确定义要返回int类型</span></span><br><span class="line">LambdaInterface li3 = () -&gt; <span class="number">100</span>;</span><br><span class="line"><span class="comment">//        LambdaInterface li4 = () -&gt; ""; // 错误</span></span><br><span class="line">LambdaInterface li5 = () -&gt; <span class="keyword">true</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(li1.get()); // 可以打印出1</span></span><br><span class="line">li1.get();</span><br></pre></td></tr></table></figure>

<h5 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h5><p>也是Lambda表达式的一种使用方式。用来直接访问最终让方法的调用变得非常简单。</p>
<p><strong>方法引用发分类</strong><br><img src="https://img-blog.csdnimg.cn/20210201140509419.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210201143539968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li><p>静态方法的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    System.out.println(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Consumer&lt;Integer&gt; c1 = Test2::getSize;</span><br><span class="line">    c1.accept(<span class="number">123</span>);</span><br><span class="line">    Consumer&lt;Integer&gt; c2 = (size) -&gt; Test2.getSize(size);</span><br><span class="line">    c1.accept(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br> 123<br> 123</p>
</li>
<li><p>实例方法的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"put.."</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Test3().put());</span><br><span class="line">    Supplier&lt;String&gt; s1 = () -&gt; <span class="keyword">new</span> Test3().put();</span><br><span class="line">    Supplier&lt;String&gt; s2 = () -&gt; &#123;<span class="keyword">return</span> <span class="keyword">new</span> Test3().put();&#125;;</span><br><span class="line">    Supplier&lt;String&gt; s3 = <span class="keyword">new</span> Test3()::put;</span><br><span class="line">    System.out.println(s1.get());</span><br><span class="line">    System.out.println(s2.get());</span><br><span class="line">    System.out.println(s3.get());</span><br><span class="line">    <span class="comment">// System.out是标准输出流，是个PrintStream类对象。即调用println()普通方法</span></span><br><span class="line"><span class="comment">//        System.out::println</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br> AAA<br> AAA<br> AAA<br> AAA</p>
</li>
<li><p>对象方法的引用（用的少）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer&lt;Too&gt; c1 = (Too too)-&gt;<span class="keyword">new</span> Too().foo();</span><br><span class="line">        c1.accept(<span class="keyword">new</span> Too());</span><br><span class="line"><span class="comment">//        Consumer&lt;Too2&gt; c2 = (Too too) -&gt; new Too2().foo(); // 报错</span></span><br><span class="line">        Consumer&lt;Too&gt; c2 = (Too too) -&gt; <span class="keyword">new</span> Too2().foo();</span><br><span class="line">        c2.accept(<span class="keyword">new</span> Too());</span><br><span class="line">        Consumer&lt;Too&gt; c3 = Too::foo;</span><br><span class="line">        c3.accept(<span class="keyword">new</span> Too());</span><br><span class="line"></span><br><span class="line">        BiConsumer&lt;Too2,String&gt; bc = (too2,str)-&gt;<span class="keyword">new</span> Too2().show(str);</span><br><span class="line">        BiConsumer&lt;Too2,String&gt; bc2 = Too2::show;</span><br><span class="line">        bc.accept(<span class="keyword">new</span> Too2(),<span class="string">"abc"</span>);</span><br><span class="line">        bc.accept(<span class="keyword">new</span> Too2(),<span class="string">"def"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Too</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">fun</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Too2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">fun</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"foo---too2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show---too2--"</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>foo<br>foo—too2<br>foo<br>show—too2–abc<br>show—too2–def</p>
</li>
<li><p>构造方法的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Account&gt; s1 = ()-&gt;<span class="keyword">new</span> Account();</span><br><span class="line">        s1.get();</span><br><span class="line">        Supplier&lt;Account&gt; s2 = Account::<span class="keyword">new</span>;</span><br><span class="line">        s2.get();</span><br><span class="line"></span><br><span class="line">        Supplier&lt;List&gt; s3 = ArrayList::<span class="keyword">new</span>;</span><br><span class="line">        Supplier&lt;Set&gt; s4 = HashSet::<span class="keyword">new</span>;</span><br><span class="line">        Supplier&lt;Thread&gt; s5 = Thread::<span class="keyword">new</span>;</span><br><span class="line">        Supplier&lt;String&gt; s6 = String::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">//        Supplier&lt;Integer&gt; s7 = Integer::new; // 错误，没有无参构造方法</span></span><br><span class="line"></span><br><span class="line">        Consumer&lt;Integer&gt; c1 = (age) -&gt; <span class="keyword">new</span> Account(age);</span><br><span class="line">        Consumer&lt;Integer&gt; c2 = Account::<span class="keyword">new</span>;</span><br><span class="line">        c1.accept(<span class="number">123</span>);</span><br><span class="line">        c2.accept(<span class="number">234</span>);</span><br><span class="line">        Function&lt;String,Account&gt; f1 = (str)-&gt;<span class="keyword">new</span> Account(str);</span><br><span class="line">        Function&lt;String,Account&gt; f2 = Account::<span class="keyword">new</span>;</span><br><span class="line">        f1.apply(<span class="string">"abc"</span>);</span><br><span class="line">        f2.apply(<span class="string">"bcd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"age 参数构造"</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"s 参数构造"</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用无参构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br>调用无参构造方法<br>调用无参构造方法<br>age 参数构造123<br>age 参数构造234<br>s 参数构造abc<br>s 参数构造bcd</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>JDK新特性</category>
      </categories>
      <tags>
        <tag>JDK新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql事务测试</title>
    <url>/2021/02/09/Mysql%E4%BA%8B%E5%8A%A1%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>登录mql命令行：<br>Cmd： mysql -uroot -p密码<br>【我的是512】</p>
</blockquote>
<p>1、<strong>打开mysql命令行，将自动提交事务给关闭</strong></p>
<blockquote>
<p>–查看是否是自动提交 1表示开启，0表示关闭<br>select @@autocommit；<br>–设置关闭<br>set autocommit = 0；</p>
</blockquote>
<p>2、<strong>环境和数据准备</strong></p>
<blockquote>
<p>–创建数据库<br>create database tran;<br>–切换数据库 两个窗口都执行<br>use tran;<br>–准备数据<br>create table psn(id int primary key,name varchar(10)) engine=innodb;<br>–插入数据<br>insert into psn values(1,’zhangsan’);<br>insert into psn values(2,’lisi’);<br>insert into psn values(3,’wangwu’);<br>commit;</p>
</blockquote>
<p>3、<strong>测试事务</strong></p>
<blockquote>
<p>–事务包含四个隔离级别：从上往下隔离级别越来越高，意味着数据月亮越安全<br>read uncommitted；–读未提交<br>read committed；–读已提交<br>repeatable read；–可重复读<br>serializable；–序列化执行，串行执行<br>–产生数据不一致的情况：<br>脏读<br>不可重复读<br>幻读</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center"></th>
<th align="center">异常情况</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交</td>
<td align="center">脏读</td>
<td align="center">不可重复读</td>
<td align="center">幻读</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center"></td>
<td align="center">不可重复读</td>
<td align="center">幻读</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">幻读</td>
</tr>
<tr>
<td align="center">序列化</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>4、测试1：<strong>脏读</strong> <font color='purple'><strong>read uncommitted</strong></font></p>
<blockquote>
<p>–两个窗口都要进行执行操作<br>–设置会话事务隔离级别为未提交读；<br>set session transaction isolation level read uncommitted;<br>start transaction; –开启事务<br><br>A:update psn set name=’’msb’;<br>A:select * from psn;<br>B:select * from psn; –此时读取的结果是msb，产生脏读。因为A事务并没有commit，读取到不存在数据<br>A:commit;<br>B:select * from psn; –此时读取的数据是msb，因为A事务已经commit，数据永久地被修改</p>
</blockquote>
<p>5、测试2：当使用<font color='purple'><strong>read committed</strong></font> 的时候，就不会出现脏读的情况了，但会出现<strong>不可重复读</strong>的问题</p>
<blockquote>
<p>set session transaction isolation level read committed;<br>A:start transaction;<br>A:select * from psn;<br>B:start transaction;<br>B:select * from psn;<br>–执行到此处的时候发现，两个窗口读取的数据是一致的<br>A:update psn set name =’zhangsan’ where id = 1;<br>A:select * from psn;<br>B:select * from psn;<br>–执行到此处发现两个窗口读取的数据不一致，B窗口中读取不到更新的数据。【不会发生脏读】<br>A:commit;<br>A:select * from psn;–读取到更新的数据<br>B:select * from psn;–也读取到更新的数据<br>–发现同一个事务中多次读取数据出现不一致的情况【发生不可重复读】</p>
</blockquote>
<p>6、测试3：当使用<font color='purple'><strong>repeatable read</strong></font>的时候(按照上面的步骤操作)，就不会出现不可重复读的问题，但是会出现<strong>幻读</strong>的问题</p>
<blockquote>
<p>set session transaction isolation level repeatable read;<br>A:start transaction;<br>A:select * from psn;<br>B:start transaction;<br>B:select * from psn;<br>–此时两个窗口读取的数据是一致的<br>A:insert into psn values(4,’sisi’);<br>A:commit;<br>A:select * from psn;–读取到添加的数据<br>B:select * from psn;–读取不到添加的数据【不会发生不可重复读】<br>B:insert into psn values(4,’sisi’);–报错，无法插入数据<br>–此时发现读取不到数据，但是在插入的时候不允许插入，出现了幻读，设置更高级别的隔离级别即可解决</p>
</blockquote>
<p><font color='red'><strong>在同一个事务里面，不管你读了多少次数据，你的数据应该是一致的。</strong></font></p>
<p><strong>脏读</strong>：A只要一进行修改，还没有commit，B中查询结果就会跟着A变化(读取到不存在的数据)</p>
<p><strong>不可重复读的问题</strong>：比如你在取钱，正在取的时候，有人给你转账（A进行了数据修改并且commit了），结果你这边马上显示钱变多了，这是不合理的。应该等你这次取钱操作结束后（也就是B当commit后），数据才会更新。</p>
<p><strong>幻读</strong>：是在插入和删除数据的时候产生的，在查询的时候不会产生。查不到，但是存在。</p>
<p><strong>总结</strong>：<br>现在学习的是数据库级别的事务，需要掌握的就是事务的<strong>隔离级别和产生的数据不一致情况</strong><br>后续学习声明式事务及事务的传播特性以及分布式事务。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>事务测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql执行计划</title>
    <url>/2021/02/20/Mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>执行计划中包含的信息<br>官网地址：<a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a></p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>select查询的序列号。<br>id越大越优先执行，id一样就按照顺序执行。</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>主要用来分辨查询类型，普通还是联合</p>
<ol>
<li><p><font color='red'><strong>SIMPE</strong></font>：简单查询，不包括子查询和union<br><code>explain select * from emp;</code><br><img src="https://img-blog.csdnimg.cn/20210222081345198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><font color='red'><strong>PRIMARY</strong></font>：查询中若包含任何子查询或者union，最外层查询被标记为primary</p>
</li>
<li><p><font color='red'><strong>UNION</strong></font>：union后面的查询语句被标记为union<br><code>explain select * from emp where deptno = 10 union select * from emp where sal &gt;2000;</code><br><img src="https://img-blog.csdnimg.cn/20210222090047473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>A,B求全集，A标记为PRIMARY，B标记为UNION。</p>
</li>
<li><p><font color='red'><strong>DEPENDENT UNION</strong></font>：此处的depentent表示union或union all联合而成的结果会受外部表影响<br><code>explain select * from emp e where e.empno  in ( select empno from emp where deptno = 10 union select empno from emp where sal &gt;2000)</code><br><img src="https://img-blog.csdnimg.cn/20210222090349465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>UNION RESULT</strong>：从union表获取结果的select<br><code>explain select * from emp where deptno = 10 union select * from emp where sal &gt;2000;</code><br><a href="https://img-blog.csdnimg.cn/20210222090623392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener">在这里插入图片描述</a></p>
</li>
<li><p><font color='red'><strong>SUBQUERY</strong></font>：在select或者where列表中包含子查询<br><code>explain select * from emp where sal &gt; (select avg(sal) from emp);</code><br><img src="https://img-blog.csdnimg.cn/20210222090722949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><font color='red'><strong>DEPENDENT SUBQUERY</strong></font>：subquery的子查询要受到外部表查询的影响。<br><code>explain select * from emp e where e.deptno in (select distinct deptno from dept);</code><br><img src="https://img-blog.csdnimg.cn/20210220171936857.png" alt="在这里插入图片描述"><br><font color='red'><strong>加了dependent和没加dependent区别</strong>：如果后面查到的是一个<strong>值</strong>的话【等值匹配，判断关系】，就是subquery；如果后面查到的是n多个值（一个<strong>结果集合</strong>的话）【依赖关系】就是dependent subquery。</font></p>
</li>
<li><p><font color='red'><strong>DERIVED</strong></font>: from子句中出现的子查询，也叫做派生类<br>所有在sql中出现的虚拟表都可以叫做“衍生表”</p>
</li>
<li><p><strong>UNCACHEABLE SUBQUERY</strong>：表示使用子查询的结果不能被缓存<br><code>explain select * from emp where empno = (select empno from emp where deptno=@@sort_buffer_size);</code><br><img src="https://img-blog.csdnimg.cn/20210222095723683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>uncacheable union</strong>:表示union的查询结果不能被缓存：sql语句未验证</p>
</li>
</ol>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><ol>
<li>如果是具体的表名(或别名)，则表明从实际的物理表中获取数据</li>
<li>表名是<code>derivedN</code>的形式，表示使用了id为N的查询产生的衍生表</li>
<li>当有<code>union result</code>的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</li>
</ol>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>显示的是访问类型。以何种方法去访问我们的数据。<br>效率从最好到最坏依次是：<br>system &gt; const &gt; eq_ref &gt; <strong>ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <strong>range</strong> &gt; index &gt; ALL</p>
<p>一般情况下，得保证查询至少达到range级别，最好能达到ref</p>
<ol>
<li>all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化</li>
<li>index：表示查询的是某一个主键列<br><code>explain select empno from emp;</code><br><img src="https://img-blog.csdnimg.cn/20210222105828182.png" alt="在这里插入图片描述"></li>
<li>range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN()<br><code>explain select * from emp where empno between 7000 and 7500;</code><br>一定要使用索引。如果是all一定没用索引。下图因为sal没用建索引，所以只能一行一行遍历。<br><a href="https://img-blog.csdnimg.cn/2021022210542255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener">在这里插入图片描述</a></li>
<li>index_subquery：利用索引来关联子查询，不再扫描全表。也必须是索引列才可以使用。<br><code>explain select * from emp where emp.job in (select job from t_job);</code><br><img src="https://img-blog.csdnimg.cn/20210222112804234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>unique_subquery:该连接类型类似与index_subquery,使用的是<strong>唯一索引</strong>。<br><code>explain select * from emp e where e.deptno in (select distinct deptno from dept);</code><br><img src="https://img-blog.csdnimg.cn/20210222113124792.png" alt="在这里插入图片描述"><br>刚刚index_subquery是给普通列建索引，而这个是给唯一列（主键列）建的索引。</li>
<li>index_merge：在查询过程中需要多个索引组合使用</li>
<li>ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式<br><img src="https://img-blog.csdnimg.cn/20210222113733792.png" alt="在这里插入图片描述"></li>
<li>ref：使用了<strong>非唯一性索引</strong>进行数据的查找<br> 先创建非唯一性索引：<code>create index idx_3 on emp(deptno);</code></li>
<li>eq_ref：使用<strong>唯一性索引</strong>进行数据查找<br>emp2和emp表一样，只是没用主键。<br><img src="https://img-blog.csdnimg.cn/2021022211393599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>const：这个表至多有一个匹配行<br><code>explain select * from emp where empno = 7369;</code><br><img src="https://img-blog.csdnimg.cn/20210222114942314.png" alt="在这里插入图片描述"></li>
<li>system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现。<blockquote>
<p>mysql中有个mysql库，这里面的表一般都是<strong>系统表</strong>。但里面的值都是多行，不是一行</p>
</blockquote>
</li>
</ol>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>查询中可能会用到的索引列，可能会用到也可能不会。<br><code>explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;</code><br><img src="https://img-blog.csdnimg.cn/20210222121416889.png" alt="在这里插入图片描述"><br>idx_3:自己创建的deptno的索引</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>​实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。<br><img src="https://img-blog.csdnimg.cn/20210222120224913.png" alt="在这里插入图片描述"></p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>可以通过key_len计算查询中使用的索引长度，推荐短的（比如name和age的，选择age字节长度短）</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>根据表的统计信息及索引使用情况，<strong>大致估算</strong>出找出所需记录需要读取的行数，此参数很重要，直接反应了sql找了多少数据，在完成目的的情况下越少越好。</p>
<h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>包含额外的信息<br><font color='red'><strong>using filesort</strong></font>: 说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置<br><img src="https://img-blog.csdnimg.cn/20210222222110856.png" alt="在这里插入图片描述"></p>
<p><strong>using temporary</strong>:建立临时表来保存中间结果，查询完成之后把临时表删除<br>using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找<br><img src="https://img-blog.csdnimg.cn/20210222222550713.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql执行计划</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql主从复制原理</title>
    <url>/2021/03/02/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong>为什么要主从复制？</strong></p>
<ol>
<li>有一句sql语句当锁表的时候不能读，这会影响运行中的业务。使用主从复制，让主库负责写，从库负责读，这样即使出现锁表，也可以通过从库读。</li>
<li>做数据的热备。</li>
<li>架构的扩展。可以降低磁盘IO访问的频率，提高单个机器的IO性能。</li>
</ol>
<p><strong>什么是mysql的主从复制？</strong><br>指数据可以从一个mysql数据库服务器主节点复制到一个或多个从节点。mysql默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有或者特定的数据库，或者特定的表。</p>
<p><strong>mysql复制原理</strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20210302090631645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20210302090631645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV</a><br>0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70)ui、</p>
<ol>
<li>master服务器将数据的改变记录到二进制binlog日志中</li>
<li>slave服务器会定期对binlog进行检测是否发生改变。如果发生改变，则开启一个IO Thread拉取master的<strong>binlog</strong>中的内容到<strong>relay log</strong>中，sql线程负责从relay log中读出内容，并更新到slave的数据库中。保证slave和mater数据一致。</li>
<li>mysql复制至少需要2个mysql的服务</li>
<li>mysql的复制确保版本：master&lt;=slave服务器</li>
<li>master和slave两节点时间需要同步</li>
</ol>
<p>mysql主从形式</p>
<ol>
<li>一主一从 一台master，一台slave<br><img src="https://img-blog.csdnimg.cn/2021030209180463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>主主复制 互为备份<br><img src="https://img-blog.csdnimg.cn/20210302091909458.png" alt="在这里插入图片描述"></li>
<li>一主多从 一般用于读写分离。主写，从读，分担读取压力<br><img src="https://img-blog.csdnimg.cn/20210302092050656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>多主一从 用来做数据备份，应用较少<br><img src="https://img-blog.csdnimg.cn/20210302091821779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>联级复制 浪费时间；依赖太强，应用较少<br><img src="https://img-blog.csdnimg.cn/20210302091839854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p><strong>mysql主从同步延迟分析</strong><br><strong>在mysql5.7以前</strong>：<br>由于mysql的主从复制是单线程操作，主库对所有DDL和DML产生的日志写入binlog，由于binlog是顺序写，效率很高，slave的sql线程将DDL和DML操作事件重新生成，而DML和DDL的IO操作是随机的，效率低。另一方面，由于sql thread也是单线程的，当主库并发较高时，<font color='purple'><strong>产生的DML和DDL数量超过slave的SQL Thread所能处理的速度</strong>，或者<strong>当slave中有大型query语句产生了锁等待</strong>，那么延迟就会产生了</font>。<br><font color='red'><strong>解决方案</strong>：</font></p>
<ol>
<li>业务的持久化层的实现采用<strong>分库架构</strong>，mysql服务可以平行扩展，分散压力</li>
<li><strong>单个库读写分离</strong>，一主多从，主写读从，分散压力。让从库压力高于主库压力，保护主库</li>
<li>服务的基础架构在业务和mysql之间加入memcache或者redis的cache层，<strong>降低mysql的读压力</strong></li>
<li>不同业务的mysql<strong>物理上放在不同机器</strong>，分散压力</li>
<li>使用比主库更好的<strong>硬件设备</strong>作为slave，mysql压力小，延迟自然小</li>
<li>使用更加强劲的<strong>硬件设备</strong></li>
</ol>
<p><strong>在mysql5.7以后</strong>：<br>使用MTS并行复制技术，永久解决复制延迟问题。<br><strong>MTS（enhanced multi-threaded slave），增强型多线程从机</strong><br>master服务器上是怎么并行执行的，那么slave上就怎样进行并行回放</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql基本架构</title>
    <url>/2021/02/18/Mysql%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Mysql基本架构图"><a href="#Mysql基本架构图" class="headerlink" title="Mysql基本架构图"></a>Mysql基本架构图</h2><p><img src="https://img-blog.csdnimg.cn/2021021822554779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li><p><strong>连接器</strong>：连接器负责跟客户端建立连接，获取权限、维持和管理连接。<br>▪ 可以使用<code>show processlist</code>查看现在的连接。<br>▪ 如果太长时间没有动静，就会自动断开，通过wait_timeout控制，默认8小时<br>▪ 连接可以分为：长连接和短连接。<strong>推荐使用长连接</strong>，可以提高性能。但是要周期性断开长连接，因为数量过多会占用过多资源。<strong>数据库连接池</strong>就属于长连接。</p>
</li>
<li><p><strong>分析器</strong>：词法分析：mysql把字符串识别成表名和列名；语法分析：根据语法规则判断是否合法。</p>
</li>
<li><p><strong>查询缓存</strong>：之前查过的数据，会在这里进行一次缓存，如果之后还有一些相同的查询时，会直接从这里拿。平时写不常用是因为，一，这里面缓存失效比较频繁，也就是说，一旦数据库一旦发生改变，它就不能用了，缓存就会被清空。二，缓存对应新更新的数据命中率比较低。<font color='red'><strong>所以一般不用</strong></font>。mysql8.0后，取消了。</p>
</li>
<li><p><strong>优化器</strong>：一般情况下，优化策略分为两个层面，一个叫<font color='red'><strong>RBO</strong></font>，基于规则的优化；一个叫<font color='red'><strong>CBO</strong></font>，基于成本的优化。现在更注重CBO，因为现在更多注重的是性能和效率。优化器是不可以省略的。这里是mysql自动帮我们优化，我们只需要写sql语句时，尽量让它能够走对应的优化策略，这也是我们查询执行计划的原因。这步之后，就形成详细的执行步骤。<br>包括，表中有多个索引的时候，决定用哪个索引；当sql语句需要做多表关联的时候，决定表的连接顺序等。</p>
</li>
<li><p><strong>执行器</strong>:直接执行。</p>
</li>
</ol>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><pre><code>不管哪种日志其实就是一块内存区域</code></pre><p>事务实现ACID的底层实现机制是和日志挂钩的。<br><strong>原子性</strong>是undolog保证的  undolog记录了数据操作前数据状态<br><strong>持久化</strong>是redolog保证的  redolog记录更新之后数据状态<br><strong>隔离性</strong>通过锁机制</p>
<h3 id="Redo日志（前滚日志）——innodb存储引擎的日志文件"><a href="#Redo日志（前滚日志）——innodb存储引擎的日志文件" class="headerlink" title="Redo日志（前滚日志）——innodb存储引擎的日志文件"></a>Redo日志（前滚日志）——innodb存储引擎的日志文件</h3><pre><code>保证了持久性</code></pre><p><strong>WAL（write ahead log，预写日志）</strong>为了提高性能的。如果每次修改数据都要写入磁盘，意味着要不停打开IO流。所以打算先写到内存中，合适时间再同步到磁盘中。但这时间段内如果断电不就东西消失了吗？所以维护的方式就是：每次先写到缓存空间里面，为了防止数据丢失问题，出现了redolog。<br>▪ <font color='purple'>当数据发生修改的时候，innodb会先将记录写到redo log（有对应的内存空间），并更新内存，同时innodb会在合适时机将记录同步到磁盘。</font><br>▪ 有了redolog，innodb就可以保证即使数据库发生<strong>异常重启</strong>，之前的记录也不会消失，叫做<font color='red'><strong>crash-safe</strong></font>。<br>▪ 只要redolog完整，就能保证数据不丢失<br>▪ Redolog是固定大小的，是循环写的过程<br>每次<code>write pos</code>后面到<code>checkpoint</code>前面，这一块是可以写数据的。因为它们之间的部分还等待着<code>checkpoint</code>进行更新`。</p>
<p><img src="https://img-blog.csdnimg.cn/20210220094120428.png" alt="在这里插入图片描述"></p>
<p>既然要避免io，为什么写redo log的时候不会造成io的问题？<br><img src="https://img-blog.csdnimg.cn/20210220092441933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210220092356723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意，虽然第1，3种也有不安全的地方，但是性能是比较高的，因为它们是批量操作。而第二种虽然最安全但是是单条操作。</p>
<blockquote>
<p>类比案例 小卖铺每天买卖交易，每次从记账本中翻找很麻烦，于是每天在门口挂一个小黑板，记录今日交易，晚上统一誊写到记账本上。而小黑板大小有限，所以改变一下，一段时间就把黑板内容誊写到记账本上，然后擦除黑板内容，这就是redolog循环写的机制。</p>
</blockquote>
<h3 id="Undo-log（回滚日志）——innodb存储引擎的日志文件"><a href="#Undo-log（回滚日志）——innodb存储引擎的日志文件" class="headerlink" title="Undo log（回滚日志）——innodb存储引擎的日志文件"></a>Undo log（回滚日志）——innodb存储引擎的日志文件</h3><pre><code>为了实现事务的原子性</code></pre><p>在进行操作数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log），然后进行数据修改，如果要回滚，就可以利用备份数据恢复。<br>undo log其实是逻辑日志：</p>
<ul>
<li>当delete一条记录时，undo log中会记录一条对应的insert记录</li>
<li>当update一条记录时，它记录一条对应相反的update记录</li>
</ul>
<h3 id="Binlog日志——服务端的日志文件"><a href="#Binlog日志——服务端的日志文件" class="headerlink" title="Binlog日志——服务端的日志文件"></a>Binlog日志——服务端的日志文件</h3><pre><code>无关存储引擎，任何存储引擎都可以使用</code></pre><p>▪ Binlog是server层的日志，主要做的是做mysql功能层面的事情。<br>▪ 默认情况下mysql下binlog没开启。<code>show variables like &#39;%log_%&#39;</code>可以查找到一个log_bin选项，看是否开启。<br>▪ <font color='purple'><strong>与redo日志的区别</strong></font>:</p>
<ol>
<li>redo是innodb独有，binlog任何存储引擎都可以使用</li>
<li>redo是物理日志，记录的是在某个数据页上做了什么修改，binlog是逻辑日志，<strong>记录的是这个语句的原始逻辑</strong></li>
<li>redo是循环写的，空间会用完，binlog是可以<strong>追加写</strong>的，不会覆盖之前的日志信息</li>
</ol>
<p>▪ 一般企业数据库有备份系统，可以定期备份。恢复时，先找到最近一次的全量备份数据，然后从备份的时间点开始将备份的binlog取出来，重放到要恢复的那个时刻。</p>
<h4 id="数据更新的流程"><a href="#数据更新的流程" class="headerlink" title="数据更新的流程"></a>数据更新的流程</h4><p><img src="https://img-blog.csdnimg.cn/20210220111026819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>执行器先从引擎中查找数据，如果在内存中直接返回，如果没有再到磁盘中读取数据并返回</li>
<li>执行器更改数据，然后调用引擎接口重新吸入数据</li>
<li>引擎将数据更新到内存，同时写入redo中。并通知执行器执行生成</li>
<li>执行器生成这个事务的binlog</li>
<li>执行器调用引擎接口，引擎把刚写完的redo提交，更新完成。</li>
</ol>
<h4 id="Redo-log的两阶段提交"><a href="#Redo-log的两阶段提交" class="headerlink" title="Redo log的两阶段提交"></a>Redo log的两阶段提交</h4><p><mark>为了保证redolog和binlog的数据一致性</mark><br>▪ <font color='red'>先写redo log后写binlog</font>：假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。因为redolog后，系统即使崩溃也能把数据恢复回来，而binlog还没来得及写完，如果需要用这个binlog来恢复临时库，该临时库就会少了这一次更新，与原来库不同，所以不能先写。<br>▪ <font color='red'>先写binlog后写redo log</font>：由于redolog还没写完，恢复后这个事务也无效。而binlog写完了，所以之后用它恢复临时库的时候就多了一个事务，所以也不行。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql基本架构</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引</title>
    <url>/2021/02/17/Mysql%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>《DDL建表操作和相关约束》中有部分索引内容。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>时间局部性<br>空间局部性</p>
<h3 id="磁盘预读"><a href="#磁盘预读" class="headerlink" title="磁盘预读"></a>磁盘预读</h3><ul>
<li><p>减少I/O：一个是减少访问的次数，一个是减少IO的量。</p>
</li>
<li><p>一般<strong>顺序读写</strong>，随机读写效率非常低。</p>
</li>
<li><p>每次读一个小单元（页通常为4k）<br>预读的长度一般为页（page）的整数倍</p>
</li>
<li><p>索引放到<font color="red"><strong>磁盘（文件系统）</strong></font>中的</p>
</li>
<li><p>索引是帮助 MySQL 高效获取数据的数据结构</p>
</li>
<li><p>索引的文件存储形式与<strong>存储引擎</strong>有关<br><img src="https://img-blog.csdnimg.cn/20210217143542424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注</strong>：不同的存储引擎，数据文件和索引文件存放的位置是不同的。因此有了分类：</p>
<ol>
<li><p><font color="red"><strong>聚簇索引</strong></font>：数据和文件放在一起：innodb<br>▪ <code>create table tid(id int) engine=innodb</code> 默认innodb<br>▪ <code>.frm</code>：存放的是表结构<br>▪ <code>.ibd</code>：存放数据文件和索引文件<br>▪ mysql的innodb存储引擎默认情况下会把<strong>所有的数据文件</strong>放到表空间中（D:\mysql-5.7.26-winx64\data\ibdata1），不会为每个单独的表保存一份数据文件，如果需要将每一个表单独使用文件保存，设置如下属性：<code>set global innodb_file_par_table=on;</code></p>
<blockquote>
<p>表空间，类似高中教师后面的柜子，每个学生有一个小格子。</p>
</blockquote>
</li>
<li><p><font color="red"><strong>非聚簇索引</strong></font>：数据和索引单独一个文件：MyISAM<br> ▪ <code>.frm</code>：存放的是表结构<br> ▪ <code>.MYI</code>：存放索引数据<br> ▪ <code>.MYD</code>：存放实际数据</p>
</li>
</ol>
</li>
<li><p>索引文件的结构<br>– hash<br>– 二叉树<br>– B树<br>– B+树</p>
</li>
</ul>
<h4 id="哈希表：哈希冲突"><a href="#哈希表：哈希冲突" class="headerlink" title="哈希表：哈希冲突"></a>哈希表：哈希冲突</h4><ul>
<li>key对应过来就是列名的值。value可能表示一整行数据。</li>
<li>哈希表可以完成<font color="orange"><strong>索引的存储</strong></font>。每次在添加索引的时候，需要计算指定列的哈希值，取模运算后计算出下标，将元素插入下标位置即可。</li>
<li><strong>适合场景</strong>：<br>等值查询<br>表中的数据是<font color="red"><strong>无序数据</strong></font>（范围查找的时候比较浪费时间，需要遍历操作）</li>
</ul>
<h6 id="不合适的理由"><a href="#不合适的理由" class="headerlink" title="不合适的理由:"></a>不合适的理由:</h6><ol>
<li>在企业中多数的查询时范围查询还是等值查询？<br><strong>范围查询</strong>。所以hashb表<strong>不是特别合适</strong>。</li>
<li>哈希表使用时，需要将全部数据加载到内存，比较耗费内存的空间，也不是很合适。</li>
</ol>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>在树的结构中，左子树必须小于根节点，右子树必须大于根节点。如果是多叉树，从左到右是有序的。<br><img src="https://img-blog.csdnimg.cn/20210218141302115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color="red"><strong>注：</strong>二叉树及其变种都<strong>不能支持索引</strong>，因为<strong>树的深度无法控制</strong>或者<strong>插入数据的性能比较低</strong>。</font></p>
<h5 id="B树（B-树）"><a href="#B树（B-树）" class="headerlink" title="B树（B-树）"></a>B树（B-树）</h5><pre><code>本质是多叉树 </code></pre><p><strong>一、B树特点</strong></p>
<blockquote>
<p><strong>键值（key）</strong>，即表中记录的主键，列的值放到这个地方<br><strong>指针</strong>，存储子节点地址信息<br><strong>数据（data）</strong>，即表记录中除主键外的数据，一整行的数据文件</p>
</blockquote>
<ol>
<li><strong>所有键值分布在整棵树中</strong></li>
<li><strong>搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找</strong></li>
<li><strong>m阶的B树每个节点最多拥有m个子树</strong></li>
<li>根节点至少有2个子树</li>
<li>分支节点（除根节点和叶子节点）至少拥有m/2棵子树</li>
<li>叶子节点在同一层，每个节点最多可以有m-1个key</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210218144123517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>从磁盘读取的4k整数倍空间，反映到图上一个节点就是一个4k磁盘块。</li>
<li>假如读28，先读入1个4k空间（磁盘块1），发现是在16和34之间，于是再读入一个4k空间（磁盘块3），发现是在25和31之间，于是再读入一个4k空间（磁盘块8），有28，里面正好有数据，读出。所以一个读了3次，12k数据。这个过程是非常快的。</li>
<li><strong>存在问题</strong>：每个磁盘块只有4k，同时还包括了一整行的数据文件，而这个数据文件大小是没法预估的，假如这个数据文件大小是1KB，键值和指针忽略不计，那么一个磁盘块只能存4条数据。一个3层的B树，最多只能存64条数据。所以如果数据多，那么<font color="orange"><strong>树的深度就会过大</strong></font>，<strong>IO次数和IO的量过多</strong></li>
</ol>
<p><strong>二、能存索引，缺点</strong></p>
<ol>
<li>每个节点都有key，同时也包含data，而每个页存储空间是有限的，如果data比较大的话，会导致每个节点存储的<font color="orange"><strong>key数量变小</strong></font>，那么区间越不明确，查询深度越高。</li>
<li>当存储的数量很大的时候，会导致<strong>深度较大</strong>，增大查询时磁盘I/O次数，对查询性能产生影响。</li>
</ol>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>B+ Tree是B Tree的优化。<br><strong>一、B+树特点</strong></p>
<ol>
<li>B+树每个节点可以包含更多的节点，这个做的原因有两个，第一个是为了降低树的高度，第二个是将数据范围变为多个区间，区间越多，检索越来越快</li>
<li>叶子节点放数据和key，非叶子节点放指针和key</li>
<li>叶子节点两两指针相互连接（符合磁盘预读），顺序查询性能更高</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210218151548334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>假如读28，还是12k数据空间，3次读取，好处是存储数据量变多。假设一个p1和28占10个字节，那一个磁盘块（4k=4096字节）看成4000字节，就能放400条数据。三层结构就能放400<em>400</em>4=64万条记录。（一般情况下，三层结构百万级别数据肯定没有问题）</li>
<li>如果是范围查询，</li>
<li>在B+树有两个头指针。一个指向根节点，一个指向关键字最小的叶子节点。而且所有叶子节点之间是一种链式环结构，因此可以对B+树进行两种查找运算：满足对于主键的<strong>范围查找和分页查找</strong>，也满足从根节点开始的<strong>随机查找</strong>。</li>
</ol>
<p><strong>二、优点</strong></p>
<ol>
<li>满足范围查找，也可以满足顺序查找。</li>
<li>支持比较大的数据量。</li>
</ol>
<p><font color="orange">问题：如果存了1万条记录，然后进行了一次更新（比如加一条记录），更新完了之后怎么办？索引需要变吗？</font></p>
<h5 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a><strong>索引的创建</strong></h5><p>&emsp;1、自动：当在表上定义一个PRIMARY KEY 或者UNIQUE 约束条件时,Oracle数据库自动创建一个对应的唯一索引<br>&emsp;2、手动：用户可以创建索引以加速查询<br>在每次读取的时候，一旦用了索引，相当于做了两件事：先去遍历索引文件，再去遍历数据文件（和<strong>存储引擎</strong>有关）。所以数据量很小，没必要建索引。</p>
<blockquote>
<p>建议把主键设置为自增的，并且主键列是一个索引列。这关系到索引的维护。</p>
</blockquote>
<h4 id="mysql-innodb—B-Tree，叶子节点直接放置数据"><a href="#mysql-innodb—B-Tree，叶子节点直接放置数据" class="headerlink" title="mysql innodb—B+Tree，叶子节点直接放置数据"></a>mysql innodb—B+Tree，叶子节点直接放置数据</h4><pre><code>存储引擎是innodb时，索引和数据文件放在一起的</code></pre><p><img src="https://img-blog.csdnimg.cn/2021021815550536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一、如果对主键创建索引（id）。根据索引找到位置，直接返回数据。<br>二、如果我们给name创建索引，上图（A索引）改变，图中key就不再是主键<code>1~6</code>那些数字了，而是变成了<code>teacher.lu……</code>，叶子节点存放数据不再是整条记录。而是变成了主键id<code>1~6</code>。所以需要两次，第一次找<strong>普通列的B+树</strong>，找到id后，再到上图A索引中<strong>查找主键列的B+树</strong>，然后取出数据。这个过程就称为<font color="orange"><strong>回表</strong></font><br><font color="purple"><strong>回表操作一般针对于innodb。</strong></font></p>
<h4 id="mysql-MyISAM—B-Tree"><a href="#mysql-MyISAM—B-Tree" class="headerlink" title="mysql MyISAM—B+Tree"></a>mysql MyISAM—B+Tree</h4><pre><code>存储引擎是MyISAM时，索引和数据文件分开放</code></pre><p>和innodb区别是：<br>最后叶子节点上存放的不是整行记录了，而是地址值。<br><img src="https://img-blog.csdnimg.cn/20210218161623126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>▪ mysql索引的五种类型：主键索引、唯一索引、普通索引和全文索引、组合索引。<br>▪ 通过给字段添加索引可以提高数据的<strong>读取速度</strong>，提高项目的并发能力和抗压能力。</p>
<blockquote>
<p><strong>自增id怎么维护？</strong><br><font color="orange"><strong>自增锁</strong></font>来维护自增性，保证id不会乱。</p>
</blockquote>
<p><strong>一、主键索引</strong><br>主键是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键。<br>    主键不是一个列，最好生成<strong>自增</strong>。因为<font color="orange"><strong>页分裂</strong></font>和<font color="orange"><strong>页合并</strong></font>都是很浪费性能的。</p>
<blockquote>
<p>当定位到叶子节点时候，有n多个磁盘页。现在要往里面插入数据：<br>如果是自增，那么每次插入的就是一个较大值，直接在后面插入即可，几乎没有成本。<br>而如果不是自增的话，假设要插入的磁盘块已经满了，就需要申请一个新的空间，然后把原来磁盘块上的数据分成两份（页分裂），如果之后不再插入数据到那个块，空间就浪费了。如果之后删除了数据，那么就又会涉及到页合并。<br>都涉及到IO，有性能损耗。而且浪费了空间。<br>【索引维护时候的情况分类】</p>
</blockquote>
<p><strong>二、唯一索引</strong><br>索引列的所有值都只能出现一次，即必须唯一，值可以为空。</p>
<p>如果确定了是唯一约束的话，就是系统自动帮我们建索引；<br><font color="orange">但如果一个列name数据库层面没有给定约束（unique），但是代码层面就限定好了是唯一的，那此时给这个列建索引的时候，我们是建成唯一索引还是普通索引？</font><br>性能方面有差别，需要考虑。普通索引需要回表。</p>
<p><strong>三、普通索引 覆盖索引</strong><br>基本的索引类型，值可以为空，没有唯一性的限制。（<font color="red"><strong>覆盖索引</strong></font>，是回表中最基本的一个优化点）</p>
<blockquote>
<p>当采取这种索引的时候，有可能会产生覆盖索引。有可能的话，<font color="red">尽量使用覆盖索引</font>。<br><img src="https://img-blog.csdnimg.cn/20210218165457315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 本来查询的时候必须要进行回表，遍历两次b+树，但是由于查的是id，可以把这个过程简化为1次。这就叫覆盖索引。使用有局限性。必须要查询对应的主键的时候才能使用。</p>
</blockquote>
<p><strong>四、全文索引</strong><br>    全文索引就是检索对应关键字。MyISAM支持，Innodb在5.6之后支持。但一般不用，因为全文检索有专门工具，es，solr等。<br>全文索引的索引类型为FULLTEXT。全文索引可以在varchar、char、text类型的列上创建<br>    搜索引擎 倒排索引 </p>
<p><strong>五、组合索引</strong><br>    多列值组成一个索引，专门用于组合搜索<br>如果查询时候总是那几个列的话，可以把一些列组合到一起，创建索引。创建规则：<font color="orange"><strong>最左匹配原则</strong></font>。<br>比如 id name age address  ，要给name和age创建索引，首先要确定是哪个在前。如果是name在前，那意味着匹配的时候必须要先匹配name，name有了值后再去匹配age。</p>
<p><font color="orange">如果有一类查询是查name和age，有一类查询只查age。那么现在除了给name和age创建联合索引（name放前面），要不要给age单独创建索引？需要。因为最左匹配原则，如果没有name，age根本查不了。但如果把age放到前面，就不需要再维护一套索引。</font><br>尽量减少索引创建，因为索引是磁盘存储的，索引越多，维护越麻烦。这些都需要衡量。</p>
<p><font color="orange"><strong>索引下推</strong></font><br>在回表之前，就做了一次判断筛选，这样能提高执行的效率。<br>比如下面搜索语句，name和age建立组合索引，本来没有索引下推时，根据<code>name=zhangsan</code>回表会返回这四条记录，有了索引下推，提前判断<code>age是否为10</code>，回表只返回1和4。<br><img src="https://img-blog.csdnimg.cn/20210218222823282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Mysql存储引擎"><a href="#Mysql存储引擎" class="headerlink" title="Mysql存储引擎"></a>Mysql存储引擎</h3><p>memory虽然快，性能高，但是一旦断电就会出现数据丢失，持久化存在问题。<br><img src="https://img-blog.csdnimg.cn/20210218223557842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Mysql默认innodb，如果想换可以从<code>my.ini</code>中修改</p>
<h2 id="索引面试题"><a href="#索引面试题" class="headerlink" title="索引面试题"></a>索引面试题</h2><p>▪ 为什么加索引能优化慢查询？<br>▪ 你知道哪些数据结构可以提高查询速度？<br>▪ 那这些数据结构既然都能优化查询速度，Mysql为何选择使用B+<br>树？</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql锁机制</title>
    <url>/2021/02/23/Mysql%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="锁的基本介绍"><a href="#锁的基本介绍" class="headerlink" title="锁的基本介绍"></a>锁的基本介绍</h3><p>MySQL的锁机制比较简单，其最 显著的特点是<strong>不同的存储引擎支持不同的锁机制</strong>。<br>MyISAM采用的是表级锁；InnoDB存储引擎支持行级锁也支持表级锁。默认行级锁。<br><strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。​<br><strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br><strong>表级锁</strong>更适合于以<strong>查询</strong>为主；而<strong>行级锁</strong>则更适合于操作语句。</p>
<h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h3><p>mysql的表级锁有两种模式：<strong>表共享读锁</strong>（Table Read Lock）和<strong>表独占写锁</strong>（Table Write Lock）</p>
<p><font color='red'><strong>对MyISAM表的读操作</strong></font>，<strong>不会阻塞</strong>其他用户对同一表的<strong>读</strong>请求，但会<strong>阻塞</strong>对同一表的<strong>写</strong>请求。<br><font color='red'><strong>对MyISAM表的写操作</strong></font>，则会<strong>阻塞</strong>其他用户对同一表的<strong>读和写</strong>操作。<br>MyISAM表的读操作与写操作之间，写操作之间是<strong>串行</strong>的。</p>
<p><strong>MyISAM写锁阻塞读的案例</strong>：<br>​当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。<br><strong>MyISAM读阻塞写的案例</strong>：<br>​ 一个session使用lock table给表加读锁，这个session可以锁定表中的记录，但更新和访问其他表都会提示错误，同时，另一个session可以查询表中的记录，但更新就会出现锁等待。<br>【读写互斥，写写互斥】<br><strong>注</strong>：<br>MyISAM在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显式加锁。</p>
<h3 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h3><pre><code>支持事务</code></pre><p>默认加行锁。</p>
<h4 id="事务及其ACID属性"><a href="#事务及其ACID属性" class="headerlink" title="事务及其ACID属性"></a>事务及其ACID属性</h4><p>事务是由一组sql语句组成的逻辑处理单元。事务具有ACID属性。<br>原子性actomicity：事务是一个原子操作单元；<br>一致性consistent：在事务开始和完成时态持一致；undo log<br>隔离性isolation：保证事务不受外部并发影响；<br>持久性durable：对数据的修改是永久性的。   redo log</p>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><p>脏读：一个事务还没有提交，这条记录就能被另一个事务读取到。<br>不可重复读：一个事务还没有提交时这条记录不能被另一个事务读取到。但是，提交之后，另一个事务也能读到更新的记录。<br>幻读：在插入和删除数据时候产生的，一个事务占用了序列号导致另一个事务无法完成插入删除。</p>
<p>read uncommitted：脏读，不可重复读，幻读<br>read committed：不可重复读，幻读<br>repeatable read：幻读<br>serializable</p>
<p>可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#39;innodb_row_lock%&#39;;</span><br><span class="line">--如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高</span><br></pre></td></tr></table></figure>

<h4 id="InnoDB的行锁模式及加锁方法"><a href="#InnoDB的行锁模式及加锁方法" class="headerlink" title="InnoDB的行锁模式及加锁方法"></a>InnoDB的行锁模式及加锁方法</h4><p>共享锁（s）：又称读锁。<br>排他锁（x）：又称写锁。如果用了排他锁，当前线程可以对他进行增删改查操作，但是其他线程既不能获得我们的读锁，同时也不能获得我们的写锁。</p>
<p>mysql innodb 引擎默认的修改语句：</p>
<ol>
<li>update，delete，insert会自动给涉及到的数据加<strong>排他锁</strong></li>
<li>select默认不会加锁<br>如果要加<strong>排他锁</strong>：<code>select...for update</code><br>如果加<strong>共享锁</strong>：<code>select...lock in share mode</code></li>
<li>所以加过排他锁的数据行在其他事务中是不可能修改数据的，也不能通过<code>for update</code>和<code>lock in share mode</code>方式查询数据，但可以直接通过<code>select from</code>查询数据。</li>
</ol>
<h5 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h5><p>innodb行锁是通过索引上的索引项加锁实现的。与mysql和oracle不同，后者是是通过数据块中对应数据行加锁实现的。<br>所以只有通过索引条件检索数据时，innodb才能使用行级锁，否则只能使用表锁！<br>1、在不通过索引条件查询的时候，innodb使用的是表锁而不是行锁<br>2、创建带索引的表进行条件查询，innodb使用的是行锁<br>3、由于mysql的行锁是针对索引加的锁，不是针对记录加的锁，所以一个索引值对应多条记录的时候，虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现冲突的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于MyISAM的表锁：</p>
<ol>
<li>每次锁的是表，读和写是串行的</li>
<li>在一定条件下，MyISAM允许查询和插入并发执行。可以利用这点解决应用中对同一表查询和插入的<strong>锁争用问题</strong></li>
<li>MyISAM默认的锁调度机制是<strong>写优先</strong></li>
<li>表锁的粒度大，读写间又是串行，可能会出现严重锁等待。可以采用InnoDB表来<strong>减少锁冲突</strong></li>
</ol>
<p>对于InnoDB锁，用户可以通过设计和SQL调整等措施减少锁冲突和死锁。</p>
<ol>
<li>尽量使用较低的隔离级别；尽量使用索引访问访问数据</li>
<li>小事务发生锁冲突概率小</li>
<li>给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁</li>
<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</li>
<li>除非必须，查询时不要显示加锁</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql锁机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql读写分离</title>
    <url>/2021/03/04/Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<h3 id="一、-读写分离介绍"><a href="#一、-读写分离介绍" class="headerlink" title="一、 读写分离介绍"></a>一、 读写分离介绍</h3><p><img src="https://img-blog.csdnimg.cn/20210305151145583.png" alt="在这里插入图片描述"><br>MySQL读写分离基本原理是proxy自动进行一个请求的分发。让master数据库处理写操作，slave数据库处理读操作。<br><strong>Mysql读写分离能提高系统性能的原因在于</strong>：</p>
<ol>
<li>物理服务器增加，机器处理能力提升，拿硬件换性能</li>
<li>主从只负责各自的读和写，极大缓解了排他锁和共享锁争用</li>
</ol>
<h3 id="二、读写分离相关配置"><a href="#二、读写分离相关配置" class="headerlink" title="二、读写分离相关配置"></a>二、读写分离相关配置</h3><pre><code>mysql proxy方式</code></pre><p><strong>硬件配置</strong></p>
<blockquote>
<p>master 192.168.12.111   node01<br>slave  192.168.12.112    node02<br>proxy  192，168.12.113   node03</p>
</blockquote>
<p><strong>在master和slave上配置主从复制</strong></p>
<p><strong>进行proxy的相关配置</strong></p>
<ol>
<li>解压安装包并修改目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf mysql-proxy-0.8.5-linux-glibc2.3-x86-64bit.tar.gz</span><br><span class="line">mv mysql-proxy-0.8.5-linux-glibc2.3-x86-64bit mysql-proxy</span><br></pre></td></tr></table></figure></li>
<li>进入mysql-proxy的目录，创建目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd mysql-proxy</span><br><span class="line">#6、创建目录</span><br><span class="line">mkdir conf</span><br><span class="line">mkdir logs</span><br></pre></td></tr></table></figure></li>
<li>添加环境变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打开&#x2F;etc&#x2F;profile文件</span><br><span class="line">vi &#x2F;etc&#x2F;profile</span><br><span class="line">#在文件的最后面添加一下命令</span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;root&#x2F;mysql-proxy&#x2F;bin</span><br><span class="line">#退出后执行命令让环境变量生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure></li>
<li>进入conf目录，创建文件并添加一下内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd conf&#x2F;</span><br><span class="line">vi mysql-proxy.conf</span><br><span class="line">添加内容</span><br><span class="line">[mysql-proxy]</span><br><span class="line">user&#x3D;root</span><br><span class="line">proxy-address&#x3D;192.168.12.113:4040</span><br><span class="line">proxy-backend-addresses&#x3D;192.168.12.111:3306</span><br><span class="line">proxy-read-only-backend-addresses&#x3D;192.168.12.112:3306</span><br><span class="line">proxy-lua-script&#x3D;&#x2F;root&#x2F;mysql-proxy&#x2F;share&#x2F;doc&#x2F;mysql-proxy&#x2F;rw-splitting.lua</span><br><span class="line">log-file&#x3D;&#x2F;root&#x2F;mysql-proxy&#x2F;logs&#x2F;mysql-proxy.log</span><br><span class="line">log-level&#x3D;debug</span><br><span class="line">daemon&#x3D;true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上面配置项只指定了node01既承担读也承担写，112只承担读。所以：<br>msb数据库node01和node02中，node03中没有。node01中psn表里面有数据1，node02中有数据1和2。<br>如果在navicat中，连接node03，会显示有msb。在msb中查询psn表，会查询到1。也就是说读数据的时候读进来了node01。<br>在node01中<code>service mysqld stop</code>停掉服务，再次在navicat中查询会卡死失败。这时候再次开启node01中mysqld服务，然后查询，会查询到1和2，也就是查的是从库node02。<br>如果插入数据再查询，会发现写的时候是往mode01写的，而读是读的node02。如果现在要读node01，需要把node02关闭服务，再重启重读。<br><strong>麻烦，很少用。</strong></p>
<h3 id="使用amoeba实现mysql读写分离"><a href="#使用amoeba实现mysql读写分离" class="headerlink" title="使用amoeba实现mysql读写分离"></a>使用amoeba实现mysql读写分离</h3><p>amoeba（变形虫）项目，专注分布式数据库proxy开发。<br>主要解决：</p>
<ol>
<li>降低数据切分带来的复杂多数据库结构</li>
<li>提供切分规则并降低切分数据库带来的影响</li>
<li>读写分离</li>
</ol>
<h4 id="为什么要用amoeba"><a href="#为什么要用amoeba" class="headerlink" title="为什么要用amoeba"></a>为什么要用amoeba</h4><p>目前实现mysql的主从读写分离，主要有以下几个方案：</p>
<ol>
<li>通过mysql-proxy来实现，由于mysql-proxy的主从读写分离是通过lua脚本来实现，目前lua的脚步开发跟不上节奏，因此导致用于生产环境风险较大。</li>
<li>通过程序实现，复杂</li>
<li>自己开发接口实现，开发成本高</li>
<li>利用阿里巴巴开源项目Amoeba实现，负载均衡、读写分离、配置简单</li>
</ol>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在node04中执行下面步骤：<br>一、安装jdk<br>1、<a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html找到`jdk-8u181-linux-x64.rpm`，复杂到node04中" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html找到`jdk-8u181-linux-x64.rpm`，复杂到node04中</a></p>
<p>2、<code>rpm -ivh jdk-8u181-linux-x64.rpm</code>进行安装</p>
<blockquote>
<p>如果想删除<code>rpm -Uvh jdk-8u181-linux-x64.rpm</code></p>
</blockquote>
<p>3、配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>按G跳到最后一行，再按o添加内容：<br>export JAVA_HOME=/usr/java/jdk1.8.0_181-amd64<br>export PATH=$PATH:$JAVA_HOME/bin</p>
<p>退出source /etc/profile</p>
<p>4、查看<br>java -version</p>
<p>二、使用amoeba<br>1、<a href="https://sourceforge.net/projects/amoeba/下载复制amoeba-mysql-3.0.5-RC-distribution.zip" target="_blank" rel="noopener">https://sourceforge.net/projects/amoeba/下载复制amoeba-mysql-3.0.5-RC-distribution.zip</a><br>2、下载解压包<code>yum install zip unzip</code>，使用unzip解压上面的安装包<br>3、跳进目录amoeba-mysql-3.0.5-RC里面的conf中<br>4、修改里面的amoeba.xml和dbServers.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi dbServers.xml</span><br><span class="line">修改：</span><br><span class="line">输入dG，把里面东西全部删除，然后按a，把下面东西复制过来</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;gbk&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE amoeba:dbServers SYSTEM &quot;dbserver.dtd&quot;&gt;</span><br><span class="line">&lt;amoeba:dbServers xmlns:amoeba&#x3D;&quot;http:&#x2F;&#x2F;amoeba.meidusa.com&#x2F;&quot;&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- </span><br><span class="line">			Each dbServer needs to be configured into a Pool,</span><br><span class="line">			If you need to configure multiple dbServer with load balancing that can be simplified by the following configu</span><br><span class="line">ration:			 add attribute with name virtual &#x3D; &quot;true&quot; in dbServer, but the configuration does not allow the element with n</span><br><span class="line">ame factoryConfig			 such as &#39;multiPool&#39; dbServer   </span><br><span class="line">		--&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;dbServer name&#x3D;&quot;abstractServer&quot; abstractive&#x3D;&quot;true&quot;&gt;</span><br><span class="line">		&lt;factoryConfig class&#x3D;&quot;com.meidusa.amoeba.mysql.net.MysqlServerConnectionFactory&quot;&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;connectionManager&quot;&gt;$&#123;defaultManager&#125;&lt;&#x2F;property&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;sendBufferSize&quot;&gt;64&lt;&#x2F;property&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;receiveBufferSize&quot;&gt;128&lt;&#x2F;property&gt;</span><br><span class="line">				</span><br><span class="line">			&lt;!-- mysql port --&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;port&quot;&gt;3306&lt;&#x2F;property&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;!-- mysql schema --&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;schema&quot;&gt;msb&lt;&#x2F;property&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;!-- mysql user --&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;property name&#x3D;&quot;password&quot;&gt;140140&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;&#x2F;factoryConfig&gt;</span><br><span class="line"></span><br><span class="line">		&lt;poolConfig class&#x3D;&quot;com.meidusa.toolkit.common.poolable.PoolableObjectPool&quot;&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;maxActive&quot;&gt;500&lt;&#x2F;property&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;maxIdle&quot;&gt;500&lt;&#x2F;property&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;minIdle&quot;&gt;1&lt;&#x2F;property&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;minEvictableIdleTimeMillis&quot;&gt;600000&lt;&#x2F;property&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;timeBetweenEvictionRunsMillis&quot;&gt;600000&lt;&#x2F;property&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;testOnBorrow&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;testOnReturn&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;testWhileIdle&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;&#x2F;poolConfig&gt;</span><br><span class="line">	&lt;&#x2F;dbServer&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dbServer name&#x3D;&quot;writedb&quot;  parent&#x3D;&quot;abstractServer&quot;&gt;</span><br><span class="line">		&lt;factoryConfig&gt;</span><br><span class="line">			&lt;!-- mysql ip --&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;ipAddress&quot;&gt;192.168.12.111&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;&#x2F;factoryConfig&gt;</span><br><span class="line">	&lt;&#x2F;dbServer&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;dbServer name&#x3D;&quot;slave&quot;  parent&#x3D;&quot;abstractServer&quot;&gt;</span><br><span class="line">		&lt;factoryConfig&gt;</span><br><span class="line">			&lt;!-- mysql ip --&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;ipAddress&quot;&gt;192.168.12.112&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;&#x2F;factoryConfig&gt;</span><br><span class="line">	&lt;&#x2F;dbServer&gt;</span><br><span class="line">	&lt;dbServer name&#x3D;&quot;myslave&quot; virtual&#x3D;&quot;true&quot;&gt;</span><br><span class="line">		&lt;poolConfig class&#x3D;&quot;com.meidusa.amoeba.server.MultipleServerPool&quot;&gt;</span><br><span class="line">			&lt;!-- Load balancing strategy: 1&#x3D;ROUNDROBIN , 2&#x3D;WEIGHTBASED , 3&#x3D;HA--&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;loadbalance&quot;&gt;1&lt;&#x2F;property&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;!-- Separated by commas,such as: server1,server2,server1 --&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;poolNames&quot;&gt;slave&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;&#x2F;poolConfig&gt;</span><br><span class="line">	&lt;&#x2F;dbServer&gt;</span><br><span class="line">&lt;&#x2F;amoeba:dbServers&gt;</span><br><span class="line"></span><br><span class="line">amoeba.xml同样删除后粘贴下面内容：</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;gbk&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE amoeba:configuration SYSTEM &quot;amoeba.dtd&quot;&gt;</span><br><span class="line">&lt;amoeba:configuration xmlns:amoeba&#x3D;&quot;http:&#x2F;&#x2F;amoeba.meidusa.com&#x2F;&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;proxy&gt;</span><br><span class="line">	</span><br><span class="line">		&lt;!-- service class must implements com.meidusa.amoeba.service.Service --&gt;</span><br><span class="line">		&lt;service name&#x3D;&quot;Amoeba for Mysql&quot; class&#x3D;&quot;com.meidusa.amoeba.mysql.server.MySQLService&quot;&gt;</span><br><span class="line">			&lt;!-- port --&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;port&quot;&gt;8066&lt;&#x2F;property&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;!-- bind ipAddress --&gt;</span><br><span class="line">			&lt;!-- </span><br><span class="line">			&lt;property name&#x3D;&quot;ipAddress&quot;&gt;127.0.0.1&lt;&#x2F;property&gt;</span><br><span class="line">			 --&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;property name&#x3D;&quot;connectionFactory&quot;&gt;</span><br><span class="line">				&lt;bean class&#x3D;&quot;com.meidusa.amoeba.mysql.net.MysqlClientConnectionFactory&quot;&gt;</span><br><span class="line">					&lt;property name&#x3D;&quot;sendBufferSize&quot;&gt;128&lt;&#x2F;property&gt;</span><br><span class="line">					&lt;property name&#x3D;&quot;receiveBufferSize&quot;&gt;64&lt;&#x2F;property&gt;</span><br><span class="line">				&lt;&#x2F;bean&gt;</span><br><span class="line">			&lt;&#x2F;property&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;property name&#x3D;&quot;authenticateProvider&quot;&gt;</span><br><span class="line">				&lt;bean class&#x3D;&quot;com.meidusa.amoeba.mysql.server.MysqlClientAuthenticator&quot;&gt;</span><br><span class="line">					</span><br><span class="line">					&lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt;</span><br><span class="line">					</span><br><span class="line">					&lt;property name&#x3D;&quot;password&quot;&gt;140140&lt;&#x2F;property&gt;</span><br><span class="line">					</span><br><span class="line">					&lt;property name&#x3D;&quot;filter&quot;&gt;</span><br><span class="line">						&lt;bean class&#x3D;&quot;com.meidusa.toolkit.net.authenticate.server.IPAccessController&quot;&gt;</span><br><span class="line">							&lt;property name&#x3D;&quot;ipFile&quot;&gt;$&#123;amoeba.home&#125;&#x2F;conf&#x2F;access_list.conf&lt;&#x2F;property&gt;</span><br><span class="line">						&lt;&#x2F;bean&gt;</span><br><span class="line">					&lt;&#x2F;property&gt;</span><br><span class="line">				&lt;&#x2F;bean&gt;</span><br><span class="line">			&lt;&#x2F;property&gt;</span><br><span class="line">			</span><br><span class="line">		&lt;&#x2F;service&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;runtime class&#x3D;&quot;com.meidusa.amoeba.mysql.context.MysqlRuntimeContext&quot;&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;!-- proxy server client process thread size --&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;executeThreadSize&quot;&gt;128&lt;&#x2F;property&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;!-- per connection cache prepared statement size  --&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;statementCacheSize&quot;&gt;500&lt;&#x2F;property&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;!-- default charset --&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;serverCharset&quot;&gt;utf8&lt;&#x2F;property&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;!-- query timeout( default: 60 second , TimeUnit:second) --&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;queryTimeout&quot;&gt;60&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;&#x2F;runtime&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;&#x2F;proxy&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- </span><br><span class="line">		Each ConnectionManager will start as thread</span><br><span class="line">		manager responsible for the Connection IO read , Death Detection</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;connectionManagerList&gt;</span><br><span class="line">		&lt;connectionManager name&#x3D;&quot;defaultManager&quot; class&#x3D;&quot;com.meidusa.toolkit.net.MultiConnectionManagerWrapper&quot;&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;subManagerClassName&quot;&gt;com.meidusa.toolkit.net.AuthingableConnectionManager&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;&#x2F;connectionManager&gt;</span><br><span class="line">	&lt;&#x2F;connectionManagerList&gt;</span><br><span class="line">	</span><br><span class="line">		&lt;!-- default using file loader --&gt;</span><br><span class="line">	&lt;dbServerLoader class&#x3D;&quot;com.meidusa.amoeba.context.DBServerConfigFileLoader&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;configFile&quot;&gt;$&#123;amoeba.home&#125;&#x2F;conf&#x2F;dbServers.xml&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;dbServerLoader&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;queryRouter class&#x3D;&quot;com.meidusa.amoeba.mysql.parser.MysqlQueryRouter&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;ruleLoader&quot;&gt;</span><br><span class="line">			&lt;bean class&#x3D;&quot;com.meidusa.amoeba.route.TableRuleFileLoader&quot;&gt;</span><br><span class="line">				&lt;property name&#x3D;&quot;ruleFile&quot;&gt;$&#123;amoeba.home&#125;&#x2F;conf&#x2F;rule.xml&lt;&#x2F;property&gt;</span><br><span class="line">				&lt;property name&#x3D;&quot;functionFile&quot;&gt;$&#123;amoeba.home&#125;&#x2F;conf&#x2F;ruleFunctionMap.xml&lt;&#x2F;property&gt;</span><br><span class="line">			&lt;&#x2F;bean&gt;</span><br><span class="line">		&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;sqlFunctionFile&quot;&gt;$&#123;amoeba.home&#125;&#x2F;conf&#x2F;functionMap.xml&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;LRUMapSize&quot;&gt;1500&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;defaultPool&quot;&gt;writedb&lt;&#x2F;property&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;property name&#x3D;&quot;writePool&quot;&gt;writedb&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;readPool&quot;&gt;myslave&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;needParse&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;queryRouter&gt;</span><br><span class="line">&lt;&#x2F;amoeba:configuration&gt;</span><br></pre></td></tr></table></figure>

<p>5、<code>cd ../bin</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;launcher</span><br></pre></td></tr></table></figure>

<p>可能会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The stack size specified is too small, Specify at least 228k</span><br><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br></pre></td></tr></table></figure>

<p>因为栈空间太小。解决：<br>跳回amoeba-mysql-3.0.5-RC中，修改jvm.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">vi jvm.properties</span><br><span class="line">里面-Xss改为-Xss256k</span><br></pre></td></tr></table></figure>
<p>再到bin目录下执行<code>./launcher</code>，成功。</p>
<p>6、配置好后，可以进行连接。转到node03中：<br><code>mysql -uroot -p140140 -h192.168.12.114 -P8066</code></p>
<p><strong>读数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use msb</span><br><span class="line">select * from psn;</span><br></pre></td></tr></table></figure>
<p>打印结果为1，2，4。即查看的是node02<br><strong>插数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into psn values(5,&#39;5&#39;);</span><br><span class="line">select * from psn;</span><br></pre></td></tr></table></figure>
<p>打印结果为1，2，4，5。即查看的是node02</p>
<p>现在停掉node01服务（service mysqld stop），再到node03中插入6.报错：<br><font color='red'>ERROR 1044 (42000): Amoeba could not connect to MySQL server[192.168.12.111:3306],Connection refused</font><br>重启node01服务，再插入就会成功。</p>
<p>停掉node02，node03查询，失败。再重启才可以查询到1，2，4，5，6</p>
<p><font color='purple'><strong>说明：node01是写库，node02是读库。</strong></font></p>
<h3 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h3><p><img src="https://img-blog.csdnimg.cn/20210306161733940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>对于DBA来说，</strong>Mycat就是Mysql Server，而Mycat后面连接的Mysql Server，就好像是Mysql的存储引擎。因此Mycat本身不存储数据，数据是在后端的Mysql上存储的。简单来说，Mycat在一定程度上让mysql拥有了跟Oracle pk的能力。</p>
<p><strong>对于软件工程师来说，</strong>Mycat<strong>近似等于</strong>Mysql的数据库服务器，可用连接mysql的方式去连接mycat（默认端口号是8066而不是mysql的3306）</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>读写分离</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle数据库连接时候报错</title>
    <url>/2021/02/14/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%80%99%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="IDEA中进行Oracle数据库连接时候报错"><a href="#IDEA中进行Oracle数据库连接时候报错" class="headerlink" title="IDEA中进行Oracle数据库连接时候报错"></a>IDEA中进行Oracle数据库连接时候报错</h1><blockquote>
<p>Exception in thread “main” java.sql.SQLException: The Network Adapter could not establish the connection<br>    at oracle.jdbc.driver.T4CConnection.logon(T4CConnection.java:412)<br>    at oracle.jdbc.driver.PhysicalConnection.<init>(PhysicalConnection.java:531)<br>    at oracle.jdbc.driver.T4CConnection.<init>(T4CConnection.java:221)<br>    at oracle.jdbc.driver.T4CDriverExtension.getConnection(T4CDriverExtension.java:32)<br>    at oracle.jdbc.driver.OracleDriver.connect(OracleDriver.java:503)<br>    at java.sql.DriverManager.getConnection(DriverManager.java:664)<br>    at java.sql.DriverManager.getConnection(DriverManager.java:247)<br>    at Demo.JDBCTest.main(JDBCTest.java:19)<br>Caused by: oracle.net.ns.NetException: The Network Adapter could not establish the connection<br>    at oracle.net.nt.ConnStrategy.execute(ConnStrategy.java:359)<br>    at oracle.net.resolver.AddrResolution.resolveAndExecute(AddrResolution.java:422)<br>    at oracle.net.ns.NSProtocol.establishConnection(NSProtocol.java:672)<br>    at oracle.net.ns.NSProtocol.connect(NSProtocol.java:237)<br>    at oracle.jdbc.driver.T4CConnection.connect(T4CConnection.java:1042)<br>    at oracle.jdbc.driver.T4CConnection.logon(T4CConnection.java:301)<br>    … 7 more<br>Caused by: java.net.ConnectException: Connection refused: connect<br>    at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)<br>    at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:85)<br>    at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)<br>    at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)<br>    at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)<br>    at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)<br>    at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)<br>    at java.net.Socket.connect(Socket.java:606)<br>    at oracle.net.nt.TcpNTAdapter.connect(TcpNTAdapter.java:141)<br>    at oracle.net.nt.ConnOption.connect(ConnOption.java:123)<br>    at oracle.net.nt.ConnStrategy.execute(ConnStrategy.java:337)<br>    … 12 more</p>
</blockquote>
<p>源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 加载驱动</span><br><span class="line">        Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);</span><br><span class="line">        &#x2F;&#x2F;2. 建立连接</span><br><span class="line">        Connection connection &#x3D; DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;,</span><br><span class="line">                &quot;scott&quot;, &quot;tiger&quot;);</span><br><span class="line">        &#x2F;&#x2F;3. 测试是否成功</span><br><span class="line">        System.out.println(connection);</span><br></pre></td></tr></table></figure>

<p>将localhost改成自己的ip地址后成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@192.168.12.1:1521:orcl"</span>,</span><br><span class="line">                <span class="string">"scott"</span>, <span class="string">"tiger"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>NUMA</title>
    <url>/2020/09/21/NUMA/</url>
    <content><![CDATA[<p>NUMA是一种底层优化。</p>
<p>UMA（统一访问内存）：多个CPU共享一个内存<br><img src="https://img-blog.csdnimg.cn/20200921183025379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>NUMA（Non Uniform Memory Access非统一访问内存）：对于自己那块主板插槽附近的自己的内存是有优先级的。（就近访问原则）<br><img src="https://img-blog.csdnimg.cn/20200921182935375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>ZGC可以做到NUMA-Aware，分配内存会优先分配线程所在CPU的最近内存</p>
]]></content>
      <categories>
        <category>硬件基础知识</category>
        <category>CPU</category>
      </categories>
      <tags>
        <tag>NUMA</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进行JDBC连接时报错</title>
    <url>/2021/02/15/Mysql%E8%BF%9B%E8%A1%8CJDBC%E8%BF%9E%E6%8E%A5%E6%97%B6%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<pre><code>我的版本：mysql-5.7.26-winx64和mysql-connector-java-8.0.17.jar</code></pre><h2 id="连接mysql报错java-sql-SQLException-The-server-time-zone-value-‘�й���׼ʱ��’-is-unrecognized…解决方法"><a href="#连接mysql报错java-sql-SQLException-The-server-time-zone-value-‘�й���׼ʱ��’-is-unrecognized…解决方法" class="headerlink" title="连接mysql报错java.sql.SQLException: The server time zone value ‘�й���׼ʱ��’ is unrecognized…解决方法"></a>连接mysql报错java.sql.SQLException: The server time zone value ‘�й���׼ʱ��’ is unrecognized…解决方法</h2><p>报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"C:\Program Files\Java\jdk1.8.0_231\bin\java.exe"</span> <span class="string">"-javaagent:D:\idea\IntelliJ IDEA 2020.1\lib\idea_rt.jar=1072:D:\idea\IntelliJ IDEA 2020.1\bin"</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath <span class="string">"C:\Program Files\Java\jdk1.8.0_231\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_231\jre\lib\rt.jar;C:\Users\Lenovo\Desktop\database\oracle\code\JDBC\out\production\JDBC;C:\Users\Lenovo\Desktop\database\oracle\node\ojdbc6.jar;C:\Users\Lenovo\Desktop\database\oracle\code\数据库连接池\工具类\commons-dbutils-1.7\commons-dbutils-1.7.jar;C:\Users\Lenovo\Desktop\database\oracle\code\数据库连接池\工具类\mysql-connector-java-8.0.17.jar"</span> apacheDBUtil.DBUtilTest</span><br><span class="line">java.sql.SQLException: The server time zone value <span class="string">'�й���׼ʱ��'</span> is unrecognized or represents more than one time zone. <span class="function">You must configure either the server or JDBC <span class="title">driver</span> <span class="params">(via the serverTimezone configuration property)</span> to use a more specifc time zone value <span class="keyword">if</span> you want to utilize time zone support.</span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.exceptions.SQLError.<span class="title">createSQLException</span><span class="params">(SQLError.java:<span class="number">129</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.exceptions.SQLError.<span class="title">createSQLException</span><span class="params">(SQLError.java:<span class="number">97</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.exceptions.SQLError.<span class="title">createSQLException</span><span class="params">(SQLError.java:<span class="number">89</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.exceptions.SQLError.<span class="title">createSQLException</span><span class="params">(SQLError.java:<span class="number">63</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.exceptions.SQLError.<span class="title">createSQLException</span><span class="params">(SQLError.java:<span class="number">73</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.<span class="title">translateException</span><span class="params">(SQLExceptionsMapping.java:<span class="number">76</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.ConnectionImpl.<span class="title">createNewIO</span><span class="params">(ConnectionImpl.java:<span class="number">827</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.ConnectionImpl.&lt;init&gt;<span class="params">(ConnectionImpl.java:<span class="number">447</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.ConnectionImpl.<span class="title">getInstance</span><span class="params">(ConnectionImpl.java:<span class="number">237</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.NonRegisteringDriver.<span class="title">connect</span><span class="params">(NonRegisteringDriver.java:<span class="number">199</span>)</span></span></span><br><span class="line"><span class="function">	at java.sql.DriverManager.<span class="title">getConnection</span><span class="params">(DriverManager.java:<span class="number">664</span>)</span></span></span><br><span class="line"><span class="function">	at java.sql.DriverManager.<span class="title">getConnection</span><span class="params">(DriverManager.java:<span class="number">247</span>)</span></span></span><br><span class="line"><span class="function">	at util.MySQLDButil.<span class="title">getConnection</span><span class="params">(MySQLDButil.java:<span class="number">24</span>)</span></span></span><br><span class="line"><span class="function">	at apacheDBUtil.DBUtilTest.<span class="title">testQuery</span><span class="params">(DBUtilTest.java:<span class="number">19</span>)</span></span></span><br><span class="line"><span class="function">	at apacheDBUtil.DBUtilTest.<span class="title">main</span><span class="params">(DBUtilTest.java:<span class="number">28</span>)</span></span></span><br><span class="line"><span class="function">Caused by: com.mysql.cj.exceptions.InvalidConnectionAttributeException: The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must configure either the server or JDBC <span class="title">driver</span> <span class="params">(via the serverTimezone configuration property)</span> to use a more specifc time zone value <span class="keyword">if</span> you want to utilize time zone support.</span></span><br><span class="line"><span class="function">	at sun.reflect.NativeConstructorAccessorImpl.<span class="title">newInstance0</span><span class="params">(Native Method)</span></span></span><br><span class="line"><span class="function">	at sun.reflect.NativeConstructorAccessorImpl.<span class="title">newInstance</span><span class="params">(NativeConstructorAccessorImpl.java:<span class="number">62</span>)</span></span></span><br><span class="line"><span class="function">	at sun.reflect.DelegatingConstructorAccessorImpl.<span class="title">newInstance</span><span class="params">(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)</span></span></span><br><span class="line"><span class="function">	at java.lang.reflect.Constructor.<span class="title">newInstance</span><span class="params">(Constructor.java:<span class="number">423</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.exceptions.ExceptionFactory.<span class="title">createException</span><span class="params">(ExceptionFactory.java:<span class="number">61</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.exceptions.ExceptionFactory.<span class="title">createException</span><span class="params">(ExceptionFactory.java:<span class="number">85</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.util.TimeUtil.<span class="title">getCanonicalTimezone</span><span class="params">(TimeUtil.java:<span class="number">132</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.protocol.a.NativeProtocol.<span class="title">configureTimezone</span><span class="params">(NativeProtocol.java:<span class="number">2139</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.protocol.a.NativeProtocol.<span class="title">initServerSession</span><span class="params">(NativeProtocol.java:<span class="number">2163</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.ConnectionImpl.<span class="title">initializePropsFromServer</span><span class="params">(ConnectionImpl.java:<span class="number">1301</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.ConnectionImpl.<span class="title">connectOneTryOnly</span><span class="params">(ConnectionImpl.java:<span class="number">958</span>)</span></span></span><br><span class="line"><span class="function">	at com.mysql.cj.jdbc.ConnectionImpl.<span class="title">createNewIO</span><span class="params">(ConnectionImpl.java:<span class="number">817</span>)</span></span></span><br><span class="line"><span class="function">	... 8 more</span></span><br><span class="line"><span class="function">Exception in thread "main" java.sql.SQLException: Null connection</span></span><br><span class="line"><span class="function">	at org.apache.commons.dbutils.QueryRunner.<span class="title">query</span><span class="params">(QueryRunner.java:<span class="number">363</span>)</span></span></span><br><span class="line"><span class="function">	at org.apache.commons.dbutils.QueryRunner.<span class="title">query</span><span class="params">(QueryRunner.java:<span class="number">252</span>)</span></span></span><br><span class="line"><span class="function">	at apacheDBUtil.DBUtilTest.<span class="title">testQuery</span><span class="params">(DBUtilTest.java:<span class="number">22</span>)</span></span></span><br><span class="line"><span class="function">	at apacheDBUtil.DBUtilTest.<span class="title">main</span><span class="params">(DBUtilTest.java:<span class="number">28</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Process finished with exit code 1</span></span><br></pre></td></tr></table></figure>
<p><strong>解决</strong>：<br>在cmd中，输入<code>mysql -uroot -p</code>，再输入密码，进入mysql命令行。之后<br>修改时区：<code>set global time_zone=&#39;+8:00&#39;;</code><img src="https://img-blog.csdnimg.cn/20210215162036425.png" alt="在这里插入图片描述"><br>即可成功。</p>
<h2 id="Loading-class-com-mysql-jdbc-Driver‘-This-is-deprecated"><a href="#Loading-class-com-mysql-jdbc-Driver‘-This-is-deprecated" class="headerlink" title="Loading class `com.mysql.jdbc.Driver‘. This is deprecated"></a>Loading class `com.mysql.jdbc.Driver‘. This is deprecated</h2><p>报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Loading <span class="class"><span class="keyword">class</span> `<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>'. <span class="title">This</span> <span class="title">is</span> <span class="title">deprecated</span>. <span class="title">The</span> <span class="title">new</span> <span class="title">driver</span> <span class="title">class</span> <span class="title">is</span> `<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>'. <span class="title">The</span> <span class="title">driver</span> <span class="title">is</span> <span class="title">automatically</span> <span class="title">registered</span> <span class="title">via</span> <span class="title">the</span> <span class="title">SPI</span> <span class="title">and</span> <span class="title">manual</span> <span class="title">loading</span> <span class="title">of</span> <span class="title">the</span> <span class="title">driver</span> <span class="title">class</span> <span class="title">is</span> <span class="title">generally</span> <span class="title">unnecessary</span>.</span></span><br></pre></td></tr></table></figure>
<p>加载类“ com.mysql.jdbc.Driver”。 不推荐使用。 新的驱动程序类为“ com.mysql.cj.jdbc.Driver”。 通过SPI自动注册驱动程序，通常不需要手动加载驱动程序类。</p>
<p><strong>解决</strong>：<br><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>改成<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code></p>
<details><summary>MySQLDButil.java</summary>
<pre><code>public class MySQLDButil {
    public static final String URL = "jdbc:mysql://localhost:3306/demo";
    public static final String USERNAME ="root";
    public static final String PASSWORD = "512";

<pre><code>static {
    try {
        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}

public static Connection getConnection(){
    try {
        return DriverManager.getConnection(URL,USERNAME,PASSWORD);
    } catch (SQLException throwables) {
        throwables.printStackTrace();
    }
    return null;
}

/**
 * 关闭数据库连接
 * @param connection
 */
public static void closeConnection(Connection connection) {
    if (connection != null) {
        try {
            connection.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
}
public static void closeConnection(Connection connection, Statement statement) {
    if (statement != null) {
        try {
            statement.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
    if (connection != null) {
        try {
            connection.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
}
public static void closeConnection(Connection connection, Statement statement, ResultSet resultSet) {
    if (resultSet != null) {
        try {
            resultSet.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
    if (statement != null) {
        try {
            statement.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
    if (connection != null) {
        try {
            connection.close();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
}</code></pre><p>}</code></pre></p>
</details>]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle函数</title>
    <url>/2021/02/05/Oracle%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h2><p>【在api里面做一个基本查询就可以了】<br>函数一般是在数据上执行的，它给数据的转换和处理提供了方便。<br>只是将取出的数据进行处理，<strong>不会改变数据库中的值</strong>。</p>
<p><strong>分类</strong><br>SQL函数可以分为<strong>组函数</strong>和<strong>单行函数</strong>。<br>&emsp;– <strong>组函数</strong>(又称聚合函数)，输入多个值，最终只会返回一个值<br>&emsp;– <font color='orange'>组函数仅可用于<strong>选择列表</strong>或者<strong>查询的having子句</strong></font><br>where语句后面的只能是表中已有的字段，类似于<code>sum(sal)</code>这种的是不能被执行的。<br>&emsp;– <strong>单行函数</strong>，输入一个值，输出一个值<br>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>因为count(<em>)是在虚拟表里面，而并不存在于emp表中。所以如果把<code>having</code>换成<code>where</code>会报<code>COU标识符无效</code>。<br><font color='orange'>注意：上面的count(</em>)不能取别名<code>select deptno,c from emp group by deptno having c &gt;3;</code>也会报错</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询所有员工的薪水总和</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(sal) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">--查看表中有多少条记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) cou <span class="keyword">from</span> emp；</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) cou <span class="keyword">from</span> emp；</span><br><span class="line"><span class="comment">--查看人数大于3的部门的部门编号</span></span><br><span class="line"><span class="keyword">select</span> deptno,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt;<span class="number">3</span>;</span><br><span class="line"><span class="comment">--错误，where语句后面的只能是表中已有的字段，而函数得到的字段是虚拟表字段</span></span><br><span class="line"><span class="keyword">select</span> deptno,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">where</span> <span class="keyword">count</span>(*) &gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h3><p>单行函数，输入一个值，输出一个值<br><strong>分类</strong><br><img src="https://img-blog.csdnimg.cn/20210205233109493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=50% height=50% align=center></p>
<h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><p>字符函数全以<strong>字符作为参数</strong>，返回值分为两类：一类返回字符值，一类返回数字值。<br>– concat（string1，string2）连接两个字符串 ||<br>– initcap（string）string中<strong>每个</strong>单词首字母大写<br>– lower(string) 以小写形式返回string<br>– lpad,rpad 填充字符型数据<br>– ltrim/rtrim(string1,string2) 去左边/右部空格<br>– trim(A from B) 去空格<br>– Substr（string,x,y）提取字符串的一部分<br>&emsp;x代表第几个位置<br>&emsp;y代表长度<br>&emsp;0和1的效果一样<br>&emsp;用负数则从右边开始数第几个位置<br>– upper(string）以大写形式返回string<br>– Instr（）字符串出现的位置<br>– Length（）字符串长度</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--concat：表示字符串的连接，等同于 ||</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'my name is '</span>,ename) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">--将字符串的每个首字母大写</span></span><br><span class="line"><span class="keyword">select</span> initcap(<span class="string">'eq a'</span>) <span class="keyword">from</span> dual; <span class="comment">-- Eq a</span></span><br><span class="line"><span class="comment">--将字符串全部转换为大写</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">upper</span>(ename) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">--将字符串全部转换为小写</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">lower</span>(ename) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">--填充字符串 </span></span><br><span class="line"><span class="comment">--规定字符串长度为10左端用*补全</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">lpad</span>(ename,<span class="number">10</span>,<span class="string">'*'</span>) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">--规定字符串长度为10右端用*补全</span></span><br><span class="line"><span class="keyword">select</span> rpad(ename,<span class="number">10</span>,<span class="string">'*'</span>) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">--去空格</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">trim</span>(ename) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">ltrim</span>(ename) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rtrim</span>(ename) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查找指定字符串的位置</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">instr</span>(<span class="string">'ABCDABC'</span>,<span class="string">'BC'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 结果为2</span></span><br><span class="line"><span class="comment">--查看字符串长度</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">length</span>(ename) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">--替换操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">replace</span>(<span class="string">'aabbd'</span>,<span class="string">'aa'</span>,<span class="string">'hehe'</span>) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">--提取字符串的一部分</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'abcde'</span>,<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">from</span> emp; <span class="comment">--ab</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'abcde'</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">from</span> emp; <span class="comment">--ab</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'abcde'</span>,<span class="number">-5</span>,<span class="number">2</span>) <span class="keyword">from</span> dual; <span class="comment">--ab</span></span><br></pre></td></tr></table></figure>

<h4 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h4><p>数字函数以NUMBER类型为参数返回NUMBER值。<br>负数在函数操作中也是支持的。<br>▪ round（number，n）返回四舍五入后的值<br>▪ trunc（number，n）<br>▪ mod（x，y）求余数<br>▪ ceil()上取整<br>▪ floor()下取整<br>▪ abs()绝对值<br>▪ sign(x)获取正负值 x=0，返回0；x&lt;0，返回-1；否则返回1<br>▪ power(x,y)x的y次幂</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--进行四舍五入运算，可以指定小数部分位数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">123.123</span>,<span class="number">2</span>) <span class="keyword">from</span> dual;<span class="comment">--结果为123.12</span></span><br><span class="line"><span class="comment">--截断数据，按照位数直接截取，不会进行其他操作</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.128</span>,<span class="number">2</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--取模操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">mod</span>(<span class="number">10</span>,<span class="number">4</span>) <span class="keyword">from</span> dual; <span class="comment">--结果为2 10 mod 4 = 2</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">mod</span>(<span class="number">-10</span>,<span class="number">4</span>) <span class="keyword">from</span> dual;  <span class="comment">--结果为-2 </span></span><br><span class="line"><span class="comment">--向上取整</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">ceil</span>(<span class="number">123.12</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--向下取整</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">floor</span>(<span class="number">123.56</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">floor</span>(<span class="number">-123.12</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--绝对值</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">abs</span>(<span class="number">-123.56</span>) <span class="keyword">from</span> dual; <span class="comment">--123.56</span></span><br><span class="line"><span class="comment">--获取正负值</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sign</span>(<span class="number">100</span>) <span class="keyword">from</span> dual; <span class="comment">--1</span></span><br><span class="line"><span class="comment">--x的y次幂</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">power</span>(<span class="number">2</span>,<span class="number">4</span>) <span class="keyword">from</span> dual; <span class="comment">--16</span></span><br></pre></td></tr></table></figure>

<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>Oracle以内部数字格式存储日期:世纪,年,月,日,小时,分钟,秒。<br>– sysdate/current_date 以date类型返回当前的日期<br>– Add_months(d,x) 返回加上x月后的日期d的值<br>– LAST_DAY(d) 返回的所在月份的最后一天<br>– Months_between(date1,date2) 返回date1和date2之间月的数目</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--获取当前系统时间</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span> <span class="keyword">from</span> dual; <span class="comment">--2021/2/6 10:13:18</span></span><br><span class="line"><span class="comment">--当前日期增加2个月</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span> 当前日期,add_months(<span class="keyword">sysdate</span>,<span class="number">2</span>) add_months <span class="keyword">from</span> dual; </span><br><span class="line"><span class="comment">--返回输入日期所在月份的最后一天</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">last_day</span>(<span class="keyword">sysdate</span>) <span class="keyword">from</span> dual;<span class="comment">--2021/2/28 10:13:50</span></span><br><span class="line"><span class="comment">--两个日期相隔的月份 trunc截断</span></span><br><span class="line"><span class="keyword">select</span> trunc(months_between(<span class="keyword">sysdate</span>,hiredate),<span class="number">3</span>) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">--提取日期中的时间</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">extract</span>(<span class="keyword">hour</span> <span class="keyword">from</span> <span class="built_in">timestamp</span> <span class="string">'2001-2-16 2:38:40 '</span> ) 小时,</span><br><span class="line"><span class="keyword">extract</span>(<span class="keyword">minute</span> <span class="keyword">from</span> <span class="built_in">timestamp</span> <span class="string">'2001-2-16 2:38:40 '</span> ) 分钟,</span><br><span class="line"><span class="keyword">extract</span>(<span class="keyword">second</span> <span class="keyword">from</span> <span class="built_in">timestamp</span> <span class="string">'2001-2-16 2:38:40 '</span> ) 秒,</span><br><span class="line"><span class="keyword">extract</span>(<span class="keyword">DAY</span> <span class="keyword">from</span> <span class="built_in">timestamp</span> <span class="string">'2001-2-16 2:38:40 '</span> ) 日,</span><br><span class="line"><span class="keyword">extract</span>(<span class="keyword">MONTH</span> <span class="keyword">from</span> <span class="built_in">timestamp</span> <span class="string">'2001-2-16 2:38:40 '</span> ) 月,</span><br><span class="line"><span class="keyword">extract</span>(<span class="keyword">YEAR</span> <span class="keyword">from</span> <span class="built_in">timestamp</span> <span class="string">'2001-2-16 2:38:40 '</span> ) 年</span><br><span class="line"> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>mysql中的日期函数</strong><br>▪ select current_time() from dual;—- mysql:时间。<br>▪ select current_date() form dual; —mysql；日期<br>▪ select current_timestamp() from dual;—mysql：日期时间</p>
</blockquote>
<h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><p>在oracle中，存在数值的<strong>隐式转换</strong>和<strong>显示转换</strong>。<br>隐式转换指的是<strong>字符串</strong>可以转换为<strong>数值</strong>或者<strong>日期</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'999'</span>+<span class="number">10</span> <span class="keyword">from</span> dual; <span class="comment">-- 1009</span></span><br></pre></td></tr></table></figure>
<p>尽管数据类型之间可以进行隐式转换，仍建议使用显示转换函数，以保持良好的设计风格。<br>显示转换指的是当由<strong>数值或者日期</strong>转换为<strong>字符串</strong>的时候，使用显示转换函数，必须规定格式。<br>▪ to_char<br>▪ to_number<br>▪ to_date<br><img src="https://img-blog.csdnimg.cn/20210206112846797.png" width=40% height=40% align=center></p>
<p>1、<strong>TO_CHAR(date, ‘fmt’)</strong><br>用于将日期或时间戳转换成varchar2类型字符串，要指定格式字符串<br><img src="https://img-blog.csdnimg.cn/20210206105603174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=60% height=60% align=center></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--date：to_char</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="keyword">sysdate</span>,<span class="string">'YYYY-MM-DD HH24:MI:SS'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 2021-02-06 11:40:26</span></span><br></pre></td></tr></table></figure>

<p>2、<strong>to_char（num,format）</strong><br>用于将Number类型参数转换为varchar2类型，要指定format<br><img src="https://img-blog.csdnimg.cn/2021020611340090.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=60% height=60% align=center></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--number：to_char</span></span><br><span class="line"><span class="comment">--9：占位符 </span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="number">123.456789</span>,<span class="string">'9999'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 123.46</span></span><br><span class="line"><span class="comment">--0：填充0占位符 </span></span><br><span class="line"><span class="comment">--.：显示本小数点</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="number">123.456789</span>,<span class="string">'0000.00'</span>) <span class="keyword">from</span> dual;<span class="comment">-- 0123.46</span></span><br><span class="line"><span class="comment">--$：显示美元符号</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="number">123.456789</span>,<span class="string">'$0000.00'</span>) <span class="keyword">from</span> dual;<span class="comment">-- $0123.46</span></span><br><span class="line"><span class="comment">--L：显示本地货币符号</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="number">123.456789</span>,<span class="string">'L0000.00'</span>) <span class="keyword">from</span> dual;<span class="comment">-- ￥0123.46</span></span><br><span class="line"><span class="comment">--,：显示千分位符号</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="number">12345.456789</span>,<span class="string">'000,000,0.00'</span>) <span class="keyword">from</span> dual;<span class="comment">--  001,234,5.46</span></span><br></pre></td></tr></table></figure>
<p>3、<strong>to_date (String,format)</strong><br>将char或varchar2类型的string转换为date类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">to_date</span>(<span class="string">'2019-10-10 10:10:10'</span>,<span class="string">'YYYY-MM-DD HH24:MI:SS'</span>) <span class="keyword">from</span> dual; <span class="comment">--2019/10/10 10:10:10</span></span><br></pre></td></tr></table></figure>
<p>4、<strong>to_number(String,format)</strong><br>将char或varchar2类型的string转换为number类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_number(<span class="string">'123,456.789'</span>,<span class="string">'999,999.999'</span>) <span class="keyword">from</span> dual; <span class="comment">-- 123456.789</span></span><br></pre></td></tr></table></figure>

<h4 id="单行函数嵌套"><a href="#单行函数嵌套" class="headerlink" title="单行函数嵌套"></a>单行函数嵌套</h4><p>案例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--显示没有上级管理（mgr为null）的公司首脑  </span></span><br><span class="line"><span class="keyword">select</span> ename,nvl(to_char(mgr),<span class="string">'boss'</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> mgr <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">--显示员工雇佣期满6个月后下一个星期五的日期</span></span><br><span class="line"><span class="keyword">select</span> hiredate,next_day(add_months(hiredate,<span class="number">6</span>),<span class="string">'星期五'</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><h5 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h5><p>decode(条件,值1,翻译值1,值2,翻译值2,…值n,翻译值n,缺省值)<br>功能】根据条件返回相应值<br>【参数】c1, c2, …,cn,字符型/数值型/日期型，必须类型相同或null<br>注：值1……n <font color='orange'>不能为条件表达式</font>,这种情况只能用case when then end解决</p>
<p>该函数的含义如下：　　<br>　　IF 条件=值1 THEN<br>　　RETURN(翻译值1)<br>　　ELSIF 条件=值2 THEN<br>　　RETURN(翻译值2)<br>　　……<br>　　ELSIF 条件=值n THEN<br>　　RETURN(翻译值n)　　<br>　　ELSE<br>　　RETURN(缺省值)<br>　　END IF</p>
<p><strong>例子</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--给不同部门的人员涨薪，10部门涨10%，20部门涨20%，30部门涨30%</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       <span class="keyword">decode</span>(deptno, <span class="number">10</span>, sal * <span class="number">1.1</span>, <span class="number">20</span>, sal * <span class="number">1.2</span>, <span class="number">30</span>, sal * <span class="number">1.3</span>)</span><br><span class="line">  <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h5 id="case-when"><a href="#case-when" class="headerlink" title="case when"></a>case when</h5><p>case [&lt;表达式&gt;]<br>when &lt;表达式条件值1&gt; then &lt;满足条件时返回值1&gt;<br>[when &lt;表达式条件值2&gt; then &lt;满足条件时返回值2&gt;<br>……<br>[else  &lt;不满足上述条件时返回值&gt;]]<br>end<br>【功能】当：&lt;表达式&gt;＝&lt;表达式条件值1……n&gt; 时，返回对应 &lt;满足条件时返回值1……n&gt;<br>【参数】<br>&lt;表达式&gt; 默认为true (逻辑型)<br>&lt;表达式条件值1……n&gt; 类型要与&lt;表达式&gt;类型一致，<br>若&lt;表达式&gt;为字符型，则&lt;表达式条件值1……n&gt;也要为字符型<br>【注意点】<br>1、以CASE开头，以END结尾<br>2、分支中WHEN 后跟条件，THEN为显示结果<br>3、ELSE 为除此之外的默认情况，类似于高级语言程序中switch case的default，<font color='orange'>可以不加</font><br>4、END 后跟别名<br>5、只返回第一个符合条件的值,剩下的when部分将会被<font color='orange'>自动忽略</font>，得注意条件先后顺序</p>
<p><strong>例子</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--给不同部门的人员涨薪，10部门涨10%，20部门涨20%，30部门涨30%</span></span><br><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       sal,</span><br><span class="line">       <span class="keyword">case</span> deptno</span><br><span class="line">         <span class="keyword">when</span> <span class="number">10</span> <span class="keyword">then</span></span><br><span class="line">          sal * <span class="number">1.1</span></span><br><span class="line">         <span class="keyword">when</span> <span class="number">20</span> <span class="keyword">then</span></span><br><span class="line">          sal * <span class="number">1.2</span></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">          sal * <span class="number">1.3</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h3 id="组函数"><a href="#组函数" class="headerlink" title="组函数"></a>组函数</h3><p>组函数，一般情况下，组函数都要和group by组合使用<br>常用的组函数有5个：<br>▪ avg()返回某列的平均值，只适合数值类型的数据<br>▪ min()返回某列的最小值，适用于任何类型<br>▪ max()返回某列的最大值，适用于任何类型<br>▪ sum()返回某列值的和，只适合数值类型的数据<br>▪ count()返回某列的行数，处理的时候会跳过空值而处理非空值<br><strong>注：</strong></p>
<ol>
<li>group by，按照某些相同的值去进行分组操作</li>
<li>group进行分组操作的时候，可以指定一个列或者多个列，但是使用了group by之后，<font color='orange'>选择列表中只能包含<strong>组函数的值</strong>或者<strong>group by的普通字段</strong></font>。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 求每个部门的平均薪水</span></span><br><span class="line"><span class="keyword">select</span> deptno,<span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br><span class="line"><span class="comment">--求平均薪水大于2000的部门</span></span><br><span class="line"><span class="keyword">select</span> deptno, <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> <span class="keyword">avg</span>(sal) &gt; <span class="number">2000</span>;</span><br><span class="line"><span class="comment">-- 报错,不是group by表达式</span></span><br><span class="line"><span class="keyword">select</span> sal, <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">having</span> <span class="keyword">avg</span>(sal) &gt; <span class="number">2000</span>;</span><br></pre></td></tr></table></figure>
 <strong>理解</strong>：按照部门进行分组后，每个部门里面的工资能一样吗？不能！所以sal根本查不出来了。</li>
<li>组函数仅在选择列表和Having子句中有效</li>
<li>count一般用于获取表中的记录条数，获取条数的时候可以使用<code>*</code>或者某一个具体的列，甚至可以使用纯数字来代替，但从效率角度考虑，建议使用数字或者某一个具体的列，而不要使用<code>*</code>效率太低。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--三种方式结果相同</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(ename) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li>
<li>组函数不能处理null<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(comm) <span class="keyword">from</span> emp; <span class="comment">--分母只算不为空的条目</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(nvl(comm,<span class="number">0</span>)) <span class="keyword">from</span> emp; <span class="comment">--分母为全部条目</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h4><p>▪ <strong>创建分组</strong><br>&emsp;– group by 子句<br>&emsp;– Group by 子句可以包含任意数目的列。<br>▪ 除组函数语句外，select语句中的每个列都必须在group by 子句中给出。<br>&emsp;– 如果分组列中具有null值，则null将作为一个分组返回。如果列中有多行null值，他们将分为一组。<br>&emsp;– Group by 子句必须出现在where子句之后，order by 子句之前。<br>▪ <strong>过滤分组</strong>（having子句)<br>&emsp;– Where过滤行，having过滤分组。<br>&emsp;– Having支持所有where操作符。<br>▪ 分组和排序<br>&emsp;– 一般在使用group by 子句时，应该也给出order by子句</p>
<p>▪ 使用GROUP BY子句将表分成小组<br>▪ 出现在SELECT列表中的字段，如果出现的位置不是在组函数中，那么必须出现在GROUP BY子句中<br>▪ GROUP BY 列可以不在SELECT列表中<br>▪ 不能在 WHERE 子句中使用组函数.不能在 WHERE 子句中限制组. 使用Having对分组进行限制</p>
<h4 id="Sql语句执行过程"><a href="#Sql语句执行过程" class="headerlink" title="Sql语句执行过程"></a>Sql语句执行过程</h4><img src="https://img-blog.csdnimg.cn/20210206170757317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=60% height=60% align=center>
1、读取from子句中的基本表、视图的数据。
2、选取满足where子句中给出的条件表达式的元组
3、按group子句中指定列的值分组，同时提取满足Having子句中组条件表达式的那些组
4、按select子句中给出的列名戒列表达式求值输出
5、Order by子句对输出的目标表进行排序

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--求部门下雇员的工资&gt;1200的人的平均薪资，且大于2000的部门，按顺序排列</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(sal)</span><br><span class="line">  <span class="keyword">from</span> emp</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> deptno</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(sal) &gt; <span class="number">2000</span></span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">avg</span>(sal);</span><br></pre></td></tr></table></figure>

<p>部门里面 工龄最小和最大的人找出来</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno, <span class="keyword">min</span>(hiredate), <span class="keyword">max</span>(hiredate) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210206194847279.png" width=40% height=40% align=center>
如果想把对应的人名字列出来，怎么办？外面嵌套一层。
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,deptno <span class="keyword">from</span> emp <span class="keyword">where</span> hiredate <span class="keyword">in</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">min</span>(hiredate), <span class="keyword">max</span>(hiredate) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno);</span><br></pre></td></tr></table></figure>
in里面只能包含一个集合，这里面有两个集合，<font color="orange">**报错：值过多**</font>。那就再分开。
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename, deptno</span><br><span class="line">  <span class="keyword">from</span> emp</span><br><span class="line"> <span class="keyword">where</span> hiredate <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">min</span>(hiredate) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno)</span><br><span class="line">    <span class="keyword">or</span> hiredate <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">max</span>(hiredate) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno);</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210206200919527.png" width=30% height=30% align=center>
部门为20的有2个。为什么？因为FORD的雇佣日期是`1981/12/3`，刚好和30部门工龄最小的JAMES同一天。这样导致FORD也符合条件被打印出来了。所以我们要把部门也进行关联。但是我们发现in里面都是对应的子查询，没法写了。

<p>我们发现这种问题无法使用我们的<strong>子查询</strong>来解决了，需要用到两张表的关联查询。从而引入了<strong>关联查询</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> mm2.deptno, e1.ename, e1.hiredate</span><br><span class="line">  <span class="keyword">from</span> emp e1,</span><br><span class="line">       (<span class="keyword">select</span> <span class="keyword">min</span>(e.hiredate) mind, <span class="keyword">max</span>(e.hiredate) maxd, e.deptno</span><br><span class="line">          <span class="keyword">from</span> emp e</span><br><span class="line">         <span class="keyword">group</span> <span class="keyword">by</span> e.deptno) mm2</span><br><span class="line"> <span class="keyword">where</span> (e1.hiredate = mm2.mind <span class="keyword">or</span> e1.hiredate = mm2.maxd)</span><br><span class="line">   <span class="keyword">and</span> e1.deptno = mm2.deptno;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210206202146650.png" width=30% height=30% align=center>

<h3 id="易错例子"><a href="#易错例子" class="headerlink" title="易错例子"></a>易错例子</h3><p>1、查询员工的奖金，如果奖金不为NULL显示‘有奖金’，为null则显示无奖金。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,</span><br><span class="line">       <span class="keyword">decode</span>(nvl(to_char(comm), <span class="string">'无奖金'</span>),</span><br><span class="line">              to_char(comm),</span><br><span class="line">              <span class="string">'有奖金'</span>,</span><br><span class="line">              <span class="string">'无奖金'</span>)</span><br><span class="line">  <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<p><font color='purple'>nvl(a, b) 当a！=null，才返回b。a，b类型要相同。</font></p>
<p>2、查询EMP表按管理者编号升序排列，如果管理者编号为空则把为空的在最前显示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> mgr <span class="keyword">nulls</span> <span class="keyword">first</span>;</span><br></pre></td></tr></table></figure>
<p><font color='purple'>注意<code>nulls first</code>的使用。</font></p>
<p>3、按部门求出工资大于1300人员的 部门编号、平均工资、最小佣金、最大佣金,且最大佣金大于100。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno, <span class="keyword">avg</span>(nvl(sal, <span class="number">0</span>)), <span class="keyword">min</span>(comm), <span class="keyword">max</span>(comm)</span><br><span class="line">  <span class="keyword">from</span> emp</span><br><span class="line"> <span class="keyword">where</span> sal &gt; <span class="number">1300</span></span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> deptno</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">max</span>(nvl(comm, <span class="number">0</span>)) &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p><font color='purple'>Where过滤行，having过滤分组。</font></p>
<p>4、查询10号部门中编号最新入职的员工，工龄最长的员工的个人信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> emp</span><br><span class="line"> <span class="keyword">where</span> deptno = <span class="number">10</span></span><br><span class="line">   <span class="keyword">and</span> (empno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">max</span>(empno) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span>) <span class="keyword">or</span></span><br><span class="line">       hiredate <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">min</span>(hiredate) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<font color='purple'>
① and优先级大于or。</br>
② 组函数仅在**选择列表**和**Having子句**中有效，不要忘记在where中的过滤条件中也可以有select选择列表，这个里面同样有效。</font>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle的简单使用</title>
    <url>/2021/02/04/Oracle%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h2><p>数据库的作用：数据持久化</p>
<p><strong>分类：</strong><br>关系型数据库</p>
<ul>
<li>Mysql（用的最多）</li>
<li>Oracle（最安全，权限管理很严格）</li>
<li>Sql server（.net）</li>
</ul>
<p>非关系型数据库</p>
<ul>
<li>Hbase</li>
<li>Redis</li>
<li>mongodb</li>
</ul>
<h3 id="Oracle介绍"><a href="#Oracle介绍" class="headerlink" title="Oracle介绍"></a>Oracle介绍</h3><p>一、数据库版本<br>Oracle9i：是之前使用最广泛版本<br>Oracle11g：现在主要使用的版本<br>二、用户</p>
<p>1) sys 超级管理员 bjmsb<br>2) system 普通管理员 bjmsb<br>3) scott 普通的用户 tiger </p>
<h3 id="Oracle安装"><a href="#Oracle安装" class="headerlink" title="Oracle安装"></a>Oracle安装</h3><p>见<a href="http://git.mashibing.com/bjmashibing/java/-/tree/master/database/note" target="_blank" rel="noopener">oracle的安装.docx</a></p>
<p>安装好后，<code>Win+r：services.msc</code> 进入服务中，在里面能看到相关信息，安装好后，会多出很多Oracle相关的服务。一般有7个，少了肯定有问题，卸载重装。<br>有一些服务是没有必要开启的，可以关闭几个保证开机速度。所有服务的属性都改成<code>手动</code>，只启动<code>Listener</code>和<code>OracleServiceORCL</code>。</p>
<h4 id="Oracle服务"><a href="#Oracle服务" class="headerlink" title="Oracle服务"></a>Oracle服务</h4><p>成功安装Oracle 11g后，共有7个服务，这七个服务的含义分别为：</p>
<ol>
<li>Oracle ORCL VSS Writer Service：Oracle卷映射拷贝写入服务。（非必须启动）</li>
<li>OracleDBConsoleorcl：Oracle数据库控制台服务。（非必须启动）</li>
<li>OracleJobSchedulerORCL：Oracle作业调度（定时器）服务。（非必须启动）</li>
<li>OracleMTSRecoveryService：服务端控制。（非必须启动）</li>
<li>OracleOraDb11g_home1ClrAgent：Oracle数据库.NET扩展服务的一部分。（非必须启动）</li>
<li><code>OracleOraDb11g_home1TNSListener</code>：：监听器服务，服务只有在数据库需要远程访问的时候才需要。（<strong>必须启动</strong>）</li>
<li><code>OracleServiceORCL</code>：数据库服务，是数据库启动的基础， 只有该服务启动，Oracle数据库才能正常启动。(<strong>必须启动</strong>)</li>
<li>（可能存在）OracleRemExecService ：暂时被使用。reboot之后会自动消失</li>
</ol>
<p>注：ORCL是数据库实例名，默认的数据库是ORCL，你可以创建其他的，即OracleService+数据库名</p>
<h4 id="第一次连接"><a href="#第一次连接" class="headerlink" title="第一次连接"></a>第一次连接</h4><p><strong>第一种方式：</strong><br>在Windows中找到oracle文件夹，里面有一个<code>SQL Plus</code>，是Oracle中自带的客户端命令行工具</p>
<blockquote>
<p>输入用户名：scott<br>输入口令：bjmsb<br>Error：the account is locked</p>
</blockquote>
<p>安装好之后是不能直接访问的，如果在安装过程中，<strong>口令管理</strong>不选择SCOTT锁定账户，可以访问。</p>
<p><strong>第二种方式</strong>：</p>
<ol>
<li>在cmd中，输入：<code>sqlplus /nolog</code>  意思是不登录，只是进入到SQL Plus命令行里面</li>
<li>连接。 输入：<code>conn scott/tiger@orcl</code><br>会报<code>Error：the account is locked</code>，和第一种效果一样。<br>【tiger是密码，无所谓】</li>
</ol>
<p>推荐使用第二种方式。<br>我们使用的时候必须要进行一个<strong>解锁操作</strong>：<br>先用管理员进行登录，解锁我们对应的账户。</p>
<ol>
<li><code>conn 用户/口令@数据库实例名 as sysdba;</code> 告诉别人我是一个dba（databaseadminister，数据库管理员）的身份。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; conn sys&#x2F;bjmsb@orcl as sysdba;</span><br><span class="line">已连接。</span><br></pre></td></tr></table></figure>
可以进行用户查看：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; show user;</span><br><span class="line">USER 为 &quot;SYS&quot;</span><br></pre></td></tr></table></figure></li>
<li><code>alter user scott account unlock;</code> 解锁用户。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; alter user scott account unlock;</span><br><span class="line"></span><br><span class="line">用户已更改。</span><br></pre></td></tr></table></figure></li>
<li>先退出<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; quit</span><br></pre></td></tr></table></figure></li>
<li>再输入：<code>sqlplus /nolog</code>进入命令行</li>
<li>更改口令为<code>tiger</code>。输入<code>conn scott/tiger@orcl;</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; conn scott&#x2F;tiger@orcl;</span><br><span class="line">ERROR:</span><br><span class="line">ORA-28001: the password has expired</span><br><span class="line"></span><br><span class="line">更改 scott 的口令</span><br><span class="line">新口令:tiger</span><br><span class="line">重新键入新口令:</span><br><span class="line">口令已更改</span><br><span class="line">已连接。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="之后的连接"><a href="#之后的连接" class="headerlink" title="之后的连接"></a>之后的连接</h4><ol>
<li>cmd中，输入<code>sqlplus /nolog</code></li>
<li>SQL命令行中输入<code>conn scott/tiger@orcl;</code></li>
</ol>
<h4 id="数据库查看表"><a href="#数据库查看表" class="headerlink" title="数据库查看表"></a>数据库查看表</h4><p>本身自带四张表。BONUS，DEPT，EMP，SALGRANE<br>查表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; select * from tab;</span><br><span class="line"></span><br><span class="line">TNAME                          TABTYPE  CLUSTERID</span><br><span class="line">------------------------------ ------- ----------</span><br><span class="line">BONUS                          TABLE</span><br><span class="line">DEPT                           TABLE</span><br><span class="line">EMP                            TABLE</span><br><span class="line">SALGRADE                       TABLE</span><br></pre></td></tr></table></figure>
<p>查表中数据：<code>SQL&gt; select * from emp;</code>，数据看的太丑了，可以更改数据格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; set pagesize 50;  &#x2F;&#x2F; 每页行可以显示多少个字符，随便写</span><br><span class="line">SQL&gt; set linesize 200; &#x2F;&#x2F; 每行可以显示多少个字符</span><br><span class="line">SQL&gt; select * from emp;</span><br><span class="line"></span><br><span class="line">     EMPNO ENAME      JOB              MGR HIREDATE              SAL       COMM     DEPTNO</span><br><span class="line">---------- ---------- --------- ---------- -------------- ---------- ---------- ----------</span><br><span class="line">      7369 SMITH      CLERK           7902 17-12月-80            800                    20</span><br><span class="line">      7499 ALLEN      SALESMAN        7698 20-2月 -81           1600        300         30</span><br><span class="line">      7521 WARD       SALESMAN        7698 22-2月 -81           1250        500         30</span><br><span class="line">      7566 JONES      MANAGER         7839 02-4月 -81           2975                    20</span><br><span class="line">      7654 MARTIN     SALESMAN        7698 28-9月 -81           1250       1400         30</span><br><span class="line">      7698 BLAKE      MANAGER         7839 01-5月 -81           2850                    30</span><br><span class="line">      7782 CLARK      MANAGER         7839 09-6月 -81           2450                    10</span><br><span class="line">      7788 SCOTT      ANALYST         7566 19-4月 -87           3000                    20</span><br><span class="line">      7839 KING       PRESIDENT            17-11月-81           5000                    10</span><br><span class="line">      7844 TURNER     SALESMAN        7698 08-9月 -81           1500          0         30</span><br><span class="line">      7876 ADAMS      CLERK           7788 23-5月 -87           1100                    20</span><br><span class="line">      7900 JAMES      CLERK           7698 03-12月-81            950                    30</span><br><span class="line">      7902 FORD       ANALYST         7566 03-12月-81           3000                    20</span><br><span class="line">      7934 MILLER     CLERK           7782 23-1月 -82           1300                    10</span><br><span class="line"></span><br><span class="line">已选择14行。</span><br></pre></td></tr></table></figure>
<p>而管理员不能随意查询表数据。<code>SQL&gt; select * from emp;</code>会失败，想要查看，可以采用<code>SQL&gt; select * from scott.emp;</code>，说明这个表归属于哪个用户，才能查到信息。</p>
<p>上面的操作成功意味着<strong>Oracle安装完成</strong>。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>详细见<a href="http://39.101.213.88/bjmashibing/java/-/blob/master/database/note/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93.docx" target="_blank" rel="noopener">创建新的数据库.docx</a></p>
<ol>
<li><p>在Windows的Oracle-OraDb11g_home1中，选择<code>Database Configuration Assistant</code></p>
</li>
<li><p>弹窗选择：创建数据库 –&gt; 一般用途或事务处理 –&gt; 全局数据库名随便设置（msb）–&gt; 所有账户使用同一口令（让操作简单，bjmsb）–&gt; 完成。【未提出的均默认下一步】</p>
<blockquote>
<p><strong>数据库和数据仓库</strong><br>公司大项目，不可能只用一个数据库，可能用MySQL，也有可能用Oracle等。有一天想要把这些数据做一个集中处理，可以按照一个统一规则，把各种数据源的数据整合到数据仓库里面。<br><strong>数据库</strong>属于<code>联机事务处理OLTP</code>（on-line transaction processing，），主要用于捕获数据；<strong>数据仓库</strong>属于<code>联机分析处理OLAP</code>，主要用于分析数据。数据仓库还可以实现<code>时间拉链表</code>，数据仓库会帮我们保留各个历史时间的数据。</p>
</blockquote>
</li>
<li><p>检测<br>cmd中，输入<code>sqlplus /nolog</code><br>SQL命令行中输入<code>conn scott/tiger@msb;</code>，成功连接，用<code>select * from tab;</code>语句会发现依然保留着那四张表，依然能进行查表操作。<br>说明创建库成功。</p>
</li>
<li><p>在服务中，将<code>OracleJobSchedulerMSB</code>属性改为手动</p>
</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>a) sqlplus</strong></p>
<ol>
<li>sqlplus /nolog</li>
<li>conn scott/tiger@orcl</li>
<li>show user</li>
<li>set linesize 150</li>
<li>set pagesize 20</li>
<li>passw</li>
<li>conn sys/abc123456@orcl as sysdba</li>
<li>select * from emp where ename=’&amp;ename’</li>
</ol>
<p><strong>b) alter user scott account unlock</strong><br>统一密码：tiger</p>
<h3 id="集成开发环境进行Oracle连接"><a href="#集成开发环境进行Oracle连接" class="headerlink" title="集成开发环境进行Oracle连接"></a>集成开发环境进行Oracle连接</h3><h4 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h4><p>1、新建连接<br><img src="https://img-blog.csdnimg.cn/20210204214107242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如果远程连接失败，可能有两个原因：<br>方式1<br>工具–&gt;选项–&gt;OCL library需要选择一个后缀叫<code>oci.dll</code>的文件，然后把这个文件修改一下。</p>
<blockquote>
<p><strong>具体操作</strong>：把Oracle安装目录D:\oracle\product\11.2.0\dbhome_1\bin\oci.dll(根据你的实际安装目录)下的oci.dll文件替换Navicat安装目录D:\Program Files (x86)\Navicat Premium 12\instantclient_11_2\oci.dll(根据你的实际安装目录)下的oci.dll就可以了。</p>
</blockquote>
<p>方式2 </p>
<ol>
<li>使用<code>PLSQL Developer</code>这个集成开发环境。<br><code>plsqldev11_chs.zip</code>里面提供了需要的软件。</li>
</ol>
<h4 id="PLSQL-Developer"><a href="#PLSQL-Developer" class="headerlink" title="PLSQL Developer"></a>PLSQL Developer</h4><p>安装好后点开，先不要选Login，然后进入页面后，选择Help里面的<code>Register</code>。辅助使用keygen工具，输入对应的三个值。<br>2. 点击session，点击<code>Log on</code>，重新进行填写。用户名<code>scott</code>，密码<code>tiger</code>（自己设置），Database选<code>ORCL</code>，connect as<code>normal</code>即可。登录成功。</p>
<p><strong>报错</strong><br>电脑重启第二次点开<code>PLSQL</code>的时候，<strong>报错ORA-12541: TNS: 无监听程序</strong>。或者<strong>报错监听程序当前无法识别连接描述符中请求的错误</strong>。<br>首先确保以下成功：<br>点开服务（<code>services.msc</code>），开启对应的两个服务。</p>
<p>【可以cmd中连接数据库，再到<code>PLSQL</code>进行log on进行检验】</p>
<p>如果依旧失败，尝试下面操作，对listener重新配置。<br>Net Configuration Assistant -&gt; 重新配置 -&gt; Listener -&gt;..<br>如果点不动重新配置，就删除<code>listener.ora</code>，然后点击添加，一路默认下一步即可。</p>
<p>重新配置不熟，还有一种方便的方法：</p>
<ol>
<li>把配置好的<code>配置文件</code>里面的<code>listener.ora</code>,<code>sqlnet.ora</code>,<code>tnsnames.ora</code>，把相应的路径名称换成自己的。然后拷贝到<code>D:\oracle\product\11.2.0\dbhome_1\NETWORK\ADMIN</code>中。</li>
<li>把<code>sqlnet.ora</code>中<code>MSB=……msb</code>改为自己创建的库名</li>
</ol>
<p>如果依旧失败，把<code>listener.ora</code>,<code>tnsnames.ora</code>的HOST换位IP地址（我的是192.168.12.1），然后重启启动上面两个服务即可。</p>
<h5 id="PLSQL简单操作"><a href="#PLSQL简单操作" class="headerlink" title="PLSQL简单操作"></a>PLSQL简单操作</h5><p><strong>点击查表</strong><br>1、拉伸开下面部分，找到Table，里面就是对应的表<br><img src="https://img-blog.csdnimg.cn/20210205095842209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210205100028446.png" alt="在这里插入图片描述"><br>2、比如要查EMP表，就右击EMP，选择<code>Query data</code>,就可以查出表。上面也可以写相应的SQL语句。</p>
<p><strong>命令行查表</strong><br>File-&gt;new，最好选择<code>command window</code>。里面就是sqlplus的样式。也可以选择<code>sql window</code>，输入语句后需要选中然后点击执行，效果相同。执行键如下：<br><img src="https://img-blog.csdnimg.cn/20210205100946145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>下面explain plan window，会告诉你执行计划，包括执行你写的sql语句所需要的时间等。</p>
<p><strong>查看表信息</strong><br>右击相应表（比如EMP），选择edit<br>Comments是注释的意思。可以用<code>comment on table emp is &#39;雇员表&#39;;</code>sql语句添加注释</p>
<h5 id="PLSQL-注意事项"><a href="#PLSQL-注意事项" class="headerlink" title="PLSQL 注意事项"></a>PLSQL 注意事项</h5><p>在SQL Window中执行命令时，底下的框有多大，查询出来的结果显示就有几行（会提示没显示完全…more）。所以要保证足够大，以免漏了数据。<br><img src="https://img-blog.csdnimg.cn/20210205145516531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210205145601339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>解决</strong>：可以点击图中向下的绿色箭头fetch last page（alt+end+fn）获取全部记录，或者fetch next page（alt+PgDn+fn）获取部分记录。</p>
<h5 id="PLSQL的代码优化"><a href="#PLSQL的代码优化" class="headerlink" title="PLSQL的代码优化"></a>PLSQL的代码优化</h5><p>使用beautifier，让代码看起来更简洁易懂。<br><img src="https://img-blog.csdnimg.cn/20210205151609237.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210205151815614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle表设计</title>
    <url>/2021/02/08/Oracle%E8%A1%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="VIEW视图"><a href="#VIEW视图" class="headerlink" title="VIEW视图"></a>VIEW视图</h2><p>▪ 视图(view)，也称<font color='red'>虚表,</font>, 不占用物理空间，只有逻辑定义。<br>▪ 视图本身的<strong>定义语句</strong>还是要存储在<strong>数据字典</strong>里的。每次使用的时候, 只是重新执行SQL。<br><font color='red'>【给定一个sql语句，当每次用到的这个视图的时候，相当于把sql里面我们规定好的语句语句重新创建一下。】</font><br>▪ 视图是从一个或多个实际表中获得的，这些表的数据存放在数据库中。那些用于产生视图的表叫做该视图的<strong>基表</strong>。一个视图也可以从另一个视图中产生。<br><font color='red'>【比如，如果我们要查询雇员的名称和其所在部门的名称，意味着从emp表和dept表分别取出一个字段。这两个字段位于两张表，如果想组合进行使用的时候，可以把它定义成一个视图，下一次要查询的时候优先从这两张表里面做一个查询，查完后再进行一个实际操作】</font><br>▪ 视图的定义存在数据库中，与此相关的数据并不存在数据库中。通过视图看到的数据存放在基表中。<br>▪ 当通过视图修改数据时，实际上是在改变基表中的数据；相反地，基表数据的改变也会自动反映在由基表产生的视图中。由于逻辑上的原因，有些Oracle视图可以修改对应的基表，有些则不能（仅仅能查<br>询）。<br><font color='red'>【如果是只读视图，就不会修改基表的数据】</font></p>
<blockquote>
<p><font color='purple'><strong>物化视图</strong></font>：&lt;fontcolor=’red’&gt;只在Oracle中有。</font>会占用物理空间。如果基表中的数据更改了，视图中的数据也会更改，但是，它的更改是分两种方式的：<br>1.On DEMAND 仅在物化视图“需要”被刷新了，才进行刷新<br>2.ON COMMIT 一旦基表提交了数据，立刻刷新物化视图</p>
</blockquote>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>复杂的时候创建才有意义。<br><strong>语法</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">VIEW</span> <span class="keyword">view</span></span><br><span class="line">[(<span class="keyword">alias</span>[, <span class="keyword">alias</span>]...)]</span><br><span class="line"><span class="keyword">AS</span> subquery</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">ONLY</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_emp <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=<span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p><font color='orange'>注：普通用户第一次使用，提示没有权限，要使用管理员去修改权限。只有在授权视图后才能创建成功。</font></p>
<h4 id="授权视图"><a href="#授权视图" class="headerlink" title="授权视图"></a>授权视图</h4><p>在cmd中登录管理员权限进行授权。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">Lenovo</span>&gt; <span class="title">sqlplus</span> /<span class="title">nolog</span></span></span><br><span class="line"><span class="function"><span class="title">SQL</span>&gt; <span class="title">conn</span> <span class="title">sys</span>/<span class="title">bjmsb</span>@<span class="title">orcl</span> <span class="title">as</span> <span class="title">sysdba</span>;</span></span><br><span class="line"><span class="function">已连接。</span></span><br><span class="line"><span class="function"><span class="title">SQL</span>&gt; <span class="title">grant</span> <span class="title">create</span> <span class="title">view</span> <span class="title">to</span> <span class="title">scott</span>;</span></span><br><span class="line"><span class="function">授权成功。</span></span><br></pre></td></tr></table></figure>
<p>撤销权限<code>SQL&gt; revoke create view from scott;</code></p>
<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> v_emp;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> v_emp(empno,ename) <span class="keyword">values</span>(<span class="number">1111</span>,<span class="string">'zhangsan'</span>);</span><br><span class="line"><span class="comment">--当前查询的时候，只在当前会话里有效，如果用另外一个会话查询的话，你根本查不到</span></span><br><span class="line"><span class="comment">--下面查得到，在cmd中登录sql命令行查询查不到</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<p>向视图中添加数据,执行成功后，需要提交事务，绿色表示<strong>提交事务</strong>，红色表示<strong>回滚事务</strong>，让数据恢复原状态。<br><img src="https://img-blog.csdnimg.cn/20210208163535683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=60% height=60% align=center></p>
<h3 id="只读视图"><a href="#只读视图" class="headerlink" title="只读视图"></a>只读视图</h3><p>如果定义的视图是非只读视图的话，可以通过视图向表中插入数据；如果是只读视图，则不可以插入数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_emp2 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">only</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> v_emp2;</span><br><span class="line"><span class="comment">--只读视图只提供查询的需求，无法进行增删改操作</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> v_emp2(EMPNO,ename) <span class="keyword">values</span>(<span class="number">1234</span>,<span class="string">'lisi'</span>);<span class="comment">--失败</span></span><br></pre></td></tr></table></figure>

<p><strong>视图</strong><br>▪ 在查询时，不需要再写完全的Select查询语句，只需要简单的写<br>上从视图中查询的语句就可以了.<br>▪ 当视图不再需要的时候，用“drop view” 撤销。删掉视图<font color='orange'>不会导致数据的丢失</font>，因为视图是基于数据库的表之上的一个查询定义。<br>&emsp;如果是<strong>物化视图</strong>，删除的也是对应物化视图的那份数据，不是我们原来基表里面的数据，没有影响。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> v_emp2;</span><br></pre></td></tr></table></figure>

<h3 id="修改视图对应基表数据"><a href="#修改视图对应基表数据" class="headerlink" title="修改视图对应基表数据"></a>修改视图对应基表数据</h3><p><strong>修改数据</strong>：<br>UPDATE view_name SET …<br>▪ 若一个视图依赖于多个基本表, 则<strong>一次修改</strong>该视图只能修改<strong>一个基本表</strong>的数据</p>
<p><strong>删除数据</strong>:<br>delete from view_name where …<br>▪ 同样, 当视图依赖多个基表时, 不能使用此语句来删除基表中的数据，只能删除依赖一个基表的数据。<br>注：只是提供了这种操作而已，<strong>平时不要通过视图来修改和删除数据！</strong>没有意义。</p>
<p><strong>例子</strong>：<br>我们要求平均薪水的等级最低的部门，它的部门名称是什么，我<br>们完全使用子查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--1.求平均薪水</span><br><span class="line">select e.deptno,avg(sal) from emp e group by e.deptno;</span><br><span class="line">--2.求平均薪水的等级</span><br><span class="line">select t.deptno, sg.grade gd</span><br><span class="line">  from salgrade sg</span><br><span class="line">  join (select e.deptno, avg(sal) vsal from emp e group by e.deptno) t</span><br><span class="line">    on t.vsal between sg.losal and sg.hisal;</span><br><span class="line">--3.求平均薪水的等级最低的部门</span><br><span class="line">select min(t.gd) </span><br><span class="line">  from (select t.deptno, sg.grade gd</span><br><span class="line">          from salgrade sg</span><br><span class="line">          join (select e.deptno, avg(sal) vsal from emp e group by e.deptno) t</span><br><span class="line">            on t.vsal between sg.losal and sg.hisal) t</span><br><span class="line">    </span><br><span class="line">--4.求平均薪水的等级最低的部门的部门名称</span><br><span class="line">select d.dname, d.deptno</span><br><span class="line">  from dept d</span><br><span class="line">  join (select t.deptno, sg.grade gd</span><br><span class="line">          from salgrade sg</span><br><span class="line">          join (select e.deptno, avg(sal) vsal from emp e group by e.deptno) t</span><br><span class="line">            on t.vsal between sg.losal and sg.hisal) t</span><br><span class="line">    on t.deptno &#x3D; d.deptno</span><br><span class="line"> where t.gd &#x3D;</span><br><span class="line">       (select min(t.gd)</span><br><span class="line">          from (select t.deptno, sg.grade gd</span><br><span class="line">                  from salgrade sg</span><br><span class="line">                  join (select e.deptno, avg(sal) vsal</span><br><span class="line">                         from emp e</span><br><span class="line">                        group by e.deptno) t</span><br><span class="line">                    on t.vsal between sg.losal and sg.hisal) t)</span><br></pre></td></tr></table></figure>
<p>查看sql能够发现，sql中有很多重复的sql子查询，可以通过视图将重复的语句抽象出来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_deptno_grade <span class="keyword">as</span> <span class="keyword">select</span> t.deptno, sg.grade gd</span><br><span class="line">          <span class="keyword">from</span> salgrade sg</span><br><span class="line">          <span class="keyword">join</span> (<span class="keyword">select</span> e.deptno, <span class="keyword">avg</span>(sal) vsal <span class="keyword">from</span> emp e <span class="keyword">group</span> <span class="keyword">by</span> e.deptno) t</span><br><span class="line">            <span class="keyword">on</span> t.vsal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br><span class="line"><span class="comment">--使用视图替换</span></span><br><span class="line"><span class="keyword">select</span> d.dname, d.deptno</span><br><span class="line">  <span class="keyword">from</span> dept d</span><br><span class="line">  <span class="keyword">join</span> v_deptno_grade t</span><br><span class="line">    <span class="keyword">on</span> t.deptno = d.deptno</span><br><span class="line"> <span class="keyword">where</span> t.gd = (<span class="keyword">select</span> <span class="keyword">min</span>(t.gd) <span class="keyword">from</span> v_deptno_grade t)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：公司中如果只使用一次就不需要使用视图，而多次使用的才会创建视图，不需要用完就删。</p>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><ol>
<li>创建用户<br>语法：create user username identified by password<br>红色字体为用户名密码。<br>create user bjmsb identified by bjmsb;</li>
<li>查看用户是否创建<br>SQL&gt;select username from dba_users;</li>
</ol>
<p><strong>创建</strong>好后不能直接登录会话。因为还没有<strong>授权</strong>。</p>
<h3 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h3><p><strong>账户授权语法</strong>：<br>grant privileges [ON object_name] to username<br>将权限privileges授予用户username<br><code>SQL&gt;grant create session to John;</code><br>【授权：连接权限】</p>
<p><strong>登录</strong>：<br><code>SQL&gt;conn John/johnpsw@test;</code></p>
<p>将scott用户的emp表所有权限授予John，则使用下列命令：<br><code>SQL&gt;grant all on scott.emp to John;</code><br><code>select * from scott.emp</code><br>如果要<strong>收回</strong>授予用户John的scott用户表emp的所有权限，使用下列SQL语句：<br><code>SQL&gt;revoke all on scott.emp from John;</code></p>
<h3 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h3><p>将John用户的口令修改为 newpsw。<br><code>SQL&gt; alter user John identified by newpsw;</code></p>
<p><strong>删除用户</strong><br>使用drop user删除用户，关键字cascade删除用户模式中包含的数据对象</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">删除用户John，并同时删除John拥有的所有表、索引等对象。</span><br><span class="line">切换为system账户登录：</span><br><span class="line">SQL&gt; conn system/test123@test</span><br><span class="line">删除John操作：</span><br><span class="line">SQL&gt; drop user John cascade;</span><br><span class="line">测试John是否存在</span><br><span class="line">SQL&gt; conn John/newpsw@test;</span><br></pre></td></tr></table></figure>

<h3 id="查看自己的权限"><a href="#查看自己的权限" class="headerlink" title="查看自己的权限"></a>查看自己的权限</h3><p>select * from user_sys_privs;</p>
<h3 id="序列sequence"><a href="#序列sequence" class="headerlink" title="序列sequence"></a>序列sequence</h3><p>序列是oracle专有的对象，用来产生一个自动递增的序列<br>create sequence seq_name<br>increment by n 每次增长n<br>start with n 从哪个值开始增长<br>maxvalue n|nomaxvalue 10^27 or -1 最大值<br>minvalue n|no minvalue 最小值<br>cycle|nocycle 是否有循环<br>cache n|nocache 是否有缓存<br>如果有缓存，就可以把一些序列值先存到缓存里面，下次用的时候直接用就行了，不至于做一个操作每次再递增一次。</p>
<p><strong>序列的使用：</strong><br>序列.nextval –&gt;下个值</p>
<p><strong>查看序列状态</strong>：<br>序列.currval –&gt; 当前值</p>
<p><strong>注意</strong>：如果创建好序列之后没有经过任何的使用，那么不能获取当前的值。<font color='orange'>必须先执行nextval才能获取当前的值</font></p>
<p><strong>删除序列</strong>:<br>drop sequence 序列名;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> my_sequence</span><br><span class="line"><span class="keyword">increment</span> <span class="keyword">by</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--如何使用？</span></span><br><span class="line"><span class="comment">--查看当前序列的值</span></span><br><span class="line"><span class="keyword">select</span> my_sequence.currval <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--获取序列的下一个值</span></span><br><span class="line"><span class="keyword">select</span> my_sequence.nextval <span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line"><span class="comment">--emp表中插入一条记录，empno为自增序列</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(empno,ename) <span class="keyword">values</span>(my_sequence.nextval,<span class="string">'hehe'</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除序列</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">sequence</span> my_sequence;</span><br></pre></td></tr></table></figure>

<h3 id="SQL数据更新"><a href="#SQL数据更新" class="headerlink" title="SQL数据更新"></a>SQL数据更新</h3><p>DML:数据操作语言<br>▪ Sql的数据更新包括数据<strong>插入</strong>、<strong>删除</strong>和<strong>修改</strong>3个操作<br>▪ 在实际项目中，使用最多的是读取操作，但是插入数据和删除数据同等重要，而修改操作相对较少</p>
<h4 id="Insert语句"><a href="#Insert语句" class="headerlink" title="Insert语句"></a>Insert语句</h4><p>插入操作有两种方式：<br>1、元组值的插入，最基本的插入方式<br>2、查询结果的插入</p>
<p>▪ 如果有一个集合的数据，把集合中的所有数据都挨条插入的话，效率很低。</p>
<p><strong>一、元组值的插入语法</strong>如下：<br>1、如果表名后没有列，那么只能将所有的列都插入<br>&emsp;insert into tablename values(val1,val2,…);<br>2、可以指定向哪些列中插入数据<br>&emsp;insert into tablename(col1,col2,…) values(val1,val2,…);</p>
<p>▪ 向部分列插入数据的时候，不是想向哪个列插入就插入的，要遵循创建表的时候定义的规范。要求省略的列必须满足下面的条件：<br>&emsp;① 该列定义为允许Null值。<br>&emsp;② 在表定义中给出默认值，这表示如果不给出值，将使用默认值。<br>如果不符合上面两个条件，将会报错。不能成功插入。</p>
<p><strong>二、</strong>可以用insert语句把一个select语句的<strong>查询结果插入</strong>到一个基本表中，<strong>语法</strong>如下：<br>insert into tablename(col,..) select * from tablename2</p>
<p><strong>例子</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span>(<span class="number">2222</span>,<span class="string">'haha'</span>,<span class="string">'clerk'</span>,<span class="number">7902</span>,<span class="keyword">to_date</span>(<span class="string">'2019-11-2'</span>,<span class="string">'yyyy-mm-dd'</span>),<span class="number">1000</span>,<span class="number">500</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(empno,ename) <span class="keyword">values</span>(<span class="number">3333</span>,<span class="string">'wangwu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建表的其他方式</span></span><br><span class="line"><span class="comment">--复制表同时复制表数据，不会复制约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp2 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp; <span class="comment">--有数据</span></span><br><span class="line"><span class="comment">--复制表结构但是不复制表数据，不会复制约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp3 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="number">1</span>=<span class="number">2</span>;<span class="comment">--无数据</span></span><br></pre></td></tr></table></figure>

<h4 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h4><p>从基本表中删除满足条件表达式的元组。</p>
<blockquote>
<p>元组，一组里面多个值</p>
</blockquote>
<p><strong>语法</strong>：<br>delete from tablename [where condition]</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--删除满足条件的数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp2 <span class="keyword">where</span> deptno=<span class="number">10</span>;</span><br><span class="line"><span class="comment">--把整张表的数据全部清空</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp2;</span><br><span class="line"><span class="comment">--truncate</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> emp2;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<br>truncate跟delete不同，delete在进行删除的时候经过事务，而truncate不经过事务，一旦删除就是永久删除，不会回滚。效率高，但易发生误操作，不建议使用。</p>
<h4 id="UPDATE语句"><a href="#UPDATE语句" class="headerlink" title="UPDATE语句"></a>UPDATE语句</h4><p>可以修改满足条件的一个列或者是多个列。<br><strong>语法</strong>：<br>update tablename set co1 = val1, col2 = val2 where condition;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--可以更新单列</span></span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> ename ename=<span class="string">'heihei'</span> <span class="keyword">where</span> ename=<span class="string">'hehe'</span>;</span><br><span class="line"><span class="comment">--可以更新多列的值</span></span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> job=<span class="string">'teacher'</span>,mgr=<span class="number">7902</span> <span class="keyword">where</span> empo=<span class="number">15</span>;</span><br></pre></td></tr></table></figure>

<h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p><strong>一、事务</strong><br>▪ 增删改是数据库常用操作，在进行操作的时候都需要（事务）的保证，也就是说每次在plsql中执行sql语句之后都需要完成<strong>commit操作</strong>，所以事务变得非常关键。<br>▪ 最主要的<strong>目的</strong>是：最终为了保证数据一致性。<br>▪ 如果同一份数据，在同一时刻只能有一个人访问，就不会出现数据错乱的问题，但是在现在的项目中，更多的是并发访问，并发访问的同时带来的就是数据不安全，也就是不一致。<br>▪ 如果要保证数据的安全，最主要的方式就是加锁的方式，MVCC<br>▪ 事务的延伸：<br>&emsp;最基本的数据库事务<br>&emsp;声明式事务<br>&emsp;分布式事务<br>▪ 为了提高效率，有可能多个操作会在同一个事务中执行，那么就有可能部分成功，部分失败，基于这样的情况就需要<strong>事务的控制</strong>。<br>select * from emp where id=7902 for update<br>select * from emp where id=7902 lock in share mode<br>▪ 如果不保证事务的话，会造成脏读，不可重复读，幻读。</p>
<p><strong>事务</strong>（Transaction）是一个操作序列。这些操作要么都做要么都不做。是数据库环境中的<strong>逻辑工作单位</strong>。<br>▪ 事务是为了保证数据库的完整性。<br>▪ 事务<font color='red'>不能嵌套。</font><br>比如转账操作，先从A卡里扣1000块，B卡中再增加1000块。所以等于一个操作里面有两个sql语句。其实实际过程中，可能包含n条语句。如果某一条语句失败，那么前面的语句必须进行一个回滚，回到原来的状态。所以必须要保证n条语句的绑定。这几条操作，合起来就被称为一个<strong>事务</strong>。<br>▪ 在oracle中，<font color='purple'>没有事务开始的语句</font>。一个Transaction起始于一条<br>DML(Insert、Update和Delete )语句，<font color='red'><strong>结束于</strong></font>：<br>&emsp;1、正常commit（使数据修改生效）或者rollback（将数据恢复到上一个状态）<br>&emsp;2、自动提交，但是一般情况下要将自动提交自动关闭，效率太低<br>&emsp;3、用户关闭，会话后会自动提交事务。例如退出scott时候，会将执行的语句提交<br>&emsp;4、系统崩溃或断电时事务自动回滚事务，将数据恢复到上一个状态</p>
<p><strong>二、commit&amp;&amp;rollback</strong><br><strong>commit</strong>：表示事务成功地结束，此把数据永久写到文件。<br>&emsp;▪ 数据以前的状态永久性丢失<br>&emsp;▪ 所有的用户都能看到操作后的结果<br>&emsp;▪ 记录锁被释放，其他用户可以操作这些记录<br><strong>rollback</strong>：表示事务不成功的结束，把<strong>缓存区</strong>的数据进行清除，恢复到数据以前的状态。<br>&emsp;▪ 行级锁被释放</p>
<blockquote>
<p><strong>锁的机制</strong>：<br>为了解决并发访问的时候，数据不一致的问题，需要给数据加锁<br>加锁的同时需要考虑《粒度》的问题：<br>&emsp;<strong>操作的对象</strong><br>&emsp;&emsp;数据库<br>&emsp;&emsp;表<br>&emsp;&emsp;行<br>一般情况下，锁的粒度越细，效率越高；粒度越粗，效率越低<br>在实际工作环境中，大部分操作都是行级锁</p>
</blockquote>
<p>▪ 它们都是另一个事务的开始。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--可以sql命令提交/回滚，也可以按键提交/回滚</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(empno,ename) <span class="keyword">values</span>(<span class="number">1111</span>,<span class="string">'zhangsan'</span>);</span><br><span class="line"><span class="comment">--commit;</span></span><br><span class="line"><span class="comment">--rollback;</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>当前结果会提交到当前会话的一个缓冲区里面，commit之后，才会提交到某一个文件数据中。所以运行后当前会话可以查看到，但是别的会话不可以。</p>
<p><strong>三、savepoint 保存点</strong><br>当一个操作集合中包含多条sql语句，但是只想让其中某部分成功，某部分失败，此时可以使用保存点。<br>此时如果需要回滚到某一个状态的话，使用<code>rollback to 保存点名称;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--前两条sql语句成功执行提交，回退到删除1234这一条语句前，也就是这一条语句执行失败。</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> empno=<span class="number">1111</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> empno=<span class="number">2222</span>;</span><br><span class="line"><span class="keyword">savepoint</span> sp1;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> empno=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> sp1;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p><strong>四、事务的四个特性：ACID</strong><br>1、<strong>原子性</strong>（Atomicity）：不可分割，一个操作集合要么全部成功，要么全部失败，不可拆分。<br>2、<font color='red'><strong>一致性</strong></font>（Consistency）：为了保证数据的一致性，当经过n多个操作之后，数据的状态不会改变。从一个一致性状态到另一个一致性状态，也就是数据不可以发生错乱。<br>例如，转账业务最终金额总数不会变化<br>3、<font color='purple'><strong>隔离性</strong>（Isolation）</font>：各个事务之间相关不会产生影响。（隔离级别）<br>严格的隔离性会导致效率降低，在某些情况下，为了提高程序的执行效率，需要降低隔离级别。<br>&emsp;<strong>隔离级别</strong>：<br>&emsp;&emsp;读未提交<br>&emsp;&emsp;读已提交<br>&emsp;&emsp;可重复读<br>&emsp;&emsp;序列化<br>&emsp;<strong>数据不一致的问题</strong>：<br>&emsp;&emsp;脏读<br>&emsp;&emsp;不可重复读<br>&emsp;&emsp;幻读<br>4、<strong>持久性</strong>（Durability）：所有数据的修改都必须要持久化到达存储介质中，不会因为应用程序的关闭而导致数据丢失。</p>
<p>四个特性中，哪个是<strong>最关键</strong>的？<br>▪ 四个特性都是为了保证数据的一致性，所以<font color='red'><strong>一致性</strong></font>是最终的追求。<br>▪ 事务中的一致性是通过原子性、隔离性、持久性来保证的。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>在同一个事务里面，不管你读了多少次数据，你的数据应该是一致的。<br>具体看《Mysql事务测试》</p>
<h4 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h4><ol>
<li><strong>number</strong>(x,y) ：数字类型 ，最长x位，y位小数<br>&emsp;▪ Java中byte，short，long，int，float，double，boolean -&gt; number</li>
<li><strong>varchar2</strong>（maxlength）：变长字符串,这个参数的上限是32767字节<br>&emsp;▪ 声明方式如下VARCHAR2（L），L为字符串长度，没有缺省值，作为变量最大32767个字节</li>
<li><strong>char</strong>(max_length) 定长字符串 最大2000字节</li>
<li><strong>DATE</strong>:日期类型 (只能精确到秒。)</li>
<li><strong>TIMESTAMP</strong>:时间戳 (精确到微秒)</li>
<li><strong>long</strong>：长字符串，最长2GB<br>但没有人会往数据库里面放入2GB的数据，IO和性能是最大瓶颈。更多情况下会单独建一个图片服务器，而数据库里面只存放对应的路径即可。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle表设计</tag>
        <tag>事务特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Push报错fatal:The remote end hung up unexpectedly</title>
    <url>/2021/01/19/Push%E6%8A%A5%E9%94%99The%20remote%20end%20hung%20up%20unexpectedly/</url>
    <content><![CDATA[<p>在使用git更新或提交项目时候出现 <code>&quot;fatal: The remote end hung up unexpectedly &quot;</code> 原因是推送的文件太大。</p>
<p>那就简单了，要么是缓存不够，要么是网络不行，要么墙的原因.<br>解决办法：<br>修改提交缓存大小为500M，或者更大的数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.postBuffer 524288000</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>GitBash</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Python——vstack()、append()、concatenate()使用</title>
    <url>/2020/11/22/Python%E2%80%94%E2%80%94vstack()%E3%80%81append()%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-numpy-vstack"><a href="#1-numpy-vstack" class="headerlink" title="1. numpy.vstack()"></a>1. <strong>numpy.vstack()</strong></h2><p>   将<strong>两个</strong>矩阵分行合并。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line">s2 = np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>]])</span><br><span class="line">v = np.vstack((s,np.expand_dims(s2[<span class="number">0</span>],<span class="number">0</span>)))</span><br><span class="line">print(v)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>[[1 0 1]<br> [1 1 2]<br> [1 0 1]]</p>
</blockquote>
<p><code>np.expand_dims</code>将[1,0,1]升维到[[1,0,1]]，然后<code>np.vstack</code>进行合并，合并后shape为(3,3)</p>
<h2 id="2-numpy-concatenate"><a href="#2-numpy-concatenate" class="headerlink" title="2. numpy.concatenate()"></a>2. <strong>numpy.concatenate()</strong></h2><p>concatenate(a_tuple, axis=0, out=None)<br>参数说明：<br>a_tuple:对需要合并的数组用元组的形式给出，(a1,a2,a3…)<br>axis: 沿指定的轴进行拼接，默认0，即第一个轴，分行合并</p>
<p>维度必须相同，比如下面例子1不能“ar2 = np.array([[7,8], [11,12],[14,15]])”</p>
<p><strong>例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ar1 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">ar2 = np.array([[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>],[<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]])</span><br><span class="line">v = np.concatenate((ar1, ar2))</span><br><span class="line">print(v)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<blockquote>
<p>[[ 1  2  3]<br> [ 4  5  6]<br> [ 7  8  9]<br> [11 12 13]<br> [14 15 16]]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">R_pre = np.zeros((<span class="number">20</span>,<span class="number">120</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    R_pre[i] = np.concatenate((R_all[i][<span class="number">0</span>],R_all[i][<span class="number">1</span>],R_all[i][<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
<p>R_all为shape是(20,3)的array数组。R_all[0]shape为(3,)，R_all[0][0]shape为(30,)，R_all[0][1]shape为(40,)，R_all[0][2]shape为(50,)<br><code>np.concatenate</code>将把<code>R_all[i][0]</code>,<code>R_all[i][1]</code>,<code>R_all[i][2]</code>拼到一起，最终shape为(20，120)</p>
<blockquote>
<p>R_all<br>[[array([1.6848972 , 0.        , 0.        , 3.398359  , 2.530793  ,<br>       1.0050455 , 2.9787443 , 0.6477883 , 2.556338  , 0.73463535,<br>       1.        , 0.        , 0.        , 0.        , 0.        ,<br>       2.        , 0.        , 2.7559242 , 0.47480136, 2.2723987 ,<br>       1.040998  , 0.63076216, 0.12816067, 1.9125026 , 3.1089356 ,<br>       0.04926831, 2.5731335 , 0.        , 0.        , 3.6136327 ,<br>       2.1885748 , 5.271537  , 2.4973857 , 2.3315785 , 0.4876842 ,<br>       2.5446043 , 2.8961205 , 2.2814133 , 2.7040894 , 0.        ,<br>       1.        , 0.40623373, 3.410592  , 0.04632151, 1.6073561 ,<br>       3.6362302 , 0.71310234, 0.807002  , 0.43683317, 0.69910496],<br>      dtype=float32)<br>  array([2.620739  , 0.        , 1.3929726 , 0.6371676 , 0.        ,<br>       1.        , 5.4475865 , 2.6643863 , 3.880937  , 4.7303853 ,<br>       0.05517461, 5.2109375 , 0.        , 0.        , 0.        ,<br>       0.98558354, 4.7299247 , 0.        , 3.8981698 , 3.6492205 ,<br>       1.        , 0.        , 6.190553  , 0.956293  , 3.5290947 ,<br>       2.        , 0.        , 1.8282684 , 0.32657242, 2.6781952 ,<br>       3.        , 0.69895065, 5.339527  , 0.        , 0.        ,<br>       5.5791173 , 0.        , 0.11749397, 7.2194476 , 0.714684  ],<br>      dtype=float32)<br>  array([6.9061866 , 6.52601   , 0.        , 0.        , 4.5311055 ,<br>       7.437533  , 0.        , 2.2622852 , 3.6607296 , 0.        ,<br>       1.        , 1.1706101 , 2.0249732 , 2.5909576 , 1.5096041 ,<br>       5.1143856 , 0.        , 7.4348016 , 8.265553  , 4.404272  ,<br>       1.        , 8.330065  , 6.1199856 , 1.8026098 , 0.        ,<br>       2.1523745 , 4.295476  , 0.        , 0.25838286, 4.181186  ],<br>      dtype=float32)]<br> [array([0.        , 1.0517871 , 0.        , 1.9522364 , 3.4467335 ,<br>       1.6532538 , 4.5833445 , 0.        , 2.8597844 , 0.        ,<br>       1.0986375 , 1.2344751 , 0.05524588, 0.        , 0.        ,<br>       1.        , 0.48994532, 2.0663538 , 0.0655461 , 1.4628885 ,<br>       2.        , 2.5271173 , 1.6658872 , 2.042052  , 1.8442372 ,<br>       3.        , 1.60442   , 0.        , 0.        , 2.941807  ,<br>       2.429257  , 5.0982413 , 1.9689019 , 0.        , 1.2967114 ,<br>       1.        , 0.915429  , 2.7474372 , 1.6846974 , 0.        ,<br>       2.        , 0.01763296, 2.0742316 , 0.24807084, 1.9481957 ,<br>       3.6349213 , 0.        , 0.01666034, 0.        , 0.606744  ],<br>      dtype=float32)<br>  array([0.8532868 , 0.        , 3.8194625 , 3.5880175 , 0.        ,<br>       1.        , 5.657879  , 2.5737116 , 2.7199547 , 3.7972608 ,<br>       2.        , 5.668191  , 0.        , 0.        , 0.        ,<br>       3.        , 4.598634  , 0.        , 3.8855243 , 1.230322  ,<br>       4.        , 0.        , 4.118646  , 0.68806565, 3.5005343 ,<br>       5.        , 1.1631998 , 3.6151364 , 0.6011877 , 4.762535  ,<br>       6.        , 1.906799  , 6.2813354 , 0.        , 0.844307  ,<br>       6.1294475 , 0.        , 0.        , 4.284295  , 1.6493309 ],<br>      dtype=float32)<br>  array([7.5145326 , 6.0982947 , 0.        , 0.        , 4.4792795 ,<br>       5.9737115 , 0.        , 1.8298718 , 3.148109  , 0.        ,<br>       1.        , 1.504651  , 2.8004415 , 3.89071   , 2.428724  ,<br>       4.807837  , 0.        , 4.968338  , 7.585526  , 2.6616354 ,<br>       1.        , 6.461577  , 7.4716034 , 1.954241  , 0.        ,<br>       0.87860256, 4.8513737 , 0.        , 0.33363724, 3.5909863 ],<br>      dtype=float32)]<br> …<br> [array([2.7897108 , 0.20866081, 0.13220854, 2.7202427 , 1.5674844 ,<br>       0.10765126, 0.6920907 , 1.729721  , 0.        , 0.24034634,<br>       0.5080626 , 0.        , 0.83318   , 0.        , 0.48236543,<br>       0.82242155, 0.        , 2.2105615 , 0.        , 0.1478676 ,<br>       4.16913   , 0.        , 1.0112963 , 2.1834922 , 1.1143222 ,<br>       1.4266597 , 0.01625035, 0.        , 0.        , 2.2396529 ,<br>       2.5664916 , 3.9461515 , 1.1411588 , 3.1272795 , 0.1037966 ,<br>       2.0988076 , 1.3239028 , 3.7377734 , 3.2496672 , 0.        ,<br>       1.        , 1.2223835 , 3.0089378 , 0.        , 0.86522657,<br>       4.675812  , 2.1618671 , 0.        , 0.35128778, 0.4188891 ],<br>      dtype=float32)<br>  array([1.1148797 , 0.        , 0.        , 0.        , 0.        ,<br>       1.        , 3.8114898 , 0.07180021, 2.3876183 , 4.440781  ,<br>       1.6769646 , 3.6686838 , 0.        , 0.        , 0.        ,<br>       4.4018536 , 3.0599968 , 0.        , 2.646227  , 4.513127  ,<br>       1.        , 0.16424567, 7.948415  , 2.2791777 , 4.057054  ,<br>       2.        , 0.        , 0.        , 0.67363834, 3.645394  ,<br>       0.25136846, 1.8742002 , 0.74671173, 4.585761  , 0.66469884,<br>       1.6343927 , 0.        , 0.9501083 , 9.39395   , 0.        ],<br>      dtype=float32)<br>  array([ 5.2303033,  3.398737 ,  0.       ,  3.7024248,  4.825684 ,<br>        6.3753657,  0.       ,  2.3967223,  3.570145 ,  2.7877963,<br>        2.67991  ,  0.       ,  0.       ,  3.125414 ,  1.5916126,<br>        3.8564463,  1.4738425, 10.70936  ,  3.1851664,  7.136737 ,<br>        1.9078373, 10.745646 ,  3.6944306,  1.1660497,  0.       ,<br>        5.3501906,  2.4445841,  1.090338 ,  0.       ,  2.5494943],<br>      dtype=float32)]]</p>
</blockquote>
<blockquote>
<p>R_all[0]:<br>[array([1.6848972 , 0.        , 0.        , 3.398359  , 2.530793  ,<br>       1.0050455 , 2.9787443 , 0.6477883 , 2.556338  , 0.73463535,<br>       1.        , 0.        , 0.        , 0.        , 0.        ,<br>       2.        , 0.        , 2.7559242 , 0.47480136, 2.2723987 ,<br>       1.040998  , 0.63076216, 0.12816067, 1.9125026 , 3.1089356 ,<br>       0.04926831, 2.5731335 , 0.        , 0.        , 3.6136327 ,<br>       2.1885748 , 5.271537  , 2.4973857 , 2.3315785 , 0.4876842 ,<br>       2.5446043 , 2.8961205 , 2.2814133 , 2.7040894 , 0.        ,<br>       1.        , 0.40623373, 3.410592  , 0.04632151, 1.6073561 ,<br>       3.6362302 , 0.71310234, 0.807002  , 0.43683317, 0.69910496],<br>      dtype=float32)<br> array([2.620739  , 0.        , 1.3929726 , 0.6371676 , 0.        ,<br>       1.        , 5.4475865 , 2.6643863 , 3.880937  , 4.7303853 ,<br>       0.05517461, 5.2109375 , 0.        , 0.        , 0.        ,<br>       0.98558354, 4.7299247 , 0.        , 3.8981698 , 3.6492205 ,<br>       1.        , 0.        , 6.190553  , 0.956293  , 3.5290947 ,<br>       2.        , 0.        , 1.8282684 , 0.32657242, 2.6781952 ,<br>       3.        , 0.69895065, 5.339527  , 0.        , 0.        ,<br>       5.5791173 , 0.        , 0.11749397, 7.2194476 , 0.714684  ],<br>      dtype=float32)<br> array([6.9061866 , 6.52601   , 0.        , 0.        , 4.5311055 ,<br>       7.437533  , 0.        , 2.2622852 , 3.6607296 , 0.        ,<br>       1.        , 1.1706101 , 2.0249732 , 2.5909576 , 1.5096041 ,<br>       5.1143856 , 0.        , 7.4348016 , 8.265553  , 4.404272  ,<br>       1.        , 8.330065  , 6.1199856 , 1.8026098 , 0.        ,<br>       2.1523745 , 4.295476  , 0.        , 0.25838286, 4.181186  ],<br>      dtype=float32)]</p>
</blockquote>
<h2 id="3-numpy-append"><a href="#3-numpy-append" class="headerlink" title="3. numpy.append()"></a>3. <strong>numpy.append()</strong></h2><p>append(arr, values, axis=None)<br>参数说明：<br>arr：array_like的数据<br>values: array_like的数据，若axis为None，则先将arr和values进行ravel扁平化,再拼接；否则values应当与arr的shape一致，或至多<br>        在拼接axis的方向不一致<br>axis：进行append操作的axis的方向，默认无</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = np.append(ar1, ar2)    <span class="comment"># 先ravel扁平化再拼接，所以返回值为一个1维数组</span></span><br><span class="line"></span><br><span class="line">v2 = np.append(ar1, ar2, axis=<span class="number">0</span>)     <span class="comment"># 沿第一个轴拼接，这里为行的方向 </span></span><br><span class="line"></span><br><span class="line">v3 = np.append(ar1, ar2, axis=<span class="number">1</span>)     <span class="comment"># 沿第二个轴拼接，这里为列的方向 </span></span><br><span class="line"></span><br><span class="line">print(v1)</span><br><span class="line">print(v2)</span><br><span class="line">print(v3)</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<blockquote>
<p>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 11, 12, 13])<br>array([[ 1,  2,  3],<br>       [ 4,  5,  6],<br>       [ 7,  8,  9],<br>       [11, 12, 13]])<br>array([[ 1,  2,  3,  7,  8,  9],<br>       [ 4,  5,  6, 11, 12, 13]])</p>
</blockquote>
]]></content>
      <categories>
        <category>大创</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python全局变量与传参</title>
    <url>/2020/11/22/Python%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<ol>
<li><p>值传递</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(a , b)</span> :</span></span><br><span class="line"> <span class="comment"># 下面代码实现a、b变量的值交换</span></span><br><span class="line"> a, b = b, a</span><br><span class="line"> print(<span class="string">"swap函数里，a的值是"</span>, \</span><br><span class="line">     a, <span class="string">"；b的值是"</span>, b)</span><br><span class="line"> a = <span class="number">6</span></span><br><span class="line"> b = <span class="number">9</span></span><br><span class="line"> swap(a , b)</span><br><span class="line"> print(<span class="string">"交换结束后，变量a的值是"</span>, \</span><br><span class="line">     a , <span class="string">"；变量b的值是"</span>, b)</span><br></pre></td></tr></table></figure>

<p> 运行上面程序，将看到如下运行结果：</p>
<blockquote>
<p>swap函数里，a的值是 9 ；b的值是 6<br>交换结束后，变量a的值是 6 ；变量b的值是 9</p>
</blockquote>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/202011221616078.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>可以采用全局变量方式。在函数中定义<code>global a, b</code></p>
<ol start="2">
<li>python传入的参数在函数中发生变化，在函数外也会发生变化。看起来是引用传递，底层实现还是值传递。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(S, x)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> S[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">                S[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                S[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">s = np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line">test(s, <span class="number">2</span>)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
 结果：<blockquote>
<p>[[1 0 1]<br> [1 1 1]]</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>大创</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet和Servlet容器的关系</title>
    <url>/2021/03/11/Servlet%E5%92%8CServlet%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><ul>
<li>servlet是Java编写的服务端程序，与协议和平台无关。</li>
<li>servlet功能：接收http请求，产生动态http响应。</li>
</ul>
<h3 id="Servlet和Servlet容器的关系"><a href="#Servlet和Servlet容器的关系" class="headerlink" title="Servlet和Servlet容器的关系"></a>Servlet和Servlet容器的关系</h3><p><img src="https://img-blog.csdnimg.cn/20210311132822894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Servlet和Servlet容器有点像枪和子弹的关系。彼此依存，又独立发展，通过标准化<strong>接口</strong>来协作。</p>
<ul>
<li>真正管理 Servlet 的容器是 Context 容器，一个Context容器对应一个web工程。* Context容器直接管理Servlet在容器中的包装类Wrapper。</li>
<li>Servlet 被 <strong>解析</strong>和<strong>包装</strong>成 <strong>Context 容器中的 StandardWrapper</strong>。<blockquote>
<p>StandardWrapper 是 Tomcat 容器中的一部分，具有容器特征。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Servlet容器</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语言</title>
    <url>/2021/02/05/SQL%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>SQL是结构化查询语言（Structured Query Language），具有定义、查询、更新、控制等多种功能，是<strong>关系数据库</strong>的标准语言。</p>
<h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><ul>
<li>数据操作语言<strong>DML</strong>(Manipulation) ：针对表里面的数据<br>· SELECT INSERT UPDATE DELETE</li>
<li>数据定义语言<strong>DDL</strong>（definition）：针对表结构<br>· CREATE ALTER DROP RENAME TRUNCATE</li>
<li>数据控制语言<strong>DCL</strong>（control）：用户访问和权限控制</li>
<li>· GRANT REVOKE</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>在PLSQL的sql window窗口中，<code>--</code>和/**/是注释。</p>
<h3 id="查表和默认表字段含义"><a href="#查表和默认表字段含义" class="headerlink" title="查表和默认表字段含义"></a>查表和默认表字段含义</h3><p>▪ select * from tab;//查看用户下的所有表<br>▪ select * from user_tables;//详细查询当前用户下的所有表<br>▪ –desc 表名； //查看表结构 表字段的含义，类型等<br>▪ 查看所有表：select table_name from user_tables;<br>▪ 查看表结构：describe dept;(戒者desc dept;)<br>▪ <font color="red">emp表-&gt;雇员表(employee)</font><br>&emsp;– Empno: 雇员工号 Ename: 雇员名字<br>&emsp;– Job:工作（秘书、销售、经理、分析员、保管）<br>&emsp;– Mgr(manager):经理的工号<br>&emsp;– Hiredate:雇用日期<br>&emsp;– Sal: 工资<br>&emsp;– Comm: 津贴<br>&emsp;– Deptno: 所属部门号<br>▪ <font color="red">dept表-&gt;部门表（department）</font><br>&emsp;– Deptno:部门号<br>&emsp;– Dname:部门名字<br>&emsp;– Loc: 地址<br>▪ <font color="red">salgrade表-&gt;一个公司是有等级制度，用此表表示一个工资的等级</font><br>&emsp;– Grade:等级<br>&emsp;– losal:最低工资<br>&emsp;– hisal:最高工资<br>▪ <font color="red">bonus表-&gt; 奖金表：表示一个雇员的工资及奖金</font><br>&emsp;– Ename:雇员名字， job:工作，<br>&emsp;– sal: 工资 comm:津贴</p>
<h3 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h3><p>▪ 为表添加注释 comment on table emp is ‘雇员表’;</p>
<p>▪ 为列添加注释comment on column emp.ename is ‘雇员姓名’;</p>
<p>注：一般建表不会用，因为有数据字典。</p>
<h3 id="Select查询"><a href="#Select查询" class="headerlink" title="Select查询"></a>Select查询</h3><p>▪ Select-from-where句型<br>▪ SELECT [DISTINCT] {*,column alias,..}<br>&emsp;FROM table alias<br>&emsp;Where 条件表达式</p>
<p>▪ alias<br>&emsp;– Column alias<br>&emsp;– Column “alias”<br>&emsp;– Column as alias </p>
<p><strong>select</strong><br>▪ 检索单个列<br>&emsp;– select col from tableName;<br>▪ 检索多个列<br>&emsp;– select col1, col2,col3 from tableName;<br>▪ 检索所有列<br>&emsp;– select * from tableName; （<font color="red">最好不要用*</font>）<br>&emsp;– 使用通配符的优点：书写方便、可以检索未知列<br>&emsp;– 使用通配符的缺点：降低检索的性能<br>▪ 给检索出的列起个别名<br>&emsp;– select job “gong zuo” from emp;<br>&emsp;– select job as “gong zuo” from emp;</p>
<p><strong>表别名</strong><br>▪ Select e.* from emp e;<br>▪ Select e.empno,e.deptno from emp e;<br><font color="red">最好写上！</font></p>
<p><strong>distinct去重</strong><br>▪ distinct必须放在开头<br>▪ 多字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询雇员表中部门编号是10的员工</span></span><br><span class="line"><span class="keyword">select</span> empno,ename,job <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span>;</span><br><span class="line"><span class="comment">--distinct去重 查询雇员表中拥有的部门编号</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">--在查询过程中可以给列添加别名，同时也可以给表添加别名</span></span><br><span class="line"><span class="comment">--去重也可以针对多个字段，多个字段值只要有一个不匹配就算是不同的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> deptno,Sal <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> e.empno 雇员编号，e.ename 雇员名称, e.job 雇员工作 <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno = <span class="number">10</span>;</span><br><span class="line"><span class="comment">--给列起别名可以加as也可以不加</span></span><br><span class="line"><span class="keyword">select</span> e.empno <span class="keyword">as</span> 雇员编号，e.ename <span class="keyword">as</span> 雇员名称, e.job <span class="keyword">as</span> 雇员工作 <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno = <span class="number">10</span>;</span><br><span class="line"><span class="comment">--给列起别名，如果别名中包含空格，那么要将别名整体用“”包含起来</span></span><br><span class="line"><span class="keyword">select</span> e.empno <span class="string">"雇员 编号"</span>，e.ename <span class="string">"雇员 名称"</span>, e.job <span class="string">"雇员 工作"</span> <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno = <span class="number">10</span>;</span><br><span class="line"><span class="comment">--查询表中所有字段,可以使用*，但是在项目中千万不要随便使用*！</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><h4 id="条件比较"><a href="#条件比较" class="headerlink" title="条件比较"></a>条件比较</h4><p>– ＝，！＝,&lt;&gt;，&lt;,&gt;,&lt;=,&gt;=,any,some,all<br>– is null,is not null<br>– between x and y<br>– in（list），not in（list）<br>– exists（sub－query）<br>– like _ ,%,escape ‘&#39;</p>
<p><strong>＝，！＝,&lt;&gt;，&lt;,&gt;,&lt;=,&gt;=,any,some,all</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- =</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">20</span>;</span><br><span class="line"><span class="comment">-- !=</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno != <span class="number">20</span>;</span><br><span class="line"><span class="comment">-- &lt;&gt; 不等于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno &lt;&gt; <span class="number">20</span>;</span><br><span class="line"><span class="comment">-- &lt;,</span></span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal &lt; <span class="number">1500</span>;</span><br><span class="line"><span class="comment">-- &gt;,</span></span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="number">1500</span>;</span><br><span class="line"><span class="comment">-- &lt;=,</span></span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal &lt;= <span class="number">1500</span>;</span><br><span class="line"><span class="comment">-- &gt;=,</span></span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;= <span class="number">1500</span>;</span><br><span class="line"><span class="comment">--any,取其中任意一个</span></span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="keyword">any</span>(<span class="number">1000</span>,<span class="number">1500</span>,<span class="number">3000</span>);</span><br><span class="line"><span class="comment">--some,跟any效果一样</span></span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="keyword">some</span>(<span class="number">1000</span>,<span class="number">1500</span>,<span class="number">3000</span>);</span><br><span class="line"><span class="comment">--all,所有的值满足才会成立</span></span><br><span class="line"><span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="keyword">all</span>(<span class="number">1000</span>,<span class="number">1500</span>,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>is null,is not null</strong><br>在sql语句中，null表示一个特殊含义，<font color="red">null != null</font>，必须使用is null或者is not null 判断。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--is null</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> comm = <span class="literal">null</span>; <span class="comment">--运行结果为空</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> comm <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">--is not null</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> comm <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">--运行结果为空</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="literal">null</span> <span class="keyword">is</span> <span class="literal">null</span>; <span class="comment">--可以显示emp所有值</span></span><br></pre></td></tr></table></figure>

<p><strong>between x and y</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--between x and y, [x,y]</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">between</span> <span class="number">1500</span> <span class="keyword">and</span> <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;= <span class="number">1500</span> <span class="keyword">and</span> sal &lt;=<span class="number">3000</span> <span class="comment">--等价</span></span><br></pre></td></tr></table></figure>

<p><strong>in（list），not in（list）</strong><br>需要进行某些值的等值判断的时候，可以使用in和not in。如果里面是字符串，用单引号括起来<br>也可以使用and 和 or这样的关键字，and相当于与，or相当于或操作。一个语句中，要注意优先级。<font color="red">and的优先级高于or</font>，所以一定要将or的相关操作用括号括起来</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--in(list)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="keyword">in</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">or</span> deptno = <span class="number">20</span>; <span class="comment">--等价</span></span><br><span class="line"><span class="comment">--not in(list)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="keyword">not</span> <span class="keyword">in</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno != <span class="number">10</span> <span class="keyword">and</span> deptno != <span class="number">20</span>;<span class="comment">--等价</span></span><br></pre></td></tr></table></figure>

<p><strong>exists（sub－query）</strong><br>exists(sub-query),当exists中的子查询语句能查到对应结果的时候，<br>意味着条件满足，相当于<font color="red">双重for循环</font>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">现在要查询部门编号为10和20的员工，要求使用exists实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">--正确</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">or</span> deptno = <span class="number">20</span>;</span><br><span class="line"><span class="comment">--错误,会查到所有的结果.因为子查询不管怎么查都会出现10和20这两个值</span></span><br><span class="line"><span class="comment">--既然能查到结果，意味着条件满足，所以每一条记录都会被查出结果。</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> emp</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> deptno</span><br><span class="line">          <span class="keyword">from</span> dept</span><br><span class="line">         <span class="keyword">where</span> deptno = <span class="number">10</span></span><br><span class="line">            <span class="keyword">or</span> deptno = <span class="number">20</span>);</span><br><span class="line"><span class="comment">--通过外层循环来规范内层循环</span></span><br><span class="line"><span class="comment">--错误,依旧查出全部结果。因为and优先级高</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> emp e</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> deptno d</span><br><span class="line">          <span class="keyword">from</span> dept d</span><br><span class="line">         <span class="keyword">where</span> d.deptno = <span class="number">10</span></span><br><span class="line">            <span class="keyword">or</span> d.deptno = <span class="number">20</span></span><br><span class="line">           <span class="keyword">and</span> e.deptno = d.deptno);</span><br><span class="line"><span class="comment">--正确</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> emp e</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> deptno d</span><br><span class="line">          <span class="keyword">from</span> dept d</span><br><span class="line">         <span class="keyword">where</span> (d.deptno = <span class="number">10</span> <span class="keyword">or</span> d.deptno = <span class="number">20</span>)</span><br><span class="line">           <span class="keyword">and</span> e.deptno = d.deptno);</span><br></pre></td></tr></table></figure>

<p><strong>like,_ ,%,escape</strong><br>模糊查询<br>在like语句中，需要使用占位符或者通配符:<br>&emsp;<code>_</code>，某个字符或者数字只出现一次<br>&emsp;<code>%</code>，任意字符出现任意次数<br>&emsp;escape，使用转义字符，可以自己规定转义字符<br><strong>注意</strong>：<br>使用like的时候要慎重，因为like的效率比较低<br>使用like可以参考使用索引，但是要求不能以%开头<br>涉及到大文本的检索的时候，可以使用某些框架 luence，solr，elastic search</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询名字以S开头的用户</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span>(<span class="string">'S%'</span>);</span><br><span class="line"><span class="comment">--查询名字以S开头且倒数第二个字符为T的用户</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> (<span class="string">'S%T_'</span>);</span><br><span class="line"><span class="comment">--查询名字中带%的人的用户</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> (<span class="string">'%a%%'</span>) escape(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="逻辑复合条件"><a href="#逻辑复合条件" class="headerlink" title="逻辑复合条件"></a>逻辑复合条件</h4><p>– not，（and，or） and优先级高</p>
<p><strong>例子</strong>：<br>列出deptno为10或者30，幵且工资&gt;2000的所有人。<br><code>select * from Emp where deptno=30 or deptno=10 and sal&gt;2000;</code><br>这个命令列出的人中薪水有&lt;2000的，为什么？<br>&emsp;and优先级高，or要加括号。<br>&emsp;计算次序问题的解决，最好用括号进行分组处理</p>
<h4 id="SQL优化问题"><a href="#SQL优化问题" class="headerlink" title="SQL优化问题"></a>SQL优化问题</h4><p>– AND: 把检索结果较少的条件放到后面<br>– OR: 把检索结果较多的条件放到后面</p>
<h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>▪ 按照单个列排序<br>&emsp;– order by col<br>▪ 降序和升序：<br>&emsp;– order by col desc (asc)<br>▪ 按多个列排序（优先级）<br>&emsp;– order by col1 desc(asc), col2 desc(asc)</p>
<p>order by进行排序默认升序操作<br><code>asc</code>：默认的排序方式，升序<br><code>desc</code>：降序<br>按照自然顺序进行排序的。数值从大到小；字符串按照字典序（ASCII码）<br><strong>A~Z在a~z前</strong></p>
<p>在进行排序的时候，可以指定多个字段，而且多个字段可以采用不同的排序方式<br>每次在执行order by的时候，相当于是做了全排序，思考全排序的效率。<br>所以这些耗费内存的操作最好放到业务不太繁忙的时候进行，使用的时候一定要慎重。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>; </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> ename;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>, ename <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<h3 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h3><p>▪ 为什么需要计算字段？<br>&emsp;我们经常需要直接从数据库中检索出转换、计算或格式化过的数据；<br>&emsp;而不是检索出数据，然后再在客户机应用程序中重新格式化。<br>▪ 计算字段并不实际存在于数据库表<br>▪ Sql允许select子句中出现+,-,*,/以及列名和常数的表达式<br>▪ 拼接字段 <code>||</code> 也可以使用函数<code>concat(arg1,arg2)</code>，拼接arg1和arg2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'my name is '</span>||ename||<span class="string">'!'</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'my name is '</span>,ename) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h3 id="通用函数-nvl"><a href="#通用函数-nvl" class="headerlink" title="通用函数 nvl"></a>通用函数 nvl</h3><p>Sql中允许列值为空，空值用保留字NULL表示。NULL丌同不0戒者<br>空格，它就是代表了一个不确定的内容。<br><strong>注意</strong>：</p>
<ol>
<li><strong>NULL != NULL</strong>。</li>
<li><font color='red'>任何含有null值的数学表达式<strong>最后的结果都为空值</strong></font>。可以使用<code>nvl</code>函数来处理。</li>
<li>函数<code>nvl(arg1,arg2)</code>，如果arg1是空，那么返回arg2；如果不为空，则返回原来的值<br>注：两个参数的类型要相同</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算所有员工的年薪</span></span><br><span class="line"><span class="keyword">select</span> ename,(e.sal+e.comm)*<span class="number">12</span> <span class="keyword">from</span> emp e;</span><br><span class="line"><span class="comment">--null是比较特殊的存在，null做任何运算都还是为空，因此要将空做转换</span></span><br><span class="line"><span class="comment">--引入函数nvl</span></span><br><span class="line"><span class="keyword">select</span> ename,(e.sal+nvl(e.comm,<span class="number">0</span>))*<span class="number">12</span> <span class="keyword">from</span> emp e;</span><br><span class="line"><span class="comment">--dual是oracle数据库中的一张虚拟表，没有实际的数据，可以拿来做测试</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">100</span>+<span class="literal">null</span> <span class="keyword">from</span> dual; <span class="comment">-- 结果为空</span></span><br><span class="line"><span class="comment">--显示没有上级管理（mgr为null）的公司首脑  </span></span><br><span class="line"><span class="keyword">select</span> ename,nvl(to_char(mgr),<span class="string">'boss'</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> mgr <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="并集，全集，交集，差集"><a href="#并集，全集，交集，差集" class="headerlink" title="并集，全集，交集，差集"></a>并集，全集，交集，差集</h3><p>1、<strong>union all</strong> 全集<br>将2个集合的数据全显示，不去重<br>2、<strong>union</strong> 并集（去重）<br>将2个集合中所有数据都进行显示，但是不包含重复的数据<br>3.<strong>intersect</strong> 交集<br>两个集合中重复的数据集，只显示一次<br>4.<strong>minus</strong> 差集<br>包含在A集合而不包含在B集合中的数据，跟A,B顺序相关</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--A  6条</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">30</span>;</span><br><span class="line"><span class="comment">--B  12条</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="number">1000</span>;</span><br><span class="line"><span class="comment">--并集</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">30</span> <span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="number">1000</span>; <span class="comment">-- 13条</span></span><br><span class="line"><span class="comment">--全集</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">30</span> <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="number">1000</span>; <span class="comment">-- 18条</span></span><br><span class="line"><span class="comment">--交集</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">30</span> <span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="number">1000</span>; <span class="comment">-- 5条</span></span><br><span class="line"><span class="comment">--差集</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">30</span> <span class="keyword">minus</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="number">1000</span>;  <span class="comment">-- 1条</span></span><br></pre></td></tr></table></figure>

<h3 id="易错例子"><a href="#易错例子" class="headerlink" title="易错例子"></a>易错例子</h3><p>具体看GitHub代码。下面只选出部分的例子。</p>
<p>1、查询部门名称为 SALES 和 RESEARCH 的雇员姓名、工资、部门编号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--使用exists 和 in</span></span><br><span class="line"><span class="keyword">select</span> e.ename, e.sal, e.deptno</span><br><span class="line">  <span class="keyword">from</span> emp e</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> d.deptno</span><br><span class="line">          <span class="keyword">from</span> dept d</span><br><span class="line">         <span class="keyword">where</span> (d.dname <span class="keyword">in</span> (<span class="string">'SALES'</span>, <span class="string">'RESEARCH'</span>))</span><br><span class="line">           <span class="keyword">and</span> e.deptno = d.deptno);</span><br><span class="line"><span class="comment">--使用exists           </span></span><br><span class="line"><span class="keyword">select</span> e.ename, e.sal, e.deptno</span><br><span class="line">  <span class="keyword">from</span> emp e</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> d.deptno</span><br><span class="line">          <span class="keyword">from</span> dept d</span><br><span class="line">         <span class="keyword">where</span> (d.dname = <span class="string">'SALES'</span> <span class="keyword">or</span> d.dname = <span class="string">'RESEARCH'</span>)</span><br><span class="line">           <span class="keyword">and</span> e.deptno = d.deptno);</span><br><span class="line"><span class="comment">--使用in</span></span><br><span class="line"><span class="keyword">select</span> e.ename, e.sal, e.deptno</span><br><span class="line">  <span class="keyword">from</span> emp e</span><br><span class="line"> <span class="keyword">where</span> e.deptno <span class="keyword">in</span></span><br><span class="line">       (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname <span class="keyword">in</span> (<span class="string">'SALES'</span>, <span class="string">'RESEARCH'</span>));</span><br></pre></td></tr></table></figure>
<p>注意：<br>■ in中如果是字符串，用单引号括起来<br>■ in(list1,list2…) 不是in[]</p>
<p>2、查询EMP表显示所有雇员名及其全年收入(月收入=工资+补助),处理NULL行,并指定列别名为”年收入”</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,(sal+nvl(<span class="number">0</span>,comm))*<span class="number">12</span> 年收入 <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<p>注意：<br>■ 别称可以选加双引号，但不能使用单引号<br>■ 别称前可以选加<code>as</code></p>
<p>3、查询EMP表显示第2个字符为”A”的所有雇员名其工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> (<span class="string">'_A%'</span>);</span><br></pre></td></tr></table></figure>
<p>注意：<br>■ like里面有单引号</p>
<p>4、查询EMP表显示在1981年2月1日到1981年5月1日之间雇佣的雇员名、岗位及雇佣日期，并以雇佣日期进行排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename, job, hiredate</span><br><span class="line">  <span class="keyword">from</span> emp</span><br><span class="line"> <span class="keyword">where</span> hiredate <span class="keyword">between</span> <span class="keyword">to_date</span>(<span class="string">'1981/2/1'</span>, <span class="string">'yyyy/mm/dd'</span>) <span class="keyword">and</span></span><br><span class="line">       <span class="keyword">to_date</span>(<span class="string">'1981/5/1'</span>, <span class="string">'yyyy/mm/dd'</span>)</span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> hiredate;</span><br></pre></td></tr></table></figure>
<p>注意：<br>■ 日期转换函数to_date的使用</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream API</title>
    <url>/2021/02/01/Stream%20API/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day08</a></p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream是一组用来处理数组、集合的API<br>JAVA8 费大力气引入函数式编程，原因：</p>
<ol>
<li>多核友好（并行计算），JAVA函数式编程使得并行程序非常简单，就是需要调用一下<code>parallel()</code>方法。</li>
<li>代码简洁。函数式编程写出的代码简洁且意图明确，使用Stream接口让你从此告别for循环。</li>
</ol>
<p><strong>特性</strong>:</p>
<ol>
<li>不是数据结构，没有内部存储<br>集合中进行了非常多操作，中间的迭代过程是不支持数据存储的。分为中间操作和执行操作，只有进行执行算子，整个流才会执行</li>
<li>不支持索引访问</li>
<li>延迟计算</li>
<li>支持并行</li>
<li>很容易生成数组或集合</li>
<li>支持过滤、查找、转换、汇总、聚合等操作</li>
</ol>
<p><strong>注</strong>：</p>
<ul>
<li>Stream分为：<strong>源source</strong>，<strong>中间操作</strong>，<strong>终止操作</strong></li>
<li>流的源可以是一个数组、一个集合、一个生成器方法、一个I/O通道等待</li>
<li>一个流可以有0或多个中间操作，每个中间操作返回一个新的流，供下一个操作使用</li>
<li>一个流只有一个终止操作。Stream只有遇到终止操作，它的源才会开始执行遍历操作</li>
</ul>
<h5 id="Stream的创建"><a href="#Stream的创建" class="headerlink" title="Stream的创建"></a>Stream的创建</h5><ol>
<li>通过数组生成</li>
<li>通过集合生成</li>
<li>通过Stream.generate()</li>
<li>通过Stream.iterate()</li>
<li>其他API创建<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过数组生成</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">        <span class="comment">// 数组转换为一个Stream</span></span><br><span class="line">        Stream&lt;String&gt; strs1 = Stream.of(strs);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * forEach参数是Consumer&lt;? super T&gt; action</span></span><br><span class="line"><span class="comment">         * Consumer&lt;T&gt;代表一个输入的函数式接口</span></span><br><span class="line"><span class="comment">         * System.out::println是一个实例方法引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        strs1.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过集合生成</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过generate()</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  generate()返回无限顺序无序流，其中每个元素是由提供的Supplier，无限循环</span></span><br><span class="line"><span class="comment">         *  Supplier，代表一个输出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; generate = Stream.generate(() -&gt; <span class="number">0</span>);</span><br><span class="line">        generate.limit(<span class="number">3</span>).forEach(System.out::println); <span class="comment">// 限制3次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用iterator</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * iterate()参数是UnaryOperator&lt;T&gt; f，无限循环</span></span><br><span class="line"><span class="comment">         * UnaryOperator&lt;T&gt; f，一个输入一个输出，类型相同</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream&lt;Integer&gt; iterate = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">1</span>);</span><br><span class="line">        iterate.limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方式</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gen5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"abcd"</span>;</span><br><span class="line">        IntStream stream = str.chars();</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        gen1();</span><br><span class="line">        gen2();</span><br><span class="line">        gen3();</span><br><span class="line">        gen4();</span><br><span class="line">        gen5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details><summary>结果：</summary>
<pre><code>a
b
c
d
1
2
3
4
0
0
0
1
2
3
97
98
99
100</code></pre>
</details>

</li>
</ol>
<h5 id="Stream常用API"><a href="#Stream常用API" class="headerlink" title="Stream常用API"></a>Stream常用API</h5><p>中间操作:如果返回值是Stream对象，意味着是中间操作<br>延迟操作可以省掉很多临时存储的空间</p>
<details><summary>StreamDemo.java</summary>
<pre><code>public static void main(String[] args) {
    //------中间操作:如果返回值是Stream对象，意味着是中间操作
    // 取出偶数
    Arrays.asList(1,2,3,4,5).stream()
            .filter((x)->x % 2 == 0).forEach(System.out::println);
    // 求出结果集中的所有偶数的和
    long count = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9).stream()
            .filter(x -> x % 2 == 0).mapToInt(x->x).sum();
    System.out.println(count);
    // 求集合中最大值
    List<Integer> list = Arrays.asList(7,1,2,3,4,5,6);
    Optional<Integer> max = list.stream().max((a, b) -> a - b);
    System.out.println(max.get());
    // 求集合中最小值
    System.out.println(list.stream().min((a,b)->a-b).get());

<pre><code>Optional&lt;Integer&gt; any = list.stream().filter(x -&gt; x % 2 == 0).findAny();
System.out.println(any.get());

// 如果没有这个值会报错：no value present
Optional&lt;Integer&gt; first = list.stream().filter(x -&gt; x % 2 == 0).findFirst();
System.out.println(first.get());

Stream&lt;Integer&gt; integerStream = list.stream().filter(i -&gt; {
    System.out.println(&quot;运行代码&quot;); // 不会被打印  延迟执行 一直等于stream一直不执行
    return i % 2 == 0;
});
System.out.println(integerStream);
System.out.println(integerStream.findAny().get());
System.out.println(&quot;---------------&quot;);
    //获取最大值和最小值，但是不使用min和max方法
    Optional&lt;Integer&gt; min = list.stream().sorted().findFirst();
    System.out.println(min.get());
    Optional&lt;Integer&gt; max2 = list.stream().sorted((a,b)-&gt;b-a).findFirst();
    System.out.println(max2.get());

    //按照自然序排序
    Arrays.asList(&quot;java&quot;,&quot;c#&quot;,&quot;python&quot;,&quot;scala&quot;,&quot;jee&quot;).stream().sorted().forEach(System.out::println);
    //按照长度排序
    System.out.println(&quot;+++++++++++&quot;);
    Arrays.asList(&quot;java&quot;,&quot;c#&quot;,&quot;python&quot;,&quot;scala&quot;,&quot;jee&quot;).stream().sorted((a,b)-&gt;a.length()-b.length()).forEach(System.out::println);
    System.out.println(&quot;=============&quot;);
    // 想将集合中的元素进行过滤同时返回一个集合对象
    List&lt;Integer&gt; collect = list.stream().filter(x -&gt; x % 2 == 0).collect(Collectors.toList());
    collect.forEach(System.out::println);
    // 去重操作
    Arrays.asList(1,2,2,3,3,3,4,5,2).stream().distinct().forEach(System.out::print);
    System.out.println();
    Arrays.asList(1,2,2,3,3,3,4,5,2).stream().collect(Collectors.toSet()).forEach(System.out::print);
    System.out.println();
    // 打印20~30这样的集合数据
    Stream.iterate(1,x-&gt;x+1).limit(50).skip(20).limit(10).forEach(System.out::print);
    System.out.println();
    // 字符串值求和
    String str = &quot;11,22,33,44,55&quot;;
    System.out.println(Stream.of(str.split(&quot;,&quot;)).mapToInt(x -&gt; Integer.valueOf(x)).sum());
    System.out.println(Stream.of(str.split(&quot;,&quot;)).mapToInt(Integer::valueOf).sum());
    System.out.println(Stream.of(str.split(&quot;,&quot;)).map(x -&gt; Integer.valueOf(x)).mapToInt(x -&gt; x).sum());
    System.out.println(Stream.of(str.split(&quot;,&quot;)).map(Integer::valueOf).mapToInt(x -&gt; x).sum());

    // 创建一组自定义对象
    String str2 = &quot;java,scala,python&quot;;
    Stream.of(str2.split(&quot;,&quot;)).map(x-&gt;new Person(x)).forEach(System.out::print);
    System.out.println();
    Stream.of(str2.split(&quot;,&quot;)).map(Person::new).forEach(System.out::print);
    System.out.println();
    Stream.of(str2.split(&quot;,&quot;)).map(x-&gt;Person.build(x)).forEach(System.out::print);
    System.out.println();
    Stream.of(str2.split(&quot;,&quot;)).map(Person::build).forEach(System.out::print);
    // 将str中每个数值都打印出来同时算出最终的求和结果
    // peek(IntConsumer action)返回由该流的元素组成的流，另外在从生成的流中消耗元素时对每个元素执行提供的操作
    System.out.println(Stream.of(str.split(&quot;,&quot;)).peek(System.out::println).mapToInt(Integer::valueOf).sum());

    // list：{7,1,2,3,4,5,6}
    // allMatch(IntPredicate predicate)返回此流的所有元素是否与提供的谓词匹配
    System.out.println(list.stream().allMatch(x -&gt; x % 2 == 0));
    System.out.println(list.stream().anyMatch(x -&gt; x % 2 == 0)); // 任何一个true</code></pre><p>}</code></pre></p>
</details>
<details><summary>Person.java</summary>
<pre><code>2
public class Person {
    private String name;
    public Person(String name) {
        this.name = name;
    }
    public Person() {
    }
    public static Person build(String name) {
        Person p = new Person();
        p.setName(name);
        return p;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                '}';
    }
}</code></pre>
</details>
<details><summary>结果</summary>
<pre><code>2
4
20
7
1
2
2
java.util.stream.ReferencePipeline$2@312b1dae
运行代码
运行代码
运行代码
2
---------------
1
7
c#
java
jee
python
scala
+++++++++++
c#
jee
java
scala
python
=============
2
4
6
12345
12345
21222324252627282930
165
165
165
165
Person{name='java'}Person{name='scala'}Person{name='python'}
Person{name='java'}Person{name='scala'}Person{name='python'}
Person{name='java'}Person{name='scala'}Person{name='python'}
Person{name='java'}Person{name='scala'}Person{name='python'}
22
33
44
55
165
false
true
</code></pre>
</details>]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>JDK新特性</category>
      </categories>
      <tags>
        <tag>JDK新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>StringUtils工具类的使用</title>
    <url>/2021/02/04/StringUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day04</a></p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>1.public static int <code>countLength</code>(String string)<br>计算给定的字符串的长度，计算规则是：一个汉字的长度为2，一个字符的长度为1</p>
<p>2.public static String <code>capitalizeFirstLetter</code>(String str)<br>如果第一个字符是字母，则将它变成大写返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.capitalizeFirstLetter(<span class="string">"a1d a"</span>)); <span class="comment">// A1d a</span></span><br></pre></td></tr></table></figure>

<p>3.public static String <code>checkLength</code>(String string, int maxLength, String appendString) {<br>检查字符串长度，如果字符串的长度超过maxLength，就截取前maxLength个字符串并在末尾拼上appendString</p>
<p>&emsp;public static String checkLength(String string, int maxLength) 检查字符串长度，如果字符串的长度超过maxLength，就截取前maxLength个字符串并在末尾拼上<code>…</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.checkLength(<span class="string">"abc"</span>,<span class="number">2</span>,<span class="string">"ee"</span>)); <span class="comment">// abee</span></span><br></pre></td></tr></table></figure>

<p>4.public static String <code>filterBlank</code>(String string)<br>空白过滤.如果给定的字符串是””，那么返回null；否则返回本身</p>
<p>5.public static String <code>filterEmpty</code>(String string)<br>如果字符串是null或者空就返回””</p>
<p>6.public static String <code>firstLetterToLowerCase</code>(String str)<br>将给定字符串的首字母转为小写<br>&emsp;<code>firstLetterToUpperCase</code>类似，将给定字符串的首字母转为大写</p>
<p>7.public static String <code>fullWidthToHalfWidth</code>(String s)<br>全角转换为半角 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.fullWidthToHalfWidth(<span class="string">"a，b"</span>)); <span class="comment">// a,b</span></span><br></pre></td></tr></table></figure>

<p>8.public static String <code>getHrefInnerHtml</code>(String href)<br>返回一个html</p>
<p>9.public static String <code>htmlEscapeCharsToString</code>(String source)<br>返回htmL到字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.htmlEscapeCharsToString(<span class="string">"&amp;lt;"</span>)); <span class="comment">// &lt;</span></span><br></pre></td></tr></table></figure>

<p>10.public static String <code>halfWidthToFullWidth</code>(String s)<br>半角转换为全角</p>
<p>11.public static String <code>htmlRemoveTag</code>(String inputString)<br>删除Html标签，返回文本字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.htmlRemoveTag(<span class="string">"&lt;br/&gt;he"</span>)); <span class="comment">// he</span></span><br></pre></td></tr></table></figure>

<p>12.public static boolean <code>isEmpty</code>(CharSequence str)<br>如果str是 null 或者 长度为0，返回true</p>
<p>&emsp;public static boolean isEmpty(String string)<br>如果str是 null 或者 长度为0 或者 由空格组成，返回true<br>&emsp;public static boolean <code>isNotEmpty</code>(String string)<br>字符串不为null且不为空，返回true</p>
<p>&emsp;public static boolean isEmpty(String… strings)<br>如果给定的字符串数组中的所有字符串都为 null 或者 是空的，返回true<br>&emsp;public static boolean isNotEmpty(String… strings)<br>给定的字符串数组中的所有字符串全部都不为null且不为空，返回true</p>
<blockquote>
<p><strong>String 和 CharSequence关系</strong><br>String 继承于CharSequence，也就是说String也是CharSequence类型。<br>CharSequence是一个接口，它只包括length(), charAt(intindex), subSequence(int start, int end)这几个API接口。除了String实现了CharSequence之外，StringBuffer和StringBuilder也实现了 CharSequence接口。<br>需要说明的是，CharSequence就是字符序列，String, StringBuilder和StringBuffer本质上都是通过字符数组实现的！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.isEmpty(<span class="string">" "</span>)); <span class="comment">// true</span></span><br><span class="line">CharSequence s1 = <span class="keyword">new</span> String(<span class="string">" "</span>);</span><br><span class="line">System.out.println(StringUtils.isEmpty(s1));<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>13.public static boolean <code>isBlank</code>(String str)<br>如果str是 null 或者 【长度为0 或者 由空格组成】(是空的)，返回true，否则返回false。</p>
<p>14.public static boolean <code>isAllDigital</code>(char[] chars)<br>是否全是数字</p>
<p>15.public static int <code>length</code>(CharSequence str)<br>获得str长度</p>
<p>16.public static String <code>MD5</code>(String string)<br>将给定的字符串MD5加密</p>
<p>17.public static String <code>nullStrToEmpty</code>(Object str)<br>如果str为null，返回””<br>如果str不是String的实例，将str转换为String类型并返回</p>
<p>18.public static String <code>removeChar</code>(String string, char ch)<br>删除给定字符串中所有的旧的字符</p>
<p>&emsp;public static String removeChar(String string, int index)<br>删除给定字符串中给定位置处的字符</p>
<p>&emsp;public static String removeChar(String string, int index, char ch)<br>删除给定字符串中给定位置处的字符,位置处字符不等于ch，不删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.removeChar(<span class="string">"avvc"</span>,<span class="string">'v'</span>)); <span class="comment">// ac</span></span><br><span class="line">System.out.println(StringUtils.removeChar(<span class="string">"avvc"</span>,<span class="number">3</span>)); <span class="comment">// avv</span></span><br><span class="line">System.out.println(StringUtils.removeChar(<span class="string">"avvc"</span>,<span class="number">3</span>,<span class="string">'c'</span>)); <span class="comment">// avv</span></span><br></pre></td></tr></table></figure>

<p>19.public static String <code>replaceBlanktihuan</code>(String str)<br>特殊字符串切换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.replaceBlanktihuan(<span class="string">"a b\tc"</span>)); <span class="comment">// abc</span></span><br></pre></td></tr></table></figure>

<p>20.public static String <code>replace</code>(String string, char oldchar, char newchar)<br>在给定的字符串string中，用新的字符替换所有旧的字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.replace(<span class="string">"accd"</span>,<span class="string">'c'</span>,<span class="string">'e'</span>)); <span class="comment">// aeed</span></span><br></pre></td></tr></table></figure>

<p>21.public static boolean <code>startsWithIgnoreCase</code>(String sourceString, String newString)<br>忽略大小写，给定的字符串以一个特定的字符串开头，返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.startsWithIgnoreCase(<span class="string">" abc"</span>,<span class="string">" ab"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>&emsp;<code>endsWithIgnoreCase</code>类似，判断是否是特定字符串结尾</p>
<p>22.public static String[] <code>split</code>(String string, char ch)<br>把给定的字符串用给定的字符分割</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String s3 : StringUtils.split(<span class="string">"abbd"</span>, <span class="string">'b'</span>)) &#123;</span><br><span class="line">    System.out.print(s3+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a  d</span></span><br></pre></td></tr></table></figure>

<p>23.public static String <code>htmlRemoveTag</code>(String inputString)<br>删除Html标签，返回文本字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.htmlRemoveTag(<span class="string">"&lt;br/&gt;he"</span>)); <span class="comment">// he</span></span><br></pre></td></tr></table></figure>

<p>24.public static String <code>toLowerCase</code>(String str, int beginIndex, int endIndex)<br>将给定字符串中给定的区域的字符转换成小写(左闭右开)<br>&emsp;<code>toUpperCase</code>类似，转换为大写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(StringUtils.toUpperCase(<span class="string">"abc"</span>,<span class="number">0</span>,<span class="number">1</span>)); <span class="comment">// Abc</span></span><br></pre></td></tr></table></figure>

<p>25.public static String <code>utf8Encode</code>(String str)<br>返回一个utf8的字符串</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>异常+常用类</category>
      </categories>
      <tags>
        <tag>StringUtils</tag>
      </tags>
  </entry>
  <entry>
    <title>String和StringBuffer用final修饰</title>
    <url>/2021/03/11/String%E5%92%8CStringBuffer%E7%94%A8final%E4%BF%AE%E9%A5%B0/</url>
    <content><![CDATA[<ol>
<li>String和StringBuffer都用<strong>final</strong>修饰，底层都是通过<strong>字符数组</strong>实现。</li>
<li>String底层的字符数组被final修饰，所以值不能更改；StringBuffer底层的字符数组没被final修饰，所以值能更改。</li>
<li>如果final修饰的是基本数据类型，值不能变；如果是引用类型，地址不能变，值可以变。</li>
<li>final修饰类（比如String和StringBuffer），只是限定类不可被继承，而非限定了其对象是否可变</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>StringBuffer</tag>
      </tags>
  </entry>
  <entry>
    <title>VS2017第一次c++环境配置后创建cpp文件运行时报错：未将对象引用设置到对象的实例</title>
    <url>/2020/06/25/VS2017%E7%AC%AC%E4%B8%80%E6%AC%A1c-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%90%8E%E5%88%9B%E5%BB%BAcpp%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8A%A5%E9%94%99%EF%BC%9A%E6%9C%AA%E5%B0%86%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E8%AE%BE%E7%BD%AE%E5%88%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p><strong>参考：</strong><br>未将对象引用设置到对象的实例：<a href="https://blog.csdn.net/lsaejn/article/details/78499774?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">VS2017错误：未将对象引用设置到对象的实例</a><br>可借鉴vs2015：<a href="https://www.zhihu.com/question/37119592" target="_blank" rel="noopener">知乎VS2015一新建项目就出现未将对象引用设置到对象的实例怎么办？</a><br>运行时候没有跳出exe框：<a href="https://blog.csdn.net/jmpan_sjtu/article/details/79053169" target="_blank" rel="noopener">vs2017初学c++环境配置及使用教程</a></p>
<p><strong>总结：</strong><br>C:\Users\用户名\AppData\Local\Microsoft\VisualStudio\，把文件全部删了，然后再打开VS2017.<br>有个不一样的地方在于：我晚上安装的<code>使用c++的桌面开发</code>,创建新项目后发现报错。之后就进行了删除。但是删的时候没删完，就关机了。第二天删完后点开正常。所以也有可能是重启的原因。（因为网上也有说法是win10系统的问题）</p>
<p>之后要是运行正常没有显示框：右键点击解决方案资源管理器中的project名称, 于属性-配置属性-链接器-系统中, 双击子系统右边的空白处, 选择”控制台 (/SUBSYSTEM:CONSOLE)”<br>或者<code>return 0;</code>前面加<code>system(&quot;pause&quot;);</code></p>
]]></content>
      <categories>
        <category>安装和踩坑</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
        <tag>VS2017</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>centos6 中安装mysql5.7</title>
    <url>/2021/03/01/centos6%20%E4%B8%AD%E5%AE%89%E8%A3%85mysql5.7/</url>
    <content><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol>
<li>下载安装<strong>Xftp</strong>和<strong>Xshell</strong><br>官网可以申请学校个人使用的免费版，安装包会马上发到email中。</li>
</ol>
<p><strong>Xshell</strong>：centos在虚拟机中使用不方便，不能粘贴复制等。而在Xshell中可以进行批处理。<br><strong>Xftp</strong>：可以把安装包传到centos中，是和Xshell配套的文件传输工具。</p>
<ol start="2">
<li>连接Xftp和Xshell<br>点击  <strong>新建</strong>，名称自取（我取得和虚拟机中系统名相同node01），主机填对应操作系统中的主机号<br>可以在虚拟机对应操作系统中（我是centos 名称为node01）查看IPADDR，即主机号:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts</span><br><span class="line">cat ifcfg-eth0</span><br></pre></td></tr></table></figure>
打开虚拟机对应操作系统node01，再在xshell中点击连接，输入相同的用户名和密码，成功。<br>Xftp的连接和Xshell相同。如果想要添加什么文件，在左边双击文件即可添加进对应的操作系统中。</li>
</ol>
<h3 id="一、更换yum源"><a href="#一、更换yum源" class="headerlink" title="一、更换yum源"></a>一、更换yum源</h3><p><strong>安装wget</strong></p>
<blockquote>
<p>yum install wget -y 我会nothing to do 的错。所以使用rpm进行安装‘</p>
</blockquote>
<ol>
<li><a href="http://rpm.pbone.net/下载wget的RPM包`wget-1.12-1.4.el6.x86_64`" target="_blank" rel="noopener">http://rpm.pbone.net/下载wget的RPM包`wget-1.12-1.4.el6.x86_64`</a></li>
<li>利用<strong>xftp</strong>将下载的rpm包拷贝到centos中</li>
<li><code>rpm -ivh wget-1.12-1.4.el6.x86_64.rpm</code> 安装即可。</li>
</ol>
<p><strong>改变某些文件的名称</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>
<p><strong>执行更换yum源的命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;file.kangle.odata.cc&#x2F;repo&#x2F;Centos-6.repo</span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;file.kangle.odata.cc&#x2F;repo&#x2F;epel-6.repo</span><br></pre></td></tr></table></figure>
<p><strong>更新本地缓存</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<h3 id="二、查看系统中是否自带安装mysql"><a href="#二、查看系统中是否自带安装mysql" class="headerlink" title="二、查看系统中是否自带安装mysql"></a>二、查看系统中是否自带安装mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list installed | grep mysql</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021030109202831.png" alt="在这里插入图片描述"></p>
<h3 id="三、给CentOS添加rpm源，并且选择较新的源"><a href="#三、给CentOS添加rpm源，并且选择较新的源" class="headerlink" title="三、给CentOS添加rpm源，并且选择较新的源"></a>三、给CentOS添加rpm源，并且选择较新的源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget dev.mysql.com&#x2F;get&#x2F;mysql-community-release-el6-5.noarch.rpm --no-check-certificate</span><br></pre></td></tr></table></figure>

<h3 id="四、安装下载好的rpm文件"><a href="#四、安装下载好的rpm文件" class="headerlink" title="四、安装下载好的rpm文件"></a>四、安装下载好的rpm文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mysql-community-release-el6-5.noarch.rpm -y</span><br></pre></td></tr></table></figure>

<h3 id="五、使用yum安装mysql"><a href="#五、使用yum安装mysql" class="headerlink" title="五、使用yum安装mysql"></a>五、使用yum安装mysql</h3><p><strong>安装成功之后，在/etc/yum.repos.d/文件夹下会多出两个文件：mysql-community.repo和mysql-community-source.repo</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p><strong>修改<code>mysql-community.repo</code></strong>，把里面5.6的<code>enabled</code>改为0，5.7的改为1。如果不改动的话，默认装的是5.6版本。<br>然后到根目录（cd）进行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mysql-community-server -y</span><br></pre></td></tr></table></figure>

<h3 id="六、启动mysql服务并设置开机启动"><a href="#六、启动mysql服务并设置开机启动" class="headerlink" title="六、启动mysql服务并设置开机启动"></a>六、启动mysql服务并设置开机启动</h3><h5 id="正确操作水水水水水水水水水水水水水水水水水水水12哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈年纪u"><a href="#正确操作水水水水水水水水水水水水水水水水水水水12哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈年纪u" class="headerlink" title="正确操作水水水水水水水水水水水水水水水水水水水12哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈年纪u"></a>正确操作水水水水水水水水水水水水水水水水水水水12哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈年纪u</h5><p>\噢噢噢噢噢噢噢噢噢噢噢噢噢噢噢噢哦哦哦、】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum update -y</span><br><span class="line">#启动mysql服务</span><br><span class="line">service mysqld start</span><br><span class="line">#设置mysql开机启动</span><br><span class="line">chkconfig mysqld on</span><br></pre></td></tr></table></figure>
<h5 id="有问题操作及其解决方法"><a href="#有问题操作及其解决方法" class="headerlink" title="有问题操作及其解决方法"></a>有问题操作及其解决方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启服务</span><br><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>
<p><font color='red'><strong>会报错：【failed】</strong></font><br>查看日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;log</span><br><span class="line"># 可以看到mysql.log</span><br><span class="line">ls</span><br><span class="line"># 查看报错原因</span><br><span class="line">cat mysql.log</span><br></pre></td></tr></table></figure>
<p><code>2021-02-25T01:44:08.107626Z 0 [ERROR] Could not generate RSA private key required for X509 certificate.</code><br>不能生成私有密钥<br>因为安装5.7后会自动生成临时密码，报这个错意味着某些证书已经过期了。<br><font color='red'><strong>解决</strong>：<code>yum update -y</code></font><br><strong>再次重新启动依旧会报错！</strong><br><strong>原因</strong>：当前目录已经生成了一些文件。启动命令实际上做了两步：第一个步是初始化，生成某些系统表。而这里报错其实第一步已经完成了。第二步才是启动服务。<br><strong>解决：</strong>删除第一次错误生成的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">rm -rf .&#x2F;*</span><br></pre></td></tr></table></figure>
<p>重新启动，成功！</p>
<h3 id="七、获取mysql的临时密码"><a href="#七、获取mysql的临时密码" class="headerlink" title="七、获取mysql的临时密码"></a>七、获取mysql的临时密码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;password&quot; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure>
<p>或者到/var/log下，查看mysqld.log，里面可以找到临时密码</p>
<h3 id="使用临时密码登录"><a href="#使用临时密码登录" class="headerlink" title="使用临时密码登录"></a>使用临时密码登录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">#输入密码</span><br></pre></td></tr></table></figure>

<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global validate_password_policy&#x3D;0;</span><br><span class="line">set global validate_password_length&#x3D;1;</span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="修改远程访问权限"><a href="#修改远程访问权限" class="headerlink" title="修改远程访问权限"></a>修改远程访问权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39; with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>centos6.5离线安装gcc</title>
    <url>/2021/02/28/centos6.5%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85gcc/</url>
    <content><![CDATA[<p>参考：<a href="https://blog.csdn.net/jiede1/article/details/78551056" target="_blank" rel="noopener">https://blog.csdn.net/jiede1/article/details/78551056</a></p>
<p>下载下面rpm包：<a href="http://rpm.pbone.net/" target="_blank" rel="noopener">http://rpm.pbone.net/</a><br>依次安装：<br>rpm -Uvh kernel-headers-2.6.32-431.el6.x86_64.rpm<br>rpm -Uvh glibc-headers-2.12-1.132.el6.x86_64.rpm<br>rpm -Uvh glibc-devel-2.12-1.132.el6.x86_64.rpm<br>rpm -Uvh libgomp-4.4.7-4.el6.x86_64.rpm<br>rpm -Uvh ppl-0.10.2-11.el6.x86_64.rpm<br>rpm -Uvh cloog-ppl-0.15.7-1.2.el6.x86_64.rpm<br>rpm -Uvh mpfr-2.4.1-6.el6.x86_64.rpm<br>rpm -Uvh cpp-4.4.7-4.el6.x86_64.rpm<br>rpm -Uvh gcc-4.4.7-4.el6.x86_64.rpm</p>
<p>遇到error，在后面加上<code>--nodeps --force</code></p>
<blockquote>
<p>–nodeps    就是安装时不检查依赖关系<br>–force    就是强制安装（电脑上含旧版本的需要）</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>class文件格式</title>
    <url>/2021/03/14/class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="JVM基础知识"><a href="#JVM基础知识" class="headerlink" title="JVM基础知识"></a>JVM基础知识</h2><p><img src="https://img-blog.csdnimg.cn/20210314090233600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>java编译成class文件，再被类加载器加载到JVM中。</p>
<blockquote>
<p>java是解释执行还是编译执行的？<br>其实都有。如果一段代码用的特别多（一些特定的），那就被JIT即时编译成exe文件，下次用的时候就不需要再解释，可以直接调用。</p>
</blockquote>
<h3 id="jvm特点"><a href="#jvm特点" class="headerlink" title="jvm特点"></a>jvm特点</h3><ol>
<li><font color='red'><strong>JVM和java无关，只跟class这种格式有关</strong></font>。任何语言只有变成class就可以在jvm上编译执行。</li>
<li><font color='red'><strong>jvm是一种规范</strong></font>。定义了jvm应该具备哪些规范</li>
<li><font color='red'><strong>是虚构出来的一台计算机</strong></font>。所以有自己的CPU，有自己的指令集，自己的内存管理。</li>
</ol>
<h3 id="常见JVM实现"><a href="#常见JVM实现" class="headerlink" title="常见JVM实现"></a>常见JVM实现</h3><p><strong>HotSpot</strong><br>oracle官方</p>
<p><strong>Jrockit</strong><br>曾号称世界最快的JVM，被Oracle收购，合并于hotspot</p>
<p><strong>azul zing</strong><br>收费。最新垃圾回收的业界标杆。速度极快（号称STW 1ms内）</p>
<p>HotSpot的ZGC参考的azul中的实现。</p>
<h3 id="JVM-JRE-JDK区别"><a href="#JVM-JRE-JDK区别" class="headerlink" title="JVM JRE JDK区别"></a>JVM JRE JDK区别</h3><p>JVM只是执行的。JRE是运行已编译Java程序所需的所有内容的集合。JDK是开发用的。<br><img src="https://img-blog.csdnimg.cn/20210314093502708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Class-File-Format"><a href="#Class-File-Format" class="headerlink" title="Class File Format"></a>Class File Format</h2><p>二进制字节流</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>gedit快捷键</title>
    <url>/2020/09/14/gedit%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>标签的快捷方式：</p>
<p>Ctrl + Alt + PageDown切换到左侧的下一个选项卡。</p>
<p>Ctrl + Alt + PageDown切换到右侧的下一个选项卡。</p>
<p>Ctrl + W关闭标签。</p>
<p>Ctrl + Shift + L保存所有标签。</p>
<p>Ctrl + Shift + W关闭所有标签。</p>
<p>Alt + n跳到第n个标签。</p>
<p>使用文件的快捷方式：</p>
<p>Ctrl + N创建一个新文档。</p>
<p>Ctrl + O打开文档。</p>
<p>Ctrl + L打开一个位置。</p>
<p>Ctrl + S将当前文档保存到磁盘。</p>
<p>Ctrl + Shift + S使用新文件名保存当前文档。</p>
<p>Ctrl + P打印当前文档。</p>
<p>Ctrl + Shift + P打印预览。</p>
<p>Ctrl + W关闭当前文档。</p>
<p>Ctrl + Q退出Gedit。</p>
<p>编辑文件的捷径：</p>
<p>Ctrl + Z撤消上一个操作。</p>
<p>Ctrl + Shift + Z重做上一个撤消的操作。</p>
<p>Ctrl + X剪切选定的文本或区域并将其放置在剪贴板上。</p>
<p>Ctrl + C将选定的文本或区域复制到剪贴板上。</p>
<p>Ctrl + V粘贴剪贴板的内容。</p>
<p>Ctrl + A全选。</p>
<p>显示和隐藏窗格的快捷方式：</p>
<p>F9显示/隐藏侧窗格。</p>
<p>Ctrl + F9显示/隐藏底部窗格。</p>
<p>搜索的快捷方式：</p>
<p>Ctrl + F查找字符串。</p>
<p>Ctrl + G查找字符串的下一个实例。</p>
<p>Ctrl + Shift + G查找字符串的上一个实例。</p>
<p>Ctrl + K交互式搜索。</p>
<p>Ctrl + H搜索并替换。</p>
<p>Ctrl + Shift + K清除突出显示。</p>
<p>Ctrl + I转到行。</p>
<p>工具的快捷方式：</p>
<p>Shift + F7检查拼写（带有插件）。</p>
<p>Alt + F12删除尾随空格（带有插件）。</p>
<p>Ctrl + T缩进（带有插件）。</p>
<p>Ctrl + Shift + T删除缩进（带有插件）。</p>
<p>F8在当前目录（带有插件）中运行“ make”。</p>
<p>Ctrl + Shift + D目录列表（带有插件）。</p>
<p>快捷帮助：</p>
<p>F1打开gedit的用户手册。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>gedit</category>
      </categories>
      <tags>
        <tag>gedit</tag>
      </tags>
  </entry>
  <entry>
    <title>git上传本地文件到github</title>
    <url>/2021/01/22/git%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%88%B0github/</url>
    <content><![CDATA[<h3 id="git上传本地文件到GitHub"><a href="#git上传本地文件到GitHub" class="headerlink" title="git上传本地文件到GitHub"></a>git上传本地文件到GitHub</h3><p>git config –global user.name “Your Real Name”<br>git config –global user.email <a href="mailto:you@email.address">you@email.address</a><br>git init<br>git add .<br>git commit -m ‘Test’<br>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:XXX/XXX.git<br>git push -u origin master</p>
<p><font color = red>注：</font>加了参数-u后，以后即可直接用git push 代替git push origin master</p>
<h3 id="git-push时出现’failed-to-push-some-refs-to’"><a href="#git-push时出现’failed-to-push-some-refs-to’" class="headerlink" title="git push时出现’failed to push some refs to’"></a>git push时出现’failed to push some refs to’</h3><p>输入<code>$ git push origin master</code>提示出错信息：<font color = red>error: failed to push some refs to……</font></p>
<p><strong>解决办法</strong>：</p>
<ol>
<li>先输入$ git pull origin master //先把远程服务器github上面的文件拉下来</li>
<li>再输入$ git push origin master</li>
</ol>
<h3 id="git-pull时出现’fatal-refusing-to-merge-unrelated-histories’"><a href="#git-pull时出现’fatal-refusing-to-merge-unrelated-histories’" class="headerlink" title="git pull时出现’fatal: refusing to merge unrelated histories’"></a>git pull时出现’fatal: refusing to merge unrelated histories’</h3><p>Github上有一个仓库(有README)，之前一直是直接网页上传文件，今天打算把本地仓库和Github上做一个关联。<br>发现git pull，git feach提醒<font color = red>fatal: refusing to merge unrelated histories</font><br><img src="https://img-blog.csdnimg.cn/20210122180036970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>上网查到原因是两个分支是两个不同的版本，具有不同的提交历史。</p>
<p><strong>解决办法</strong>：</p>
<ol>
<li>输入$ git pull origin master –allow-unrelated-histories</li>
<li>再输入$ git push origin master</li>
</ol>
<p><strong>效果</strong>：<br>可以允许不相关历史提，强制合并。即原来GitHub上的内容和本地库中的内容都合并了，且相同。</p>
<p>但是由于GitHub上和本地库中有内容相同但名字不同的部分，比如本地库中命名为“DAY06_链表”，而GitHub中名为“DAY06”，不符合我的预期。</p>
<p><strong>解决办法</strong>：<br>把本地的要不要留下的部分删去，再强制提交。<br>输入$ git push origin master -f</p>
<p><font color = red>注</font>：<code>-f</code>使用需要谨慎！！提交后会直接覆盖掉GitHub端的内容。</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>GitBash</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git查看和更改origin数据源</title>
    <url>/2021/01/22/git%E6%9B%B4%E6%94%B9origin%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
    <content><![CDATA[<p>git remote －v 查看远程origin<br>git remote rm origin 删除远程origin<br>git remote add origin [url]</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>GitBash</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap的源码分析</title>
    <url>/2020/11/16/hashmap%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="hashmap和hashtable的区别"><a href="#hashmap和hashtable的区别" class="headerlink" title="hashmap和hashtable的区别"></a>hashmap和hashtable的区别</h3><ol>
<li>hashmap线程不安全，效率比较高，hashtable线程安全，效率低。</li>
<li>hashmap中key和value都可以为空，hashtable不允许为空。</li>
</ol>
<p>hashmap的初始值为2的n次幂，原因：</p>
<ol>
<li>分别进行 &amp; 操作，提高效率， &amp; 要比取模运算效率要高。<br>hash &amp; (initCapacity - 1)</li>
<li>在扩容之后涉及元素的迁移过程，迁移的时候只需要判断二进制的前一位是0或者是1即可。<br>如果是0，表示新数组和旧数组的下标位置不变，如果是1，只需要将索引位置加上旧的数组的长度值即为新数组的下标。</li>
</ol>
<h3 id="1-7-hashmap的源码分析：-数组-链表"><a href="#1-7-hashmap的源码分析：-数组-链表" class="headerlink" title="1.7 hashmap的源码分析： 数组+链表"></a>1.7 hashmap的源码分析： 数组+链表</h3><blockquote>
<blockquote>
<ol>
<li>默认初始容量</li>
<li>加载因子</li>
<li>put操作<br>&emsp;1）设置值，计算hash<br>&emsp;2）扩展操作<br>&emsp;3）数据迁移的过程</li>
</ol>
</blockquote>
</blockquote>
<pre><code>private void inflateTable(int toSize)
`capacity` : hashmap的初始值,为2的n次幂
`threshold = capacity * loadFactor` : loadFactor是加载因子，每次进行扩容的时候会用到。如果capacity = 16，loadFactor = 0.75，那么当容量为12的时候我们可以进行扩容。
`table = new Entry(capacity)` 在堆里面创建一个数组空间,我们可以往里面放入元素值了。

if(key == null)
为了减少哈希碰撞</code></pre><blockquote>
<blockquote>
<p>关于 |= , &amp;= , ^= 运算符<br>a |= b：相当于“a ∪ b” 只有a，b二进制位均为0时，结果才为0<br>a &amp;= b：相当于“a ∩ b” 只有a，b二进制位均为1时，结果才为0<br>a |= b：相当于“a异或b” 只有a，b二进制位相异，结果才为0</p>
</blockquote>
</blockquote>
<h3 id="1-8-hashmap的源码分析：数组-链表-红黑树"><a href="#1-8-hashmap的源码分析：数组-链表-红黑树" class="headerlink" title="1.8 hashmap的源码分析：数组+链表+红黑树"></a>1.8 hashmap的源码分析：数组+链表+红黑树</h3><pre><code>扰动函数：让高位参与运算来减少哈希碰撞发生的概论。</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>Java集合框架</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo个人博客搭建和中间遇到的问题</title>
    <url>/2020/06/23/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E4%B8%AD%E9%97%B4%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>@[toc]</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol>
<li>安装好git bsah</li>
<li>全程git bash下完成命令</li>
</ol>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h5 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h5><p>一路next，直接安装完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测是否成功</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<h5 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h5><p>1.在创建的文件夹blog下，打开git bash</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装cnmp（阿里开发，国内速度快）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>
<p>依旧用<code>hexo -v</code> <code>cnpm -v</code>查看一下版本</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ol>
<li>初始化一下hexo<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure>
显示结果最后两句为：<br><img src="https://img-blog.csdnimg.cn/20200622004505658.png" alt="在这里插入图片描述"><br>根据提示</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cd myblog <span class="comment">//进入myblog文件夹</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h6 id="报错npm-ERR-code-ELIFECYCLE"><a href="#报错npm-ERR-code-ELIFECYCLE" class="headerlink" title="报错npm ERR! code ELIFECYCLE"></a>报错npm ERR! code ELIFECYCLE</h6><p>npm ERR! code ELIFECYCLE<br>npm ERR! errno 1<br>npm ERR! <a href="mailto:ejs@2.7.4">ejs@2.7.4</a> postinstall: ` node ./postinstall.js`<br>npm ERR! Exit status 1<br>npm ERR!<br>npm ERR! Failed at the <a href="mailto:ejs@2.7.4">ejs@2.7.4</a> postinstall script.<br>npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</p>
<p>npm ERR! A complete log of this run can be found in:<br>npm ERR!     C:\Users\Lenovo\AppData\Roaming\npm-cache_logs\2020-06-21T16_16_49_430Z-debug.log</p>
<p>如果不解决，继续往下走，hexo可以运行，但是打开 <a href="http://localhost:4000会发现没有格式，只有几行代码。">http://localhost:4000会发现没有格式，只有几行代码。</a></p>
<h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>继续输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure>
<p>部分截图如下：<br><img src="https://img-blog.csdnimg.cn/2020062200525094.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol start="2">
<li>运行hexo</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>成功！<br>基础显示页面：<br><img src="https://img-blog.csdnimg.cn/20200622005514779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><h6 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h6><p>新建一个专门用来部署博客的仓库</p>
<h6 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h6><p>1.安装部署插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>2.设置配置文件<br>在<code>_config.yml</code>中尾端，修改成下面样子：</p>
<p># Deployment<br>## Docs: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a><br>deploy:<br>  type: ‘git’<br>  repo: <a href="https://github.com/two-fire/two-fire.github.io.git" target="_blank" rel="noopener">https://github.com/two-fire/two-fire.github.io.git</a><br>  branch: master</p>
<ul>
<li>可以通过vim进入，<code>[[</code>定位到文件首部，<code>]]</code>定位到尾部。</li>
</ul>
<ol start="3">
<li>部署到远端<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
成功！<br>例如我可通过<a href="https://two-fire.github.io/访问" target="_blank" rel="noopener">https://two-fire.github.io/访问</a><br><img src="https://img-blog.csdnimg.cn/20200622123124547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h3 id="换主题"><a href="#换主题" class="headerlink" title="换主题"></a>换主题</h3><ol>
<li><p>下载主题<br>在github上找到喜欢的主题，克隆到themes<br>我找的是next主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next.git themes&#x2F;next</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置到我的博客中</p>
</li>
</ol>
<p>修改<code>_config.yml</code>文件中的theme为next<br># Extensions<br>## Plugins: <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a><br>## Themes: <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>theme: <strong>landscape</strong></p>
<ul>
<li>vim中可以通过<code>/something</code>来查找，n下一个，N上一个</li>
</ul>
<ol start="3">
<li><p>查看<br>重新清理，生成（generate），运行（server）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  </span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>localhost:4000 发现已经改变。<br><img src="https://img-blog.csdnimg.cn/20200622124509321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>推送到远端(deploy)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>成功之后可通过GitHub的地址访问。（更换主题可能有延迟）</p>
</li>
</ol>
<h4 id="主题的个性化打造"><a href="#主题的个性化打造" class="headerlink" title="主题的个性化打造"></a>主题的个性化打造</h4><p>参考博文：<a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></p>
<ol>
<li>修改文章底部的那个带#号的标签</li>
</ol>
<p>修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成<i class="fa fa-tag"></i></p>
<p>2.在网站底部加上访问量</p>
<p>打开\themes\next\layout_partials\footer.swig文件,在&lt;div class=”copyright”&gt;前加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;https:&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>等等……</p>
<h3 id="博客内容完善"><a href="#博客内容完善" class="headerlink" title="博客内容完善"></a>博客内容完善</h3><p>都可以在<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next官方文档</a>和<a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">hexo官方文档</a>中找到详细介绍<br>例如：</p>
<h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><ol>
<li><p><code>hexo new page &quot;about&quot;</code></p>
<p> 在myblog/source下会新生成一个新的文件夹about，<br> 在该文件夹下会有一个index.md文件,里面Front-matter中加上    <code>type: &quot;about&quot;</code>，在Front-matter下面用markdown格式书写想要写的内容即可。</p>
</li>
<li><p>在主题的 themes/next/_configy.yml 设置中将 menu中about前面的注释去掉</p>
</li>
<li><p><code>hexo clean</code> <code>hexo d -g</code></p>
</li>
</ol>
<p>等等……</p>
<h5 id="点击侧边栏关于，分类等，发现hexo-Cannot-GET-20"><a href="#点击侧边栏关于，分类等，发现hexo-Cannot-GET-20" class="headerlink" title="点击侧边栏关于，分类等，发现hexo Cannot GET /%20/"></a>点击侧边栏关于，分类等，发现hexo Cannot GET /%20/</h5><p>解决：<a href="https://www.jianshu.com/p/b671e4082c13" target="_blank" rel="noopener">实习生小王的博客</a><br>%20 是空格的意思，把配置文件里 ||之前所有的空格删掉即可。<br><em>不一定每次遇到，上一次的博客搭建就没有这个问题。</em></p>
<p>还有一个问题，是新建必须命名tags，不能是tag。不然也会无法打开。</p>
<h5 id="hexo-g后-报错INFO-Start-processing-ERROR-Theme-config-load-failed-ERROR-Process"><a href="#hexo-g后-报错INFO-Start-processing-ERROR-Theme-config-load-failed-ERROR-Process" class="headerlink" title="hexo g后 报错INFO  Start processing ERROR Theme config load failed. ERROR Process"></a>hexo g后 报错INFO  Start processing ERROR Theme config load failed. ERROR Process</h5><blockquote>
<p>INFO  Start processing ERROR Theme config load failed. ERROR Process<br>failed: _config.yml YAMLException: bad indentation of a mapping entry<br>at line 130, column 3:<br>      GitHub: <a href="https://github.com/two-f" target="_blank" rel="noopener">https://github.com/two-f</a> …<br>        ^<br>    at generateError (D:\OtherFiles\blog\myblog\node_modules\js-yaml\lib\js-yaml\loader.js:167:10)<br>    at throwError (D:\OtherFiles\blog\myblog\node_modules\js-yaml\lib\js-yaml\loader.js:173:9)<br>    at readBlockMapping (D:\OtherFiles\blog\myblog\node_modules\js-yaml\lib\js-yaml\loader.js:1107:7)<br>    at composeNode (D:\OtherFiles\blog\myblog\node_modules\js-yaml\lib\js-yaml\loader.js:1359:12)<br>    ……</p>
</blockquote>
<p>报错显示_config.yml 130行，对应找到发现是GitHub社交链接<code>GitHub: https://github.com/two-fire || github</code>处。原来，上面一行<code>social:</code>忘记取消注释了。</p>
<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ol>
<li><p>安装搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li><p>myblog中的_config.yml，增加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li>
<li><p>next主题中的全局配置文件_config.yml中，修改local_search的enable为true</p>
</li>
<li><p>git bash中，先在localhost上查看（比较快）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>在执行下一步：<code>hexo s</code>时候，发现报错<code>Usage: hexo &lt;command&gt;</code><br>执行<code>cnpm install</code>        后，再<code>hexo s</code>发现成功。<br><img src="https://img-blog.csdnimg.cn/20200622195353449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（我使用的是next中的scheme: Pisces）<br>之后可以使用<code>hexo d</code>上传远端。</p>
<h5 id="如果报错hexo-d后-ERROR-Deployer-not-found-git"><a href="#如果报错hexo-d后-ERROR-Deployer-not-found-git" class="headerlink" title="如果报错hexo d后 ERROR Deployer not found: git"></a>如果报错hexo d后 ERROR Deployer not found: git</h5><p>如果遇到，可尝试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>（以下摘自<a href="https://hexo.imydl.tech/archives/51612.html" target="_blank" rel="noopener">明月登楼博客</a>）<br>其中的 npm install 可以加上参数 -save ，这样</p>
<ul>
<li>会把依赖包安装到 node_modules 目录中</li>
<li>会在package.json的dependencies属性下添加依赖包的名称和版本号</li>
<li>之后运行npm install命令时，会自动安装依赖包到node_modules目录中</li>
<li>如果不加save参数的话，之后把X包安装到node_modules目录中，不会添加到 package.json 文件的 dependencies 属性中。</li>
</ul>
</blockquote>
<p><strong>找到原因，是myblog的_config文件中的git用成了中文双引号“”，导致失败！</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#39;git&#39;</span><br></pre></td></tr></table></figure>
<p>接下来是还未找到原因时候的尝试，直到发现问题出在上面引号处停止。</p>
<hr>
<blockquote>
<p>显示<strong>run `npm audit fix` to fix them, or ` npm audit``for<br>details</strong>,执行npm audit fix</p>
<h5 id="如果报错npm-ERR-Missing-hexo-renderer-ejs-1-0-0"><a href="#如果报错npm-ERR-Missing-hexo-renderer-ejs-1-0-0" class="headerlink" title="如果报错npm ERR!     Missing: hexo-renderer-ejs@^1.0.0"></a>如果报错npm ERR!     Missing: hexo-renderer-ejs@^1.0.0</h5><blockquote>
<p>npm ERR! code ELOCKVERIFY npm ERR! Errors were found in your<br>package-lock.json, run  npm install  to fix them. npm ERR!<br>Missing: hexo-renderer-ejs@^1.0.0</p>
<p>npm ERR! A complete log of this run can be found in: npm ERR!<br>C:\Users\Lenovo\AppData\Roaming\npm-cache_logs\2020-06-23T00_27_08_923Z-debug.log<br>进入package.json和package-lock.json，发现package.json的dependences是包含hexo-renderer-ejs@^1.0.0的<br>，但package-lock.json中没有hexo-renderer-ejs@^1.0.0。</p>
</blockquote>
<ol>
<li>查看hexo插件安装情况 <code>npm ls --depth 0</code>发现<code>npm ERR! missing: hexo-renderer-ejs@^1.0.0, required by hexo-site@0.0.0</code></li>
<li>安装缺失的包 <code>npm install hexo-renderer-ejs --save</code><h5 id="如果报错npm-ERR-Failed-at-the-ejs-2-7-4-postinstall-script-c-npm-ERR-code-ELIFECYCLE-npm-ERR-errno-1-npm-ERR-ejs-2-7-4"><a href="#如果报错npm-ERR-Failed-at-the-ejs-2-7-4-postinstall-script-c-npm-ERR-code-ELIFECYCLE-npm-ERR-errno-1-npm-ERR-ejs-2-7-4" class="headerlink" title="如果报错npm ERR! Failed at the ejs@2.7.4 postinstall script ```c npm ERR! code ELIFECYCLE    npm ERR! errno 1 npm ERR! ejs@2.7.4"></a>如果报错npm ERR! Failed at the <a href="mailto:ejs@2.7.4">ejs@2.7.4</a> postinstall script ```c npm ERR! code ELIFECYCLE    npm ERR! errno 1 npm ERR! <a href="mailto:ejs@2.7.4">ejs@2.7.4</a></h5>postinstall: `node ./postinstall.js` npm ERR! Exit status 1  npm ERR!<br>npm ERR! Failed at the <a href="mailto:ejs@2.7.4">ejs@2.7.4</a> postinstall script.   npm ERR! This<br>is probably not a problem with npm.There is likely additional logging<br>output above.  npm ERR! A complete log of this run can be found in:<br>npm ERR!<br>C:\Users\Lenovo\AppData\Roaming\npm-cache_logs\2020-06-23T00_27_54_327Z-debug.log<figure class="highlight plain"><figcaption><span>install ejs@2.7.4 --ignore-scripts`后再执行后续操作。</span></figcaption><table><tr><td class="code"><pre><span class="line">（方法来自[熊二吃屁的博客](https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_46493091&#x2F;article&#x2F;details&#x2F;106891882)）</span><br><span class="line">根据提示&#96;npm audit fix&#96;之后，再&#96;npm ls --depth 0 &#96;不报错。 但是尝试&#96;npm install --save</span><br><span class="line">hexo-deployer-git&#96;依旧有问题，有两个漏洞： </span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><a href="mailto:hexo-deployer-git@2.1.0">hexo-deployer-git@2.1.0</a> removed 2 packages, updated 1 package and audited 255 packages in 41.24s found 2 low severity vulnerabilities<br>run <code>npm audit fix</code> to fix them, or <code>npm audit</code> for details ````npm<br>audit`查看详情，显示：2 vulnerabilities require manual review. See the full<br>report for details.  即2个漏洞需要手动检查。 有关详细信息，请参见完整报告。并给出了 Visit<br><a href="https://go.npm.me/audit-guide" target="_blank" rel="noopener">https://go.npm.me/audit-guide</a> for additional guidance的建议。<br>网站内容是《审核程序包相关性是否存在安全漏洞》<img src="https://img-blog.csdnimg.cn/20200623101039107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="审核程序包相关性是否存在安全漏洞"><br>尝试关闭审核 ```npm set audit false npm install –save hexo-deployer-git<figure class="highlight plain"><figcaption><span>audit fix`没有出现报错。</span></figcaption><table><tr><td class="code"><pre><span class="line">![过程](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200623101429668.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ&#x3D;&#x3D;,size_16,color_FFFFFF,t_70)</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">####  写博客</span><br><span class="line">1. 创建新页面 </span><br></pre></td></tr></table></figure>
hexo new ‘filename’</li>
</ul>
</blockquote>
<p>```<br>在source/_posts路径下可以看到你创建的文章。<br>编辑文章，之后按照前面说的方式部署，在浏览器刷新就能看到你的文章了</p>
<p><a href="https://blog.csdn.net/weixin_42915561/article/details/106726687?%3E?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-3" target="_blank" rel="noopener">markdown语法</a></p>
<p>编辑文章我用的VScode，有时候直接sublime3。想要直接在命令行输入“subl xxx”就打开文件，可以参考我的另一篇博文<a href="https://two-fire.github.io/" target="_blank" rel="noopener">Git-Bash中设置命令</a></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>绑定域名参考（包含详细博客搭建）：<a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-11" target="_blank" rel="noopener">绑定域名</a></p>
<h3 id="无法访问页面"><a href="#无法访问页面" class="headerlink" title="无法访问页面"></a>无法访问页面</h3><p><code>https://two-fire.github.io/</code>无法访问<br>可能是网的问题，开了热点就能访问了。</p>
]]></content>
      <categories>
        <category>安装和踩坑</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>java中包装类和基本类型使用==比较详解</title>
    <url>/2021/02/03/java%E4%B8%AD%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8==%E6%AF%94%E8%BE%83%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>案例1</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">Integer it1 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">System.out.println(a == it1);  <span class="comment">// ture</span></span><br><span class="line"><span class="comment">// 通过方法进行类型转换</span></span><br><span class="line">Integer it2 = Integer.valueOf(a);</span><br><span class="line"><span class="keyword">int</span> i = it1.intValue();</span><br></pre></td></tr></table></figure>
<p>分析：<br>当Integer与int进行==比较时，Integer就会拆箱成一个int类型，所以还是相当于两个int类型进行比较，这里的Integer,不管是直接赋值，还是new创建的对象，只要跟int比较就会拆箱为int类型，所以就是相等的</p>
<p><strong>案例2</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = -<span class="number">128</span>; <span class="comment">// 将-128赋值给b</span></span><br><span class="line">Integer i1 = -<span class="number">128</span>; <span class="comment">// 1.基本类型int -128的变量 2.自动装箱int-&gt;Integer</span></span><br><span class="line">Integer i2 = -<span class="number">128</span>;</span><br><span class="line">Integer i3 = <span class="number">128</span>;</span><br><span class="line">Integer i4 = <span class="number">128</span>;</span><br><span class="line">System.out.println(b == i1); <span class="comment">// true</span></span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// true</span></span><br><span class="line">System.out.println(i3 == i4); <span class="comment">// false</span></span><br><span class="line">Integer integer1 = <span class="keyword">new</span> Integer(-<span class="number">128</span>);</span><br><span class="line">System.out.println(i1 == integer1); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>分析：<br>两个Integer==比较，由于都是对象类型，所以不会拆箱比较。<br>Integer i1 = -128;的第二步自动装箱时，要调用valueOf()，Integer作为<strong>常量</strong>时，对于-128到127之间的数，会进行缓存。第二次创建i2的时候，直接取出缓存，所以相等。而超出范围就是new了新对象了，所以不等。<br><code>valueOf()</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i在[-128,127]之间，直接返回cache，是相同的对象</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="comment">// 否则创建新对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例3</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double d1 = <span class="number">1.0</span>;</span><br><span class="line">Double d2 = <span class="number">1.0</span>;</span><br><span class="line">Double d3 = <span class="number">2.0</span>;</span><br><span class="line">Double d4 = <span class="number">2.0</span>;</span><br><span class="line">System.out.println(d1 == d2); <span class="comment">//false</span></span><br><span class="line">System.out.println(d3 == d4); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>分析：<br><code>valueOf()</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(parseDouble(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例4</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">int</span> c = integer;</span><br><span class="line">System.out.println(c == integer); <span class="comment">// true</span></span><br><span class="line">System.out.println(integer == c); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>分析：<br><code>int c = integer;</code>自动拆箱，c赋值为10，当Integer与int进行==比较时，Integer就会拆箱成一个int类型。所以为true。</p>
<p><strong>案例4</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d = <span class="number">10</span>;</span><br><span class="line">Integer integer2 = d;</span><br><span class="line">Integer integer3 = <span class="number">10</span>;</span><br><span class="line">System.out.println(d == integer2); <span class="comment">// true</span></span><br><span class="line">System.out.println(integer3 == integer2); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">int</span> e = <span class="number">128</span>;</span><br><span class="line">Integer integer4 = e;</span><br><span class="line">Integer integer5 = <span class="number">128</span>;</span><br><span class="line">System.out.println(integer4 == integer5); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>分析：<br>同理，这里都是常量的比较。</p>
<p><strong>案例5</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer6 = <span class="number">128</span>;</span><br><span class="line">Integer integer7 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">System.out.println(integer6 == integer7); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>分析：<br>一个对象类型，一个是常类，存放位置不同。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>常用类</tag>
      </tags>
  </entry>
  <entry>
    <title>yum makecache时报错【Errno】 14PYCURL ERROR 22 - The requested URL returned error 404 Not Found</title>
    <url>/2021/02/28/yum%20makecache%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>centos6更换yum源为阿里源，前面都没有问题，但进行yum makecache操作会报错[Errno 14] PYCURL ERROR 22 - “The requested URL returned error: 404 Not Found”</p>
<p><strong>报错如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;6&#x2F;os&#x2F;x86_64&#x2F;repodata&#x2F;repomd.xml: [Errno 14] PYCURL ERROR 22 - &quot;The requested URL returned error: 404 Not Found&quot;</span><br><span class="line">Trying other mirror.</span><br><span class="line">http:&#x2F;&#x2F;mirrors.aliyuncs.com&#x2F;centos&#x2F;6&#x2F;os&#x2F;x86_64&#x2F;repodata&#x2F;repomd.xml: [Errno 14] PYCURL ERROR 7 - &quot;couldn&#39;t connect to host&quot;</span><br><span class="line">Trying other mirror.</span><br><span class="line">http:&#x2F;&#x2F;mirrors.cloud.aliyuncs.com&#x2F;centos&#x2F;6&#x2F;os&#x2F;x86_64&#x2F;repodata&#x2F;repomd.xml: [Errno 14] PYCURL ERROR 6 - &quot;Couldn&#39;t resolve host &#39;mirrors.cloud.aliyuncs.com&#39;&quot;</span><br><span class="line">Trying other mirror.</span><br><span class="line">Error: Cannot retrieve repository metadata (repomd.xml) for repository: base. Please verify its path and try again</span><br></pre></td></tr></table></figure>
<p>阿里云的centos源不能用了。</p>
<p><strong>解决：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;file.kangle.odata.cc&#x2F;repo&#x2F;Centos-6.repo</span><br><span class="line"></span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;file.kangle.odata.cc&#x2F;repo&#x2F;epel-6.repo</span><br></pre></td></tr></table></figure>
<p>然后再：<code>yum makecache</code>，成功。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>java利用Socket在控制台互发信息没有正常显示</title>
    <url>/2021/01/31/java%E5%88%A9%E7%94%A8Socket%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BA%92%E5%8F%91%E4%BF%A1%E6%81%AF%E6%B2%A1%E6%9C%89%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>【网络编程】java利用Socket在控制台互发信息。但是在客户端控制台输入信息后，服务器端控制台无消息显示。<br>原因：<code>PrintWriter printWriter = new PrintWriter(outputStream, true);</code> 必须在加上<strong>true</strong>，意味着想要将数据打印到outputStream中，并使用自动刷新。<br>加上后代码如下，结果如图：<br><img src="https://img-blog.csdnimg.cn/20210131164253481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>客户端</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建socket对象，指定数据接收方的ip地址和端口号</span></span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">10001</span>);</span><br><span class="line">        <span class="comment">//----------------从控制台输入服务器端输出----------</span></span><br><span class="line">        <span class="comment">// 从控制台输入数据</span></span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        <span class="comment">// 存入缓冲区</span></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">        <span class="comment">// 获取输出流对象，向服务端发送数据</span></span><br><span class="line">        OutputStream outputStream = client.getOutputStream();</span><br><span class="line">        PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(outputStream, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//------------接收服务器端数据--------------------</span></span><br><span class="line">        InputStream inputStream = client.getInputStream();</span><br><span class="line">        InputStreamReader inputStreamReader2 = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br><span class="line">        BufferedReader bufferedReader2 = <span class="keyword">new</span> BufferedReader(inputStreamReader2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我说："</span>);</span><br><span class="line">            String str = bufferedReader.readLine(); <span class="comment">// 获取数据</span></span><br><span class="line">            printWriter.println(str);</span><br><span class="line"></span><br><span class="line">            String receive = bufferedReader2.readLine(); <span class="comment">// 获取数据</span></span><br><span class="line">            System.out.println(<span class="string">"服务器说："</span> + receive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>服务器端</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程解决</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 服务端需要使用serversocket来开放本地的端口</span></span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">10001</span>);</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">//------------接收客户端数据---------------</span></span><br><span class="line">            <span class="comment">// 通过server获取输入流对象</span></span><br><span class="line">            InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">            <span class="comment">//------------向客户端输出数据---------------</span></span><br><span class="line">            OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">            PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(outputStream, <span class="keyword">true</span>);</span><br><span class="line">            InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">            BufferedReader br2 = <span class="keyword">new</span> BufferedReader(isr2);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String str = <span class="keyword">null</span>; <span class="comment">//读出缓存区数据</span></span><br><span class="line">                str = br.readLine();</span><br><span class="line">                System.out.println(<span class="string">"客户端说："</span> + str);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"我说："</span>);</span><br><span class="line">                String str2 = <span class="keyword">null</span>;</span><br><span class="line">                str2 = br2.readLine();</span><br><span class="line">                printWriter.println(str2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以利用多线程实现上述代码。只需要改变Server3.java，再增加一个ServerThread.java即可。</p>
<details><summary>Server3.java</summary>
<pre><code>public class Server3 {
    public static void main(String[] args) throws IOException {
        // 服务端需要使用serversocket来开放本地的端口
        ServerSocket serverSocket = new ServerSocket(10001);
        Socket socket = serverSocket.accept();
        ServerThread serverThread = new ServerThread(socket);
        new Thread(serverThread).start();
    }
}</code></pre>
</details>
<details><summary>ServerThread.java</summary>
<pre><code>public class ServerThread implements Runnable{
    private Socket socket;

<pre><code>public ServerThread(Socket socket) {
    this.socket = socket;
}

@Override
public void run() {
    try {
        //------------接收客户端数据---------------
        // 通过server获取输入流对象
        InputStream inputStream = null;
        inputStream = socket.getInputStream();
        InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
        BufferedReader br = new BufferedReader(inputStreamReader);
        //------------向客户端输出数据---------------
        OutputStream outputStream = null;
        outputStream = socket.getOutputStream();
        PrintWriter printWriter = new PrintWriter(outputStream, true);
        InputStreamReader isr2 = new InputStreamReader(System.in);
        BufferedReader br2 = new BufferedReader(isr2);
        while (true) {
            String str = null; //读出缓存区数据
            str = br.readLine();
            System.out.println(&quot;客户端说：&quot; + str);

            System.out.println(&quot;我说：&quot;);
            String str2 = null;
            str2 = br2.readLine();
            printWriter.println(str2);
        }
    } catch (Exception e){

    }
}</code></pre><p>}</p>
<p></code></pre></p>
</details>


]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>《操作系统教程》概述</title>
    <url>/2020/08/21/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B%E3%80%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>3.4 进程控制<br>3.3.3 进程状态和转换<br>三状态：<br><img src="https://img-blog.csdnimg.cn/20200821130631465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>五状态：<br><img src="https://img-blog.csdnimg.cn/20200821130727222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>七状态：<br><img src="https://img-blog.csdnimg.cn/20200821130752148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>3.3.4 进程控制块（PCB）<br>· 是一个操作系统为管理进程设置的数据结构<br>· 是进程存在的唯一标识<br>· 作用：<br>    - 进程的创建：为该进程创理一个PCB<br>    - 进程的终止：回收它的PCB<br>    - 进程的组织管理：通过对PCB的组织管理实现<br>· 内容：<br>    1. 进程描述信息。如本进程的标识；它的父进程标识；用户标识。<br>    2. 进程控制信息。进程当前状态，优先级，进程间同步和通信等。<br>    3. 所拥有的资源和使用情况。<br>    4. CPU现场保护信息。</p>
<p> · 多采用链表的组织方式。可以更好地完成动态插入删除。如果比较固定，也可以采用索引表方式。</p>
<p>3.4.1 进程创建<br>引起创建的三个主要事件：<br>    1. 系统初始化时；<br>    2. 用户请求创建一个新进程<br>    3. 正在运行的进程执行了创建进程的系统调用<br><code>fork()</code>:</p>
<blockquote>
<p>0 : 在父进程中，返回值为子进程的id值<br>0： 在子进程中，返回值为0，表示当前进程是子进程<br>-1：创建失败</p>
</blockquote>
<p>3.4.2进程的阻塞和唤醒</p>
<p>3.6 处理器调度<br>三级调度<br>    1. 高级调度（作业调度、宏观调度、长程调度）<br>    任务：将作业从后备队列中装人内存<br>    2. 中级调度（平衡负载调度、中程调度）<br>    任务：内存资源紧张的时候，将一些进程换出主存，使之进入挂起态。调整系统负荷。<br>    3. 低级调度（进程调度、短程调度）<br>    任务：按照某种原则决定就绪队列中的哪个进程获得CPU</p>
<p>3.7 作业的管理和调度<br>作业<br>· 定义：用户需要计算机完成某项任务时要求计算机所做工作的集合。<br>· 四个阶段：<br>    1. 作业提交：从输入设备到外存的后备队列中<br>    2. 作业收容：后备队列中等待进入内存执行<br>    3. 作业执行：在内存中执行<br>    4. 作业完成<br>· 作业和进程区别：<br>    1. 作业是用户向计算机提交的任务实体；<br>    进程是完成任务的执行实体，是向系统申请分配资源的基本单位<br>    2. 作业由若干进程组成<br>    3. 作业的概念主要用于批处理系统；<br>    进程的概念用于所有的多道程序系统中</p>
<p>两个指标：<br>    1. 作业平均周转时间：<br>    假设<code>n</code>个作业，其中作业<code>i</code>进入系统时间为<code>Si</code>，它被选中执行，得到结果的时间（完成时间）为<code>Ei</code>，其周转时间为<code>Ti = Ei - Si</code>，则这批作业平均周转时间为T = （T1 + T2 + … + Tn）/ n<br>    · 有时间单位<br>    · Ti不是完成时间 - 进入内存时间（开始时间）<br>    2. 平均带权周转时间：<br>    <code>ri</code>为作业<code>i</code>的实际执行时间。则带权周转时间为<code>Wi = Ti/ri</code><br>    W = （T1/r1 + T2/r2 + … + Tn/rn）/n<br>    · 是一个比值，没有时间单位<br>注：T 不同调度算法对同一个作业流的性能衡量；W 同一调度算法对不同作业流的性能衡量。</p>
<p>作业调度算法<br>    1. FCFS算法（先来先服务调度算法）<br>    根据作业提交的先后次序分派CPU<br>    2. SJF算法（短作业优先调度）<br>    根据作业的估计运行时间分派CPU<br>    3. HRN算法（高响应比调度）<br>    相应比R = 作业周转时间/作业运行时间 = 1+等待时间/(估计)运行时间<br>    4. HPF算法（基于优先数调度）<br>    5. 均匀调度算法<br>    6. 最短剩余时间优先调度算法</p>
<p>3.9 线程<br>目的：将进程以更细的粒度切分，以低开销进一步提高系统并发度。<br>定义：轻量级进程，是进程的一个运行实体，作为CPU的调度单位。</p>
<p>线程资源：<br>· 系统引入线程后：<br>    - 调度单位——线程<br>    - 资源分配单位——进程<br>· 线程只拥有少量在运行时必不可少的资源<br>· 同一个进程中的所有线程共享进程的地址空间和资源</p>
<p>线程和进程比较：<br>【资源】进程是资源分配的基本单位；同进程内的线程共享进程的资源<br>【调度时】不同进程有不同地址空间；同个进程内所有线程有相同地址空间<br>【开销】进程切换开销大；同进程的线程切换开销小<br>【关系】进程间关系较疏远；同进程的线程间关系较紧密</p>
<p>线程的优越性：<br>    1. 快速关联切换<br>    2. 系统开销小<br>    3. 通信易实现<br>    4. 线程个数比进程多的多</p>
<p>4.5 死锁<br>死锁检测<br>进程资源分配图如下：<br><img src="https://img-blog.csdnimg.cn/20200821130851487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<pre><code>- 图中，如果能消去此进程的所有边，成为孤立结点。经一系列简化，所有进程都成为孤立结点，则该图是可完全简化的，否则为不可完全简化的。
- 【死锁定理】系统为死锁的充分条件是：当且仅当该状态的“进程-资源分配图”是不可完全简化的。</code></pre><p>死锁的解除：<br>    1. 资源剥夺法。从其他进程那里剥夺资源给死锁进程。<br>    2. 撤销进程法。撤销死锁进程。</p>
<p>第五章 存储管理<br>5.1 分区存储管理<br>· os中的离散和连续是物理空间上的分配，而DS中的链表和数组是逻辑空间上的分配。</p>
<p>分类：（根据划分分区的时机不同）<br>· 连续分配<br>    - 固定分区分配<br>    · 内存启动时，划分成若干个大小固定的分区，每个进程占一个分区<br>    · 固定：分区个数固定；分区大小固定（大小相等；不相等）</p>
<pre><code>- 可变（动态）分区分配
基本思想：
作业执行过程中，根据作业大小找到一个空闲的分区，并进行划分。
分配算法：
1）首次适应法：
· 思想：空闲分区地址递增排列。进行分配时，从空闲分区开始位置查找，直到第一个满足大小要求的分区，再按照作业大小划分出一块。
· 特点：保留了内存高地址部分大的空闲分区；低地址部分存在许多碎片。
2）循环首次适应法（下次适应法）：
· 思想：首次适应法的变形。进行内存分配时，从上次找到的空闲分区的下一个空闲区开始查找
· 特点：对存储空间利用更均衡；没有保留大的空闲分区
3）最佳适应法：
· 思想：空闲分区容量递增排列。从开始位置开始查找
· 特点：没有保留大的空闲分区；划分后有许多碎片
4）最坏适应法：
· 思想：空闲分区容量递减排列。只检查第一个空闲分区。
· 特点：没有保留大的空闲分区；每次只用查第一个空闲分区
回收算法：
根据回收区与空闲分区的位置关系，分为四种情况。回收后系统中空闲分区个数不同。</code></pre><p>· 离散分配<br>    - 分页式存储管理<br>    - 分段式存储管理<br>    - 段页式存储管理</p>
<p>· 分区移动技术：合并分散的小空闲分区 —&gt; 大空闲分区。允许作业在运行过程中在内存中移动，必须采用动态重定位方法。<br>· 覆盖技术<br>· 交换技术：把内存中暂时不能运行的进程或暂时不用的程序和数据，换到外存。把已经具备运行条件的进程，或进程所需的程序或数据换入内存。</p>
<p>5.2 页式存储管理<br>一、概念<br>页：逻辑空间划分成大小相等的若干个页，又称页面。<br>块：物理空间划分成大小相同的若干块，又叫页框。（每页的大小和每块的大小相同，一般大小为2的幂，512B~4MB）</p>
<p>二、数据结构<br>页表：<br>    - （索引）页号(页面号)和块号(页框号)的对应关系<br>    - 系统为每个装入内存的进程建立一张相应的页表<br>请求表：<br>    - 用来确定进程的地址空间的各页在内存中的实际位置关系<br>    - 记录每个进程页表的起始地址，还有所需的页面数<br>存储页面表<br>    - 记录系统中物理块的使用情况<br>    - 二维数组表示一维物理空间使用情况</p>
<p>三、地址转换（重定位）</p>
<blockquote>
<p>页的大小：L；逻辑地址：LA；页号对应的块号：b</p>
</blockquote>
<p>十进制计算过程：<br>页号P = LA / L<br>页内偏移地址d = LA % L<br>物理地址PA = b*L+d<br><img src="https://img-blog.csdnimg.cn/20200821131123953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>十六进制计算过程：<br>E.g<br><img src="https://img-blog.csdnimg.cn/20200821131155396.png#pic_center" alt="在这里插入图片描述"></p>
<p>根据页面大小得到位数。这里是12。LA转换成二进制，后12位不变，为d；前四位根据页表查询块号（页号推出页框号）。物理地址PA就是它们再转换成16进制。该过程通常由硬件完成。</p>
<p>如果给出物理地址—-&gt;对应的虚拟地址：根据页面大小得到位数。LA转换成二进制，后面的偏移地址不变。由前面的页框号推出页号。虚拟地址就是再转换为16进制。</p>
<p>四、快表<br>· 无快表的分页式<br>两次访问内存：①形成物理地址(PA)要访问页表，页表在内存中。②PA访问数据，也在内存。<br>普通内存：平均o（n），最好o（logn）</p>
<p>· 快表机制：<br>    1. o（1）即可以得到内存<br>    2. 快表是页表的子集，存放当前访问最频繁的页表项<br>    3. 介质不是内存。是有并行查询能力的高速寄存器组，称为相联存储器，构成一张快表，按内容查找</p>
<p>· 快表机制的地址转换：<br>根据页号P查快表。若命中，得到块号b（快表时间+访问内存时间）；若未命中，接着查页表，得到b（页表时间+访问内存时间）因为查页表和快表的操作是并行的。<br><img src="https://img-blog.csdnimg.cn/20200821131221136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>五、页面的共享与保护<br>页式分配的离散分配灵活的特点，允许两个及以上进程共享程序库中的例程（复杂），或公共数据的同一副本（简单，可以将共享的数据页面安排在地址空间的任意一个页面上）<br>分页不利于页面共享。对于库例程必须使共享页面具有相同的页号，或者要在地址之间重叠。</p>
<p>5.3 段式存储管理<br>一、基本思想<br>    1. 作业空间划分成若干段，每段定义一组逻辑信息。每个段地址不一定连续，段内编号连续<br>    2. 装人程序分段装入<br>    3. 系统以段为单位分配内存，每个段分配一个连续内存。段表记录起始地址<br>    4. 标识进程的地址时，要同时给出段名和段内地址。地址空间是二维的<br>    5. 段长由相应的逻辑信息组决定</p>
<p>二、段的地址转换<br>设置段表，包含段号，段始址，段长度。查找段表，找到每个段对应的内存区，实现从逻辑段–&gt;物理内存区的映射。<br>与页式存储管理相同。</p>
<p>分配和回收与可变分区类似</p>
<p>三、段的共享和保护<br>共享：<br>共享段表<br>保护：<br>    1. 越界检查<br>    2. 存取控制检查<br>    3. 环保护机制<br>    将所有进程进行分层。<br>    0环：属于操作系统内核，管理I/O操作、存储管理功能，可使用特权指令，访问所有段和页面。<br>    1环：某些重要的实用程序、操作系统服务，如系统调用管理程序。<br>    2环：共享库的过程和函数<br>    3环：一般应用程序<br>    访问较高特权环，需要采用调用服务的方式。</p>
<p>四、段和页的比较<br>相同：<br>    1. 离散分配<br>    2. 地址映射机构实现地址转换<br>不同：<br>    1. 页是物理单位，为了减少内存碎片<br>    段是逻辑单位，为了满足用户需求<br>    2. 页的大小固定，在系统初始化时完成<br>    段的大小取决于用户所编写的程序<br>    3. 页式管理中，逻辑地址是一维的<br>    段式管理中，逻辑地址是二维的</p>
<p>五、碎片<br>碎片：无法被利用的存储空间<br>固定分区管理：有内存碎片——每个分区中<br>可变分区管理：有外部碎片——这些空闲空间过小，不能被利用<br>分段式：有外部碎片——可以通过分区移动技术，将若干碎片拼凑利用<br>分页式：有页内碎片（属于内部碎片）——最后一页往往装不满 </p>
<p>说明：内部碎片不好消除，外部碎片可以通过分区移动消除</p>
<p>5.4 虚拟机存储管理<br>· 虚拟存储（VM）：用外存来虚拟内存，逻辑上扩充内存容量<br>· 程序访问局部性原理：指CPU对指令和数据在时间、空间、顺序上往往集中在一定的范围内。<br>    - 时间局部性：某条指令/某个数据结构被访问，则在不久一段时间内可能再次被访问<br>    - 空间局部性：某个存储单元被访问，则在不久一段时间内，附近的存储单元可能被访问<br>    - 顺序局部性：程序执行是在内存中的连续地址进行的；只有遇到跳转才会到一个不连续的地址空间<br>基于此，可以只把当前作业所需的程序和数据装入内存就能启动运行：<br>    • 一次性装入内存<br>多次装入内存 / 理论基础是局部性原理 （时间顺序局限性）/ 基于结构化程序设计（三种基本结构——顺序分支循环）<br><img src="https://img-blog.csdnimg.cn/20200821131221136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>· 基本思想：<br>    1. 基于程序执行的局部性原理，将当前正在使用的部分装入内存就能启动运行（部分装入）<br>    2. 如果访问的程序和数据不在内存中，则系统将这部分装入内存。（请求调入）<br>    3. 如果内存中没有足够存储空间，则需要将内存中暂不用的信息移到外存（部分对换）<br>    特点：离散，虚拟，多次，对换<br><img src="https://img-blog.csdnimg.cn/20200821131502640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>· 特点：<br>    1. 离散性：内存分配采用离散分配，将一个进程分成多个部分<br>    2. 虚拟性：逻辑上扩充内存容量<br>    3. 多次性：进程多个部分分多次调入内存<br>    4. 对换性：允许进程部分在运行过程中换入换出到对换区</p>
<p>· 实现方法：请求页式/段式/段页式存储管理<br>· 请求分页式存储：<br>    • 请求页式存储管理的页表<br><img src="https://img-blog.csdnimg.cn/20200821131616317.png#pic_center" alt="在这里插入图片描述"><br>    · 中断位：判断页是否在内存中，若不在则产生缺页中断<br>    · 访问位：<br>    记录该页在一段时间被访问的次数，或记录该页最近已经有多长时间未被访问。<br>    提供给置换算法在选择换出页面时参考<br>    · 修改位：表示该页在调入内存后是否被修改过<br>    · 外存地址：指出该页在外存上的地址<br>    • 地址转换：快表命中；页表命中；缺页中断<br>    • 页面调入策略：<br>    · 请页式调入：确保只有被访问的页才调入内存<br>    · 预调式调入：系统动态预测进程最可能要访问的那些页面，使用前预先调入，常一次调入连续多个页面</p>
<pre><code>• 页面清除策略：清除内存中某些页面。要考虑何时把修改过的页面写回外存
· 请页式清除：仅当一页选中要被置换，且之前它被修改过，才把这个页面写入外存。                                                
· 预约式清除 ：对更改过的页面，在被置换前就把它们都写回外存。

• 页面分配策略
分配物理块数
    a. 固定分配
    b. 可变分配
淘汰页面置换
    c. 局部置换：本进程内
    d. 全局置换：页面置换算法作用范围是整个系统
ab,bc,bd √
固定分配全局置换 ×

• 页面置换算法
① 最佳页面置换算法（OPT）：永不使用的或最长时间内不再被访问的页面被置换（将来）</code></pre><p>【理想化，性能评价依据】</p>
<pre><code>② 先进先出（first-in first-out FIFO 算法） 内存中驻留时间最久的页面（过去）                                                    Belady 贝莱德异常 分配物理块数增加了，缺页次数增加了

③最近最久未使用页面置换算法（least recently used LRU ）最近一段时间内最长时间没有被访问过的页面（过去）
符合局部性原理
工程实际上使用的是该算法的改进（时钟置换算法 clock，二次机会法 ）
④时钟置换算法 （也称最近未使用算法NRU）是LRU和FIFO的折衷
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020082113194446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center)

·内存中所有的页面链接为循环队列                                      
· 每页设置一位访问位，若某页被访问，置1
· 一个页面首次装入内存，其访问位置1
过程：
1）置换时，从指针当前指向的页面开始扫描。
2）先检查访问位。把遇到的所有“访问位”为1的页面“访问位”清0，检查下个页面；遇到“访问位”为0的页面置换掉，指针推进一步。

⑤改进的时钟算法
把访问位（引用位）和修改位结合起来使用：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200821132135239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center)
1）选择最佳淘汰页面，从指针当前位置开始，扫描循环队列。
扫描过程中不改变引用位，把遇到的第一个r=0，m=0作为淘汰页面。
2）如果1失败，再从原位置开始，查找r=0且m=1的页面，把遇到的第一个这样的页面作为淘汰页面，而在扫描过程中，把所扫过的页面的引用位r置0。
思考：为什么会有修改过但未被访问过的情况（r=0，m=1）？
因为每次算法结束后都没有更改过修改位，最多只是置零访问位
⑥最少使用置换算法（LFU）当前为止访问次数最少的页面

• 性能分析
缺页率和进程 工作集的关系：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200821132154808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center)</code></pre><p>6.1 设备管理<br>按传输速率分：<br>    1. 低速设备：(几B<del>几百B) 键盘、鼠标、语音输入/输出设备<br>    2. 中速设备：(千B) 打印机<br>    3. 高速设备：(数十MB</del>数百MB) 磁盘<br>按信息交换单位分：<br>    1. 字符设备：键盘、鼠标、打印机<br>    I/O采用中断驱动方式；不可寻址(不能指定源、目地址)<br>    2. 块设备：磁盘<br>    I/O采用DMA方式；可寻址<br>从资源分配角度分：<br>    1. 独占设备：一段时间内只允许一个进程访问<br>    打印机<br>    2. 共享设备：一段时间内允许多个进程交替访问<br>    磁盘<br>    3. 虚拟设备：虚拟技术将独占设备（本质上）改造成共享设备（用户角度）<br>    共享(虚拟)打印机：用磁盘来虚拟打印机</p>
<p>设备的功能和任务<br>    1. 实现设备并行性，提高系统利用率<br>    ①设备与CPU并行<br>    ②设备之间并行<br>    2. 采用动态分配方式分配设备，提高设备利用率<br>    3. 采用缓冲技术，提高系统效率<br>    4. 为方便用户使用，屏蔽设备物理特性，实现设备独立性</p>
<p>6.2 I/O控制方式<br>宗旨：减少主机对外设的干涉，以便有更多时间进行计算处理。<br>分类：<br>    1. 程序之间查询控制方式（询问方式）<br>    主机重复查询外设直到准备就绪。<br>    · 没有中断，没有实现CPU与设备的并行<br>    · 传送单位是字，每传一个字需要CPU干涉<br>    2. 中断方式<br>    · 引入中断机制，实现了CPU和设备并行<br>    · 传送单位是字，每传一个字需要CPU干涉<br>    3. 直接内存读取DMA方式<br>    特点：<br>    · 数据传输的基本单位是数据块<br>    · 传输的数据直接从内存到外设，或相反<br>    · 只在传输开始、结束时需要CPU干涉<br>    DMA控制器组成：主机与DMA的接口、DMA与设备的接口、I/O逻辑<br>    设置四个寄存器，实现CPU与控制器之间的块传输：<br>        1. 命令/状态寄存器（CR）<br>        接收CPU发出的I/O指令，或相关控制信息，或设备状态<br>        2. 内存地址寄存器（MAR）<br>        输入时，存放把数据从设备传到内存的起始目标地址；<br>        输出时，存放即将传输到设备的数据在内存源地址<br>        3. 数据计数器（DC）<br>        存放本次CPU要读写的字节数<br>        4. 数据寄存器（DR）<br>        暂存从设备到内存，或相反的数据</p>
<pre><code>4. 通道方式
通道又称“输入输出处理器”，独立于CPU的特殊处理器。
· 指令单一，只涉及输入输出
· 没有独立内存，与主机（CPU）共享内存

按信息交换方式分：
    1. 字节多路通道
    多连接低、中速外设
    2. 数组选择通道
    多连接高速外设
    3. 数组多路通道
    多连接中、高速外设</code></pre><p>6.3 缓冲技术<br>基本思想：输出数据时，在内存中开辟一个输出缓冲区，将要输入到外设中的数据输入到该区中，等到装满系统再写到I/O设备上。输入类似。<br> 四种机制：<br>    1. 单缓冲<br>    未采用缓冲：<br>    数据进入工作区T；数据进入计算C<br>    总时间: T+C<br>    采用缓冲：输入、计算并行<br>    数据从设备进入缓冲区 T；数据缓存区到工作区M<br>    总时间：Max(T,C)+M  （M远小于T，C）<br>    <img src="https://img-blog.csdnimg.cn/20200821132512739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>    2. 双缓冲<br>    在单缓冲基础上进一步提高并行程度<br>    3. 循环缓冲<br>    组成：<br>    ①多个缓存区。每个大小相同。<br>    空缓冲区R；已装满缓存区G；计算进程正在使用的缓存区C<br>    ②多个指针。<br>    Nextg：指向计算进程下一个可用的G；<br>    Nexti：指向输入进程下次可用的R；<br>    Current：指向计算进程正在使用的缓存区C<br>    过程：<br>    ①GetBuffer。<br>    对于计算进程，调用GetBuffer过程：<br>        1. 通过<code>Nextg</code>获得要进行计算的缓存区，相应地将该缓冲区改成C，将Current指向该缓冲区<br>        2. <code>Nextg</code>指向下一个G缓存区<br>    <img src="https://img-blog.csdnimg.cn/20200821132713788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<pre><code>对于输入进程，调用GetBuffer过程：
1. 通过`Nexti`获得可用的缓存区，相应地将该缓冲区改成C，将Current指向该缓冲区</code></pre><p><code>Nexti</code>指向下一个R缓存区<br>    <img src="https://img-blog.csdnimg.cn/20200821132858712.png#pic_center" alt="在这里插入图片描述"><br>    ②ReleaseBuffer。<br>    当计算进程提取完毕后，当前缓存区空出。调用ReleaseBuffer过程，将C改为R。<br>    类似输入进程输入完毕，调用ReleaseBuffer过程，将该缓存区改为G。<br>    <img src="https://img-blog.csdnimg.cn/20200821132933364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>    4. 缓冲池<br>    缓冲池是一个临界资源，进程同步<br>    组成：<br>    <img src="https://img-blog.csdnimg.cn/20200821133113177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>    两个基本操作：<br>    ①Getbuf（type）：从type指定的队列的队首摘下一个缓存区<br>    ②Putbuf（type，number）：将number所指示的缓存区挂在type队列上<br>    过程：<br>    收容输入：设备上的数据进入缓存区<br>    提取输入：缓存区的数据进入工作区<br>    <img src="https://img-blog.csdnimg.cn/20200821133138496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>6.4 驱动调度技术<br>6.4.1磁盘的物理结构<br>1。物理结构<br>顺序存取存储设备：严格依赖信息的物理位置进行定位和读写，容量大，稳定，便于保存（磁带）<br>直接 (随机) 存取存储设备：读取任何物理块所需时间几乎不依赖信息的位置（磁盘）<br><img src="https://img-blog.csdnimg.cn/20200821133201782.png#pic_center" alt="在这里插入图片描述"><br>盘片：每个盘片有两个盘面<br>盘面：每个盘面有若干磁道(同心圆)、一个磁头（磁头号与盘面号一一     对应）<br>磁头：所有读写磁头固定在唯一的移动臂上同时移动<br>磁道：每个磁道分成若干物理块<br>扇区（物理块）：若干个扇区组成一个块<br>块（簇）：块是磁盘读写的基本单位<br>柱面：不同磁盘上的相同磁道号（磁头位置下的所有磁道）组成一个柱面<br>注：<br>· 文件的信息通常记录在同一个柱面的不同磁道上。（多磁头并发访问）<br>· 访问磁盘上的一个物理记录，需要三个参数：柱面号、磁头号、块号。<br>柱面号决定在哪个磁道上，磁头号决定在哪个盘面上，块号决定读写哪个块。<br>2.磁盘访问时间<br>（1）寻道时间 Ts<br>把磁臂（磁头）移到指定磁道上的时间。是启动磁臂的时间<code>s</code>和磁头移动<code>n</code>条磁道所花费的时间和：<br><code>Ts = m*n + s</code><br>· m是常数，与磁盘驱动器有关，对一般磁盘，m=0.2；对高速磁盘，m&lt;=0.1。<br>· 磁臂启动时间约为2 ms<br>· 一般温盘，Ts=5~30ms<br>（2）旋转延迟时间<br>指定扇区移动到磁头下面所经历的时间。</p>
]]></content>
  </entry>
  <entry>
    <title>《图解TCP/IP》概述</title>
    <url>/2020/06/29/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP-IP%E3%80%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p><font color=green >思考</font></br><br><font color=#FF9000 >问题</font></br><br> 已解决⭐ </br><br> <font color=#FF4500 >重点</font></p>
</blockquote>
<p>目录</p>
<ul>
<li><a href="#623">6.23</a><ul>
<li><a href="#第一章-网络基础知识">第一章 网络基础知识</a></li>
</ul>
</li>
<li><a href="#624">6.24</a><ul>
<li><a href="#第二章-tcpip基础知识">第二章 TCP/IP基础知识</a></li>
</ul>
</li>
<li><a href="#626">6.26</a><ul>
<li><a href="#第三章-数据链路">第三章 数据链路</a></li>
</ul>
</li>
<li><a href="#628">6.28</a><ul>
<li><a href="#第四章-ip协议">第四章 IP协议</a></li>
</ul>
</li>
<li><a href="#629">6.29</a></li>
<li><a href="#71">7.1</a><ul>
<li><a href="#第五章-ip协议相关技术">第五章 IP协议相关技术</a></li>
</ul>
</li>
<li><a href="#72">7.2</a><ul>
<li><a href="#第六章-tcp与udp">第六章 TCP与UDP</a></li>
</ul>
</li>
<li><a href="#73">7.3</a></li>
<li><a href="#74">7.4</a><ul>
<li><a href="#第七章-路由协议">第七章 路由协议</a></li>
</ul>
</li>
<li><a href="#75">7.5</a></li>
<li><a href="#75-1">7.5</a><ul>
<li><a href="#第8章-应用层协议">第8章 应用层协议</a></li>
<li><a href="#第9章-网络安全">第9章 网络安全</a><h1 id="6-23"><a href="#6-23" class="headerlink" title="6.23"></a>6.23</h1><h2 id="第一章-网络基础知识"><a href="#第一章-网络基础知识" class="headerlink" title="第一章 网络基础知识"></a>第一章 网络基础知识</h2></li>
</ul>
</li>
</ul>
<p>协议如同交流中的语言。是一组事先约定的通信规则的集合。<br>TCP/IP并非ISO（国际标准化组织）制定，而是IETF所倡导推进的业界公认标准。<br>协议的分层：优劣<br>osi参考模型与osi协议区别</p>
<ul>
<li>osi协议是以osi参考模型为基础制定的每个阶层的协议和每两层之间的接口的标准。</li>
<li>osi参考模型粗略定义了每层的“作用”,即每层需要涉及哪些功能的“协议”；“协议”对每一层的“作用”进行详细定义。<br>传输层只管数据在通信双方节点间数据的可靠传输。<br>网络层与数据链路层的区别 </li>
<li><font color=#FF9000>网络层负责端到端数据的传输，将整个数据发送到最终目标地址（怎么实现的?）</font>而数据链路层是每个区间内的通信，进行数据处理。</li>
</ul>
<p><font color=green >思考：</font>会话层负责数据何时发送，连接断开的时间，而数据链路层进行路由，网络层负责将数据端到端传输。<font color=#FF9000>那为什么网络层还不保证数据可达性？</font><br><font color=#FF4500 >网络层负责地址管理和路由选择，数据链路层进行互联设备间的传送。</font></p>
<p>MAC（介质访问控制）地址/物理地址/硬件地址：识别连接到同一传输介质上的设备。物理层中包含该地址信息的首部附加到从网络层转发过来的数据上。</p>
<p><font color=green >总结思考:</font>ISO参考模型：第七层应用层：文件传输等；第六层表示层：规定数据传输的标准格式设备特有格式和标准数据格式的转换；第四层第五层会话层：确定何时建立和关闭链接，<font color=#FF4500 >通信管理</font>；第五层第四层传输层：保证数据的正确传输；第三层网络层：端到端数据的传输；第二层数据链路层：控制在同一传输介质中的各台设备之间的通信，数据的传输；第一层物理层：附加包含MAC地址的首部，比特流与电磁波等传输介质的互换，根据目的地址进行数据传输。</p>
<h1 id="6-24"><a href="#6-24" class="headerlink" title="6.24"></a>6.24</h1><p> TCP/IP采用分组交换技术。<br>· 电路交换需要提前建立链接。<br>· 计算机与路由器、路路之间常为一条通信线路。<font color=#FF9000>电路交换呢？</font><br>· 地址的特性：唯一性（MAC,IP地址），层次性（IP地址）<br>MAC是负责最终通信的地址，是由设备制造商对每块网卡进行指定的。但由于它的不分层，所以IP地址在寻址过程中必不可少。<br>· <font color=#FF9000>⭐交换机和路由器区别？</font><br>· <font color=#FF4500 >MAC寻址参考地址转发表，IP寻址参考路由控制表。<br>交换机查看地址转发表，路由器和主机查看路由控制表。p53</font><br><font color=#FF9000>· 主机将数据给了交换机，交换机怎么根据mac地址转发表确定发送给哪个路由器？</font><br><font color=#FF4500>转发表中有各个设备的MAC地址，不需要手动设置，会每次根据这次的记录自动生成（自学）。以太网交换机就是网桥。可以根据数据链路层每个目标MAC地址来确定哪个网络端口发送数据。</font></p>
<p><font color=green>· 思考：</font>因为分组报文的转发，网桥是根据MAC地址处理，路由器根据IP地址处理。路由器和主机在寻址的时候。</p>
<p>· 传输速率（又称带宽）高是指单位时间传输的数据量大而不是速度快。<br>· 主机间实际传输速率又叫吞吐量。单位与带宽均为bps。吞吐量的衡量内容包括但不仅为带宽。<br>· 网卡（NIC/网络适配器/LAN卡）：计算机连入网络的设备。<br>· 中继器：物理层延长网络的设备，可以增强信号，有的还可以转换信号，但不能校验和在不同传播速度的媒介间转发。<br>提供多端口的也称作集线器（Hub）。<br>· 网桥/二层交换机：第二层数链层连接两个网络的设备。没有连接网段个数限制，基本只连接相同类型的网络，有时也可以连接传输速率不同的网络。可校验帧，控制网络流量（通过地址自学机制，<font color=#FF9000>⭐过滤功能</font>）<br><font color=#FF4500>过滤功能指带有一定特殊参数的IP数据报才能通过路由器。参数可以是发送端主机、接收端主机、TCP\UDP端口号、TCP的SYN(连接请求包)或ACK标志等。</font><br>· 交换集线器（具有网桥功能的Hub）也属于网桥一种。<br>· 路由器/三层交换机：第三层网络层面连接两个网络，转发分组报文的设备。</p>
<p><font color=green>· 思考：</font>路由器连接两个网络。路由器需要根据分层的IP地址，查找路由控制表，把分组报文发送到另一个路由器。网桥是数据链路层连接两个网络，又因为数链层是实现一个区域内的通信，不需要分层，只需要唯一性的MAC地址就可以完成。<font color=#FF4500>见底下分层包中的结构图</font><br>· 路由器是网络层设备，所以TCP/IP中，网络层的地址就成了IP地址。网桥是数据链路层设备，MAC地址是物理地址。<br>路由器会分割数据链路，使得数链层的广播无法继续传播。这也分担了网络负荷。有的也具备一定网络安全功能。<br>· 4<del>7层交换机：分析收发数据，进行特定处理，如带宽控制。如负载均衡器。<br>· 网关：和4</del>7层交换机一样，负责传输层及以上的对数据进行控制处理，但还有协议的翻译。<br>代理服务器是一种应用网关（在相同的协议之间转发数据）。为了控制流量。<br><font color=#FF9000>具体代理服务器的处理？</font><br><img src="https://img-blog.csdnimg.cn/20200629215143293.png" alt="在这里插入图片描述"><br><font color=#FF4500>代理服务器代替服务器提供服务</font><br><font color=green>思考：</font>信号物理层调整（放大转换），然后向上到数据链路层储存重构，去掉错误的帧，转发到物理层。物理层判断网络路径，再转发至目标地址.</p>
<p>· 以前访问由个人，企业自行管理的服务器居多，现在多为利用数据中心发布信息。<br>· 云：利用虚拟化技术，资源（包括cpu,内存）虚拟化，实现按需分配资源</p>
<h2 id="第二章-TCP-IP基础知识"><a href="#第二章-TCP-IP基础知识" class="headerlink" title="第二章 TCP/IP基础知识"></a>第二章 TCP/IP基础知识</h2><p>· TCP/IP网络出现背景：电路交换网络容灾性差，分组交换技术不仅在这方面有优势，而且可以同时并发通信提高效率。<br>· 阿帕网是互联网网的鼻祖。</p>
<h1 id="6-26"><a href="#6-26" class="headerlink" title="6.26"></a>6.26</h1><p>· 互联网的每个网络由主干网和末端网构成，每个网络间由NOC连接。然后每个ISP的异构网络又需要IX连接。<br>NOC：网络操作中心 ；IX：网络交换中心；ISP：网络提供商<br>· <strong>TCP/IP协议分层模型</strong><br><img src="https://img-blog.csdnimg.cn/20200702093341765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;· 硬件<br>&emsp;· 网络接口层：为NIC使用提供驱动程序<br>（硬件+网络接口层：网络通信层）<br>&emsp;· 互连网层<br>   &emsp;&emsp;· IP协议：非可靠性传输协议，不会重发。与互联网连接的主机、路由器必须实现IP功能，其他的设备不必要。<br><font color=#FF9000>为什么？</font><br><img src="https://img-blog.csdnimg.cn/20200629215518558.png" alt="在这里插入图片描述"></p>
<p>  &emsp;&emsp;· ICMP协议：IP数据包如果传送不到目的端，就发送通知异常<br>&emsp;· 传输层<br>   &emsp;&emsp;· TCP协议：互连网层面向有连接的传输层协议。能够保证通信可达，能正确处理传输过程中的异常状况<br>   &emsp;&emsp;· UDP协议：面向无连接。<font color=#FF9000>为什么？</font><br><img src="https://img-blog.csdnimg.cn/20200629221529923.png" alt="在这里插入图片描述"></p>
<p>&emsp;· 应用层（osi模型会话层及以上）<br>  &emsp;&emsp; · 浏览器和服务器间通信用的是HTTP协议（属于OSI模型的应用层），传输的主要数据格式是HTML（属于OSI模型的表示层）<br>  &emsp;&emsp; · 发送电子邮件用的协议是 SMTP（Simple Mail Tranfer Protocol），现在电子邮件的格式由MIME协议扩展后（属于OSI模型的表示层）<br>  &emsp;&emsp; · 文件传输 FTP 。在传输文件时候，会建立两个TCP连接，一个是发送连接请求时需要用到的控制连接，一个是传输数据时需要用到的数据连接。这两种连接都属于会话层功能。<br>   &emsp;&emsp;· 远程登陆 TELENT和SSH协议<br>   &emsp;&emsp;· 网络管理 采取SNMP协议（Simple Network Management Protocol）。管理设备的一段叫做管理器，被管理的设备叫做SNMP代理。在代理端保存着网络接口信息、异常数据量等，管理器访问这些信息需要通过MIB（Management Information Base）访问。在TCP/IP网络管理中，SNMP属于应用层协议，MIB属于表示层协议。<br><img src="https://img-blog.csdnimg.cn/20200629215620856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="!\["></p>
<p>分层包中的结构:<br><img src="https://img-blog.csdnimg.cn/20200629215650461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><font color=#FF9000>很多NIC产品不是发给自己的包也不丢弃数据，为什么能用于监控网络流量？</font></p>
<p><font color=green>思考 e.g：</font><br>· 甲用计算机A向乙的计算机B发送电子邮件的过程：<br>    1. 应用程序处理<br>    在点击发送那一刻，开始TCP/IP通信。<font color=#FF4500>首先进行编码处理（表示层）；之后由于软件的不同，何时发送数据不同（会话层）；应用在发送数据那一刻建立TCP连接，利用连接发送数据。</font><del>查找接收端的邮箱地址，存在则开始发送数据包。</del><br>    2. TCP模块的处理<br>    TCP根据应用的指示（会话层），提供将数据准确端到端发送的可靠传输。数据前附加一个TCP首部，包含源，目标端口号，序号，校验和，如果数据异常则请求重新发送，正常则发送到下一层网络层。<br>    3. IP模块的处理<br>    查找接收端<del>IP</del><font color=#FF4500>MAC</font>地址，如果尚不知道，可以利用ARP（address resolution protocol）协议来查找，把IP地址和上层用到的TCP/UDP协议类型封装到IP首部，<font color=#FF4500>判断后面封装的数据是TCP/UDP的信息</font>，全部交给下层进行传输。<br>    4. 网络接口（以太网驱动）的处理<br>    以太网首部包括发送端、接收端的MAC地址，<font color=#FF4500>以及标志以太网类型的以太网数据的协议，</font>尾部添加循环校验码<font color=#FF4500>（处理中的FCS）</font><br>· 计算机B接收的过程<br>    1. 网络接口（以太网驱动）的处理<br>    <font color=#FF4500>接收到以太包后，从首部找到mac地址判断是否为自己的包，不是则丢弃。是的话，查看标志类型域，确定数据类型。此例中是IP包，交给IP处理。</font>议类型无法识别，丢弃。<br>    2. IP模块的处理<br>    判断IP地址是否与自己匹配，若匹配，接收数据并查找上一层协议，如果是TCP就交给TCP处理。<font color=#FF4500>对于有路由的情况下，路由器查路由控制表，如果不是本网络接收，则发送到下一个网络。</font><br>    3. TCP模块的处理<br>    计算校验和，<font color=#FF4500>检测是否按照序号在接收数据，检测端口号确定应用程序。</font><del>如果数据被破坏则请求重新发送。路由器查路由控制表，如果不是本网络接收，则发送到下一个网络。</del><font color=#FF4500>数据接收完毕，发送“确认回执”给发送端，如果该信息未能到达，发送端就会一直发送。<br>    数据完整接收后，传到端口号识别的应用程序。</font><br>    4. 应用程序处理<br>    <font color=#FF4500>直接接收发送端的数据。解析后获得收件人为乙的地址。如果B上没有乙的邮箱，B返回发送端“无此收件地址”的报错。有的话，</font>邮件保存到本地硬盘上。若保存正常运行，返回“处理正常”的回执，否则“处理异常”。</p>
<p>SNS（Social Network Service）社交网络，基于TCP/IP应用。<br><img src="https://img-blog.csdnimg.cn/2020062922022373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="第三章-数据链路"><a href="#第三章-数据链路" class="headerlink" title="第三章 数据链路"></a>第三章 数据链路</h2><p>· 数据链路，指OSI参考模型中数据链路层，有时也指以太网、无线局域网等通信手段。也可以被视为网络传输中的最小单位，互联网“数据链路的集合”<br>· MAC地址基本上是独一无二的。如果一台主机启动多个虚拟机，只能由虚拟软件设置MAC地址给多个虚拟网卡，这时候很难保证MAC地址的独一无二了。<br>· 共享介质型网络： 基本采取半双工通信，并对介质进行访问控制，包括争用方式和令牌传递方式。<br>  · 争用方式，也叫CSMA（载波监听多路访问）<br>  · 改良版CSMA——CSMA/CD方式：发送数据时候一直检测电压（这种硬件属于同轴电缆），若超出规定范围认为是发生冲突。发生后，发送一个阻塞报文，放弃发送帧，在随机延时一段时间后发。<br>  · 令牌传递方式<br>· 非共享介质网络：网络中每个站直连交换机，交换机来转发帧。 发送端和接收端并不共享网络，一般采用全双工模式<br>  · 交换集线器,也叫以太网交换机。就是有多个端口的网桥。<font color=#FF9000><br>TCP或UDP等传输协议中的端口另有其他含义。是指什么？</font><br>  · MAC地址没有层次性，所以转发表的大小和设备数量有关。如果终端过多，可考虑将网络分成多个数据链路，分层管理。<br>  · 交换机转发方式有直接转发和存储转发（需检验FCS位）<br>· 解决网络中的环路问题：<br>  1.生成树；<br>  2.源路由：可以判断源地址是通过哪个网桥实现传输的，并将帧写入RIF（Routing Information Field），网桥根据这个RIF来发送帧给目标地址。<br>· VLAN可以通过不修改硬件线路，只修改网络结构来进行分散网络负载等操作。VLAN技术附加到网桥/2层交换机上，可以切断所有VLAN间的通信，从而提高网络的承载效率。（<font color=#FF9000>是因为减小了网络负载吗</font>⭐<font color=#FF4500>是的。它可以按端口号区分多个网段，从而区分广播数据传播范围</font>）但异构的网段间必须利用具有路由功能的交换机（如3层交换机）或通过路由器才能通信.<font color=#FF9000>为什么路由功能可以？</font><br>· TAG VLAN：跨交换机的VLAN。在交换机传输帧时，以太网首部加入VID标签识别帧发送到哪个网段。<br>· 以太网：是一种作为传输方式的数据链路。使用同轴电缆或双绞线电缆，可以决定其中0，1可以被解释为何种电子信号。<br>· 计算机内部表现值为二进制：1K=1024，1M=1024K<br>· 传输速度以时钟频率决定，1K =1000,1M=1000K<br>· FDDI 光纤分布式数据接口：有时间限制的令牌环访问方式。是目前传输速率最快的LAN技术中的一种，100Mbps。而且由于有主环和备用环，故障容错能力很强。<br>· 以太网、FDDI与OSI模型中数链层和物理层均有关。<br>· 以太网帧前面有个前导码部分。由8个8位字节组成，末尾有个起始帧定界符（Start Frame Delimiter）11。以太网中将最后2bit”11”称为SFD，IEEE802.3将最后8bit称为SFD<br><img src="https://img-blog.csdnimg.cn/20200629220448662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>· 数据链路层又细分为介质访问控制层(MAC， Media Access Control)和逻辑链路控制层（LLC，Logical Link Control）。<br>· MAC层根据不同数据链路特有的首部信息进行控制，LLC层根据不同数据链路共有的首部信息进行控制。<br><img src="https://img-blog.csdnimg.cn/20200629220509259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_8,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>· 无线通信<br>  · WiMAX：使用微波在家庭或者企业实现无线通信的一种方式，属于无线MAN<br>  · ZigBee ：主要应用于家电的远程控制。短距离低功耗的无线通信技术。<br>· PPP点对点协议，属于osi模型中纯粹的数据链路层。· 数据开始传输前先建立一个PPP连接。之后可进行身份验证等。PPP主要功能中包括不依赖上层的LCP（Link Control Protocol）协议和依赖上层的NCP（Network…）协议。当上层为IP,此时的NCP也叫IPCP协议。<br>  · LCP负责建立，检测，断开数据链路连接，设置最大接受单元MRU（Maximum Receive Unit），设置验证协议（PAP或者CHAP），设置是否进行通信质量监控<br>  · NCP建立和配置不同网络层协议<br>  · IPCP负责IP地址设置以及是否进行TCP/IP首部压缩等协商。<br>  · PAP密码认证协议 （password authentication protocol）：建立连接时两次握手，明文传输<br>  · CHAP挑战握手认证协议（Challenge Handshake ）：使用一次性密码OTP。建立连接后也可以继续进行密码交换。<br>· HDLC就是每个帧前后加8字节01111110（标识码）进行区分，发送帧时，如果帧内出现5个连续的1，后面必须插入一个0。而在接收帧时，去掉0(增删0，计算FCS会给COU处理，增加计算机负担）。而PPP是基于高级数据链路控制协议（HDLC）制定出来的，所以格式与此相同，如下：<br><img src="https://img-blog.csdnimg.cn/20200629220553195.png" alt="在这里插入图片描述"></p>
<p>· 有的互联网接入服务商会在以太网中利用PPPoE（PPP over Ethernet）提高PPP功能。因为单纯以太网没有验证功能，也没有建立断开连接的处理，无法按时收费。利用PPP可帮各家ISP有效管理用户。<br><img src="https://img-blog.csdnimg.cn/20200629220608609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>· ATM（Asynchronous Transfer Mode）是以一个叫信元的单位进行传输的面向连接的数据链路。多用于广域网的连接。没有发送权限设置，易引发网络拥堵。ATM扩展了TDM（时分复用设备），时隙不要求连续，一个帧所占用的时隙也不固定。只是增加了5字节的首部，增加了网络开销，一定程度上降低了通信速度，但提高了线路利用率。<br><img src="https://img-blog.csdnimg.cn/20200629220649170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200629220706859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是一旦有一个信元出错，就会重发最多192个信元。<br>· POS（package over SDH/SONET）是一种在SDH（SONET）上进行包通信的一种协议。<br>SDH（synchronization digital hierarchy，同步数字体系）；SONET(synchronization optical NETwork，同步光纤网络)<br>SDH（SONET）是光纤上传输数字信号的物理层规范。<br>· FDDI 分布式光纤数据接口 ，令牌环网拓展产物<br>（基本不用）<br>· Toking Ring令牌环网（基本不用）<br>· 光纤通道 ：实现高速数据通信的一种数据链路。广泛用于搭建SAN（Storage Area Network，存储域网络，服务器与多台存储设备间高速传输数据的网络）<br>· HIPPI 连接超大计算机<br>· HDMI （High-definition Multimedia Interface，高清晰度多媒体接口）通过一根缆线实现数字信号高品质传输，1.4版后可以传输以太帧。<br>· iSCSI 将个人电脑连接硬盘的SCSI标准应用于TCP/IP网络上的一种标准。把SCSI命令和数据包含进IP包进行数据传输。可以使用网络上直连的大规模硬盘。<br>· DOCSIS是有线电视传输数据的行业标准。<br>· ADSL 对模拟电话线扩展，在家到电信局交换机之间，设置分离器，让音频信号（低频）和数字信号（高频）不互相干扰。<br>· FTTH 光纤到家</p>
<h1 id="6-28"><a href="#6-28" class="headerlink" title="6.28"></a>6.28</h1><p>公共网络<br>· VPN虚拟专用网络，连接距离较远的地方<br>   · IP-VPN<br>     在IP网络（互联网）上建立VPN。服务商提高MPLS（multiprotocol label switching，多协议标签交换）网，根据IP包中的Label，从而进行用户区分，形成密闭私有网络。<br>   · 企业互联VPN<br>     采用IPsec技术，对VPN通信中的IP包进行验证和加密，在互联网上构造一个密闭私有网络。<br>   · 广域以太网<br>     IP-VPN是IP层的连接，而广域以太网则是在作为数据链路层的以太网上利用VLAN实现VPN技术。</p>
<h2 id="第四章-IP协议"><a href="#第四章-IP协议" class="headerlink" title="第四章 IP协议"></a>第四章 IP协议</h2><p>· IP网际协议，负责将数据包发送给最终的目标计算机，因此IP能让任何两台计算机通信。<br>· <strong>主机</strong>：配有IP地址，但不能进行路由控制。<strong>路由器</strong>（IPV4中叫做<strong>网关</strong>）：配有IP地址，还能进行路由控制。统称<strong>节点</strong>。<br>· 网络层和数据链路层间的关系：<br>  数链层提供直连两个设备间的通信，而作为网络层的IP则负责在没有直连的两个网络间进行通信传输。</p>
<p>需要这两个分层才能实现向最终目标地址通信。<br>· IP寻址<br>   · <font color=#FF9000>⭐为什么不能数据链路层也用IP寻址？</font><br>    <font color=#FF4500>因为IP地址需要设备上线后，才能根据他进入了哪个子网分配的，在未分配时我们需要根据MAC地址来区分不同设备。</font><a href="https://www.zhihu.com/question/21546408/answer/149670503" target="_blank" rel="noopener">参考知乎</a><br>   · 数据链路的类型对IP地址形式透明<br>· 路由控制<br>   · IP包在网络中一个个跳间被转发。<br>   · 数据链路实现某一区间（一跳）内的通信。一跳是指源MAC地址到目标MAC地址间的传输帧的区间。也就是，主机或者路由器网卡不经过其他路由器而能直接到达的相邻主机或路由器网卡间的一个区间。<br>   · 在一个区间内，电缆通过交换集线器或者网桥相连，而不会通过路由器或者网关。<br>   · <font color=#FF9000>网桥是数据链路层上连接两个网络的，一个网络的范围到达如何定义的？</font><br>   <font color=green>思考：如果没有IP地址，网桥需要向世界发送包来获得下一个MAC地址，并且需要一张巨大的表来维护所学的MAC地址。显然网络可能会崩溃。</font><br>· 不同数据链路最大区别就是最大传输单位（MTU）不同。MTU在以太网中1500字节，FDDI中4352字节，ATM中9180字节。所以IP进行分片处理，这样可以忽略途中的MTU，抽象化了数据链路层。<br>· IP采用面向无连接的原因：1.为了简化，2. 为了提速。需要连接时，可以委托上一层提供服务。<br>· IP只是负责将数据发给目标主机，是否收到、是否错误都不考虑。上层的TCP则负责保证对端主机确实接收到数据。如果让IP具有传输功能，协议的实施和编程会变得很复杂。<br>· IP地址并非根据主机台数配置的，而是每台主机的每一块网卡（NIC）都需要设置，一块网卡可以配置多个IP地址。而且一台路由器通常配置两个以上网卡，所以IPV4的32位IP地址不够用。<br>· IP地址包括网络标识和主机标识两部分，以子网掩码区分。</p>
<h1 id="6-29"><a href="#6-29" class="headerlink" title="6.29"></a>6.29</h1><p>· IP地址分成四类地址。<br>  网络地址<br>  · A类：0.0.0.0~127.0.0.0 （开头0）后24位为主机标识<br>  · B类：128.0.0.0~191.255.0.0（开头10）后16位为主机标识<br>  · C类：192.0.0.0~223.255.255.0（开头110）后8位为主机标识<br>  · D类：224.0.0.0~239.255.255.255（开头1110）没有主机标识。<br>· 主机地址全为1，为广播地址<br>  · 本地广播的IP包会被路由器屏蔽<br>  · 直接广播可以在不同的网络直接广播。<br>· IP多播1110之后28位为多播的组编号<br>  · 将包发送给特定组内的所有主机。<br>  · 既可以穿透路由器，又可以实现只给必要的组发送数据包。<br>  · 多播使用D类地址，从224.0.0.0~224.0.0.255的范围不需要路由控制，同一链路内实现多播，在这范围之外设置多播地址会给全网所有组内成员发送多播的包。<br>  · 所有主机必须属于224.0.0.1的组，所有的路由器必须属于224.0.0.2的组。除了地址之外，还需要IGMP（Internet Group Management Protocol）等协议的支持。<br>· 子网掩码：对应的IP地址网络标识部分为1，主机地址部分为0。子网掩码必须是首位开始连续的1。<br>· CIDR（Classless Inter-Domain Routing，无类型域间选路）：采用任意长度分割IP地址的网络标识和主机标识。<br>  · 连续多个C类地址划分到一个较大网络内，并通过路由集中方式降低路由器负担。<br>· VLSM（Variable Length Subnet Mask，可变长子网掩码）  ：可随时修改组织内各部门的子网掩码的机制<br>· 私有IP地址：在同个域里保持唯一。<br>  · A类（10/8），B类（172.16/12)，C类（192.168/16）为私有IP，其他的都为全局IP。<br>  · 配有私有IP的主机和配有全局IP的互联网主机通过NAT技术可以实现通信。<br>· 全局IP地址（公网地址）：基本保证在整个互联网范围内保持唯一。任播情况，多台主机或路由器可配同一个IP。<br>  · 对于FTTH,ADSL服务，网络提供服务商直接给用户分配全局IP，用户每次重连，该IP地址都可能变化。<br>· 现在普遍采用方式：LAN中设置私有地址，通过少数设置全局IP地址的代理服务器，结合NAT的设置进行互联网通信。这时IP地址个数不限于LAN中主机个数，而是代理服务器和NAT的个数决定。<br><font color=green>思考：IP地址到底是动态的还是固定唯一的？其实要分类型讨论。</p>
<ol>
<li>我们设备上所显示出来的动态ip地址是ISP通过NAT技术整出来的内网ip，不是公网ip。公网IP由专门的机构统一分配、管理，在互联网上具有唯一性。私网IP无法联入互联网，只能在局域网使用。当然，如果需要连接互联网，每个局域网的出口，都有一个公网IP。</li>
<li>IP地址静态还是动态分配，取决于管理人员如何设置。家用WIFI之所以能在你断开网络后，仍然分配到原来的那个IP地址，这是因为设备本身的默认设置，在一定时间内，A先使用了这个IP，继续把这个IP给A用。除非A很长都不用，设备再换给B用。（地址池租期）</font><br>· 路由控制<br>· 路由控制表的形成：静态路由控制，管理员手动设置；动态路由控制：刷新<br>· 路由控制表由“路由协议”制作而成。<br>· 默认路由：一张路由表上包含了所有网络及其子网信息时使用。0.0.0.0/0<br>· 主机路由：基于主机网卡上配置的IP地址本身进行路由<br>· 环回地址：同一台计算机上进行网络通信时的一个默认地址，127.0.0.1。主机名是localhost。使用这个IP或主机名，数据包不会流向网络。<br>· 路由汇总，也叫路由表的聚合：减少路由条目，减少网络开销<br>· 数据链路不同，MTU相异。原因是不同数据链路的使用目的不同。<br>· 经过分片之后的IP数据报只会在目的主机被重组（以防丢失包，等待30s），经过路由器可以做分片但是不能重组。<br>· 路径MTU发现<br>&emsp;· 背景：分片太小，网络利用率低；太大分片容易丢失。<br>&emsp;·  Path MTU指发送端到目的端不需要分片时最大分片大  小。<br>&emsp;· 过程：以UDP情况为例，发送端IP首部设置不分片，发送IP包，如果分片过大，被丢弃。因为UDP没有请求重发机制，所以由ICMP发送不可达消息回去，并重新设置分片大小。也就是UDP层传回来的“UDP首部+UDP数据”在IP层被分片。（对于IP不区分首部和数据），如此反复，直到所有分片到达目的主机后被重组，再传给UDP层。<br>（<font color=#FF4500>缓存期10min，过后重新做路径MTU发现</font>）<br>&emsp;· 对于TCP情况，根据路径MTU大小计算出最大段长度（MSS），然后再进行数据报发送，也就是IP层不会进行分层处理。</li>
</ol>
<p>IPv4 32比特，一般写为4个8位字节；<br>IPv6 128比特，一般写成8个16位字节。<br>从4-&gt;6，需要将网络中所有主机和路由器IP地址重新设置，任务大。<br>IPv6特性：<br>· IP地址扩大，依旧适应网络分层<br>· 性能提升。包首部长度采用固定40字节，不再采用首部校验码。只由发送端进行分片处理。<br>· 支持即插即用功能。即使没有DHCP服务也可实现自动分配IP地址。<br>· 采用认证和加密功能。防伪造IP和线路窃听（IPsec）<br>· 多播、Moblie IP成为扩展功能。<br>Pv6地址表示：16比特为一组，冒号隔开，一般十六进制表示。如果出现连续的0，可以用两个冒号隔开。一个IP地址只允许出现一次双冒号。<br>IPv6地址结构<br><img src="https://img-blog.csdnimg.cn/20200629231752278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200629231805404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>· 全局单播地址：前64位为网络标识（，后64位为主机标识。从IPv6地址查看定位设备难。因为接口ID中保留64比特版的MAC地址可以是“临时地址”。<br><img src="https://img-blog.csdnimg.cn/20200629231856784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>· 链路本地单播地址：通常接口ID中保留64比特的MAC版地址。<br><img src="https://img-blog.csdnimg.cn/20200629231916215.png" alt="在这里插入图片描述"></p>
<p>· 唯一本地地址：不进行互联网通信时使用的地址。<br><img src="https://img-blog.csdnimg.cn/20200629231936454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;为了提高安全性，企业内部网络与互联网不连接，通信时通过NAT或者网关（代理）进行。<font color=#FF9000>进行的过程？</font><br><img src="https://img-blog.csdnimg.cn/20200701092144316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>版本</strong>：值为4，代表IPv4<br><strong>IHL</strong>（Internet Header Length）：表示IP首部大小，单位为4字节(32比特)<br><strong>TOS</strong>：来表明服务质量，但基本未使用。之后分成两个字段。<br>· <span id="DSCP"><em>DSCP</em>（Differential Services Dodepoint，差分服务代码点），现统称DiffServ，用来质量控制，6比特组成。</span><br><img src="https://img-blog.csdnimg.cn/20200701092248799.png" alt="在这里插入图片描述"><br>· <em>ECN</em>（Explicit Congestion Notification，显式拥塞报告），2比特组成。第6位的ECT（ECN-Capable Transport）用于通告上层TCP协议是否处理ECN。路由器转发ECN为1的包时，如果拥堵，CE（Congenstion Experienced）位置1。<br><strong>总长度</strong>：IP首部与数据部分合起来的总字节数。该字段长16比特，所以IP包最大长度2^16（65535）字节。<br><strong>标识</strong>：16比特组成，用于分片重组。不同分片标识值一定不同，标识值相同的分片也不一定是同一分片。（目标地址、源地址、协议不同都算不同分片）<br><strong>标志</strong>：<br><img src="https://img-blog.csdnimg.cn/20200701092357560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>片偏移：13比特组成，标识每一分段相对于原始数据的位置。最多可表示2^13(8192)个相对位置。<font color=#FF4500>单位为8字节</font>，8<em>81922=6536字节的位置。<br>生存时间：8比特，指可以中转多少个路由器（最多256个）。直到变为0丢弃。<br>协议：表示IP首部的下一个首部属于哪个协议。<br>首部校验和：只校验数据报的首部，不校验数据部分。确保IP数据报不被破坏。（<font color=#FF4500>1补数计算</font>）<br>*</em>源地址**<br><strong>目标地址</strong><br><strong>可选项</strong>：长度可变，通常只在进行实验或诊断时使用。包括安全级别，源路径，路径记录，时间戳。<br><strong>填充</strong>：如果有可选项，要将首部长度通过填充0，调整为32比特整数倍。<br><strong>数据</strong>：将IP上层协议也当作数据进行处理。  </p>
<p>IPv6数据报格式如下图。<strong>省略了首部校验和字段</strong>。因为TCP和UDP在做校验和计算时候使用伪首部，可以验证IP地址和协议的正确性。因此即使IP层无法提供可靠传输，TCP/UDP层也可以提供可靠传输服务。<strong>识别码成为可选项，IPv6首部和可选项均由8字节构成。</strong><br><img src="https://img-blog.csdnimg.cn/20200701092548902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>通信量类</strong>（Traffic Class）：相当于TOS字段。<br><strong>流标号</strong>（Flow Label）：准备用于服务质量（QoS）控制。不使用时每一位设为0.进行控制时，设为随机数，利用可设置流的协议RSVP（Resource Reservation Protocol）在路由器上进行QoS设置。<font color=green>流标号是个无意义索引值，用来方便路由器检索服务质量的控制信息的。</font>当流标号、源地址、目标地址三项都一致，才认为是一个流。<br><strong>有效载荷长度</strong>：指包的数据部分。而IPv4的TL是包括首部在内的所有长度。当有可选项时，包括可选项的数据长度。<br><strong>下一个首部</strong>：相当于IPv4协议字段。但在有IPv6扩展首部情况下，表示后面第一个扩展首部的协议类型。<br><strong>跳数限制</strong>：同IPv4中TTL。</p>
<p><strong>IPv6扩展首部</strong>：IPv6首部长度固定，无法将可选项加入其中。就通过扩展首部代替，进行功能扩展。<br>· 通常位于IPv6首部和TCP/IP首部中间。<br>· <font color=#FF9000>IPv4可选项长度固定为40字节</font>，但IPv6扩展首部无限制。⭐<font color=#FF9000>文章上面不是说长度可变？</font><br>根据选项的不同，该字段时可变长，从1字节到40字节。用来支持拍错、测量以及安全等措施。<a href="https://blog.csdn.net/u011784495/article/details/71636993" target="_blank" rel="noopener">参考博客</a><br>· IPv6扩展首部还可以包括扩展首部协议和下一个扩展首部字段。当需要分片时，可以使用扩展首部。<br>· IPv6扩展首部还可以包括扩展首部协议和下一个扩展首部字段。当需要分片时，可以使用扩展首部。<br><img src="https://img-blog.csdnimg.cn/20200701093011935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h1><h2 id="第五章-IP协议相关技术"><a href="#第五章-IP协议相关技术" class="headerlink" title="第五章 IP协议相关技术"></a>第五章 IP协议相关技术</h2><p>· 主机根据实际IP包通信，需要实现将应用中使用的地址映射为IP地址。<br>· 数据链路层也不适用IP地址，在以太网情况下只使用MAC地址传输IP数据报。<br><strong>DNS</strong>（Domain Name System）：可以将字符串自动转换为具体IP地址<br>· 适用于IPv4，IPv6<br>· 起初为方便记忆，出现主机识别码。可为每台计算机赋予唯一主机名。需要不断更新下载最新hosts文件。现不用。<br><img src="https://img-blog.csdnimg.cn/20200701125153763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· DNS系统产生，它可以维护用来表示组织内部主机名（域名）和IP地址间对应关系的数据库。<br>&emsp;<em>UNIX和Windows中，”nslookup 主机名“可返回对应IP地址</em><br>· 域名服务器：管理所在层域的相关信息<br>· 域名解析器：进行DNS查询的主机和软件<br> · DNS查询原理：解析器先向域名服务器进行查询处理，如果没有，则到根域名服务器查找，查找到返回给解析器。<br>· DNS如同互联网中的分布式数据库，管理许多信息。如，由IP地址查主机名的信息PTR，上层或下层域名服务器IP地址的映射的NS记录；注册了邮箱地址和邮件接收服务器的主机名的MX记录等。</p>
<p><strong>ARP</strong>（Address Resolution Protocol）：一种解决地址问题的协议。<br>· 以目标IP为线索定位下一个应接收数据分包的网络设备对应的MAC地址。如果目标主机不在同一链路，IPv4下通过ARP查找下一跳路由器的MAC地址。IPv6中，用ICMPv6替代发送邻居探索消息。<br>· 工作机制：广播发送ARP请求包，被同一链路所有主机和路由器接收解析。一致的返回ARP响应表。<br><img src="https://img-blog.csdnimg.cn/2020070112530392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;接收端、发送端获取到的MAC地址缓存到ARP缓存列表中一段时间。<br><strong>RARP</strong>（reverse…）：从MAC地址定义IP地址的一种协议。<br>· 平时通过个人电脑设置IP地址，也可以通过<a href="#DHCP">DHCP</a>（Dynamic Host Configuration Protocol）自动分配获得IP地址。然而使用嵌入式设备（如打印机等）时，会遇到没有输入接口或无法通过DHCP动态获取IP地址的情况。此时可使用RARP<br>· RARP请求包和RARP响应包</p>
<p><strong>代理ARP</strong>(Proxy ARP)：ARP包通常会被路由器隔离。但采用代理ARP的路由器可以将ARP请求转发给临近网段。</p>
<p><strong>辅助IP的ICMP</strong>：确认IP包是否成功送达目标地址，通知发送中被抛弃的IP包的原因，改善网络设置等。<font color=#FF4500>仅支持IPv4</font>。<br>· 因为基于IP进行工作，例如通知消息使用IP进行发送。所以无法保证服务质量。<br>· 在ICMP中，包以明文方式像TCP/UDP一样通过IP进行传输。ICMP的功能并不是传输层的补充，而应该把ICMP考虑为IP一部分。<br>· ICMP消息分为两大类：通知出错原因的错误消息；用于诊断的查询消息。<br>· ICMP目标不可达消息；ICMP重定向消息：有更好的发送路由；ICMP超时信息；ICMP回送消息：常用ping命令，判断对端主机是否可达。<br>ICMPv6：作用扩大。IPv4没有ICMP可以工作，但IPv6不能没有ICMPv6。<br>· 从IP定位MAC地址的协议从ARP变为ICMP的邻居探索消息。它融合了IPv4的ARP、ICMP重定向和ICMP路由选择消息等功能，还提供了自动设置IP地址的功能（但ICMPv6中没有DNS服务器的通知功能，所以实际上这个功能需要与DHCPv6组合使用实现）<br>·  ICMPv6中ICMP分为两大类：错误消息和信息消息<br>· IPv4中使用ARP采用广播，IPv6邻居请求消息中利用多播传输。</p>
<span id="DHCP">
**DHCP**（Dynamic Host Configuration Protocol）：实现自动设置IP地址，统一管理IP地址分配</span>
· 支持IPv4，IPv6
· 只要连接到网络，就能实现TCP/IP通信。实现即插即用：物理上一连通，无需专门设置即可使用设备。
· 提高容灾性，架设不止一台DHCP服务器

<p><img src="https://img-blog.csdnimg.cn/20200701133501140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·  使用DHCP之前，需要一台DHCP服务器，很多时候由该网段的路由器充当。然后在DHCP服务器上设置可分配的IP地址、子网掩码、默认路由。</p>
<ol>
<li>客户端首先会广播发送一个<font color=#FF4500>dhcp discovery</font>报文，要求设置IP地址和网络掩码。</li>
<li>服务器收到客户端发来的发现报文后，单播回复一个<font color=#FF4500>dhcp offer</font>报文（包含IP地址、租约信息、dns等），同时dhcp服务器也会生成一个租期表格（ip地址、租期、mac）。ps：此处为单播主要是原因是交换机有这client的mac列表，所以可以单播回复，减少资源消耗。</li>
<li>客户端收到服务器来的提供报文后，广播发送一个<font color=#FF4500>dhcp request</font>报文。包含自己的IP地址信息，目的是为了①告诉别的DHCP服务器，我已经有地址了，你们之前准备分给我的地址，你们可以收回了。②告诉选中的DHCP，我选择你了，你的地址我准备用了。</li>
<li>服务器收到客户端发来的应答报文后，会发送一个<font color=#FF4500>dhcp ack</font>或<font color=#FF4500>dhcp nak</font>。服务器检测后可以用，就回复ACK，如果地址冲突或者无效就回复NAK，客户端重新获取地址。</li>
<li>DHCP网络设置结束，可进行TCP/IP通信。<br><a href="https://www.cnblogs.com/dsl146/p/10331120.html" target="_blank" rel="noopener">参考博文</a><br>· DHCP服务器在分配IP地址前发送ICMP回送请求包，确认无应答；DHCP客户端针对获得的IP地址发送ARP请求包，确认无应答。</li>
</ol>
<p><strong>DHCP中继代理</strong>：<br>· 学校等大规模网络环境中，如果将DHCP服务器分设到各个路由器上，不好管理。需要DHCP中继代理——对不同网段的IP地址分配由一个DHCP服务器统一管理。<br>· 不需要每个网段架设一个DHCP服务器，只需要每个网段设置一个DHCP中继代理。<br>· DHCP客户端向DHCP中继代理发送DHCP请求包，而中继代理在收到之后单播发送给DHCP服务器。服务器端收到后再由原路线返回应答。<br><img src="https://img-blog.csdnimg.cn/20200701134818234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>NAT</strong>（Network Address Translator）：用于私有地址转成全局IP地址的技术。<strong>NAPT</strong>，还可以转换TCP、UDP端口号从而实现⭐<font color=#FF9000>用一个全局IP地址与多主机通信（怎么实现？）</font><font color=#FF4500>生成NAPT表，正确转换地址和端口的组合，令多个客户端同时与服务器进行通信。现在提到NAT，多指NAPT，也称<strong>IP伪装</strong>或<strong>Multi NAT</strong>。</font><br>· IPv4和IPv6均有使用。在两者间的通信常使用NAT-PT。<br><img src="https://img-blog.csdnimg.cn/20200701155810750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· 在NAT(NAPT)路由器内部，有一张<strong>自动生成</strong>的用来转换地址的表。<br>· 当私有网络中多台机器同时与外部通信，仅转变IP地址，全局IP地址可能不够用。解决：采用NAPT方式。<br><img src="https://img-blog.csdnimg.cn/20200701155845835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>NAT-PT(NAPT-PT)</strong>：PT是Protocol Translation的缩写。严格说，NAT-PT用来翻译IP地址，NAPT-PT用来翻译IP首部与端口号的。<br>· NAT-PT将IPv6的首部转换为IPv4的首部。这样只有IPv6地址的主机就可与IPv4地址的主机通信了。<br>· NAT-PT有多种形式，包括结合DNS和IP首部替换的DNS-ALG（应用层网关）<br>· NAT-PT问题：</p>
<ol>
<li>无法从NAT外部向内部服务器建立连接</li>
<li>转换表开销</li>
<li>NAT重启后，TCP连接重置<br>· 解决：</li>
<li>改用IPv6。普及度不容乐观</li>
<li>“NAT穿越”：在NAT内侧（私有IP地址的一边）主机上运行的应用，发送一个虚拟网络包给NAT外侧。NAT生成转换表。 应用可与NAT路由器通信，生成转换表，并将NAT路由器上附属的全局IP地址传给应用。<font color=green>(向外部固定服务器注册，服务器上保存一张含全局IP地址和端口号的表)</font>这样，外侧内侧间可进行通信。<br><a href="https://blog.csdn.net/whoamiyang/article/details/51992208" target="_blank" rel="noopener">参考博客</a></li>
</ol>
<p><strong>IP隧道</strong>：网络层后追加网络层首部的通信方式。<br>· 可以让夹着IPv4C网络的A，B能够正常通信。IP隧道将从A网络发过来的IPv6的包统合成一个数据，再追加一个IPv4首部，转发给C。<br><img src="https://img-blog.csdnimg.cn/20200701160026932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>IP多播相关技术</strong><br>· MLD（Multicast Listener Discovery）多播监听发现：确认是否有接收端。是IPv4中IGMP（Internet Group Management Protocol）和IPv6中ICMPv6的重要功能之一。<br>· IGMP(MLD)两大作用：</p>
<ol>
<li>向路由器表明想要接收多播信息，并通知想接收多播的主机地址。路由器会了解主机，并发送消息给其他路由器，准备接收多播消息。多播消息的发送路径则由多播路径协议决定。</li>
<li>IGMP(MLD)探听。支持IGMP(MLD)探听的交换集线器可以过滤多播帧，降低网络负荷。</li>
</ol>
<p><strong>IP任播</strong>：多个服务器一个IP地址，就近处理<br>· 主要用于110，119系统。IP任播应用中最为有名的是DNS根域名服务器。适用IPv4，IPv6<br>· 限制：无法保证第一个包和第二个包发送给了同一个主机。</p>
<p><strong>通信质量控制</strong><br><strong>RSVP</strong>（Resolution Reservation Protocol）包括两个内容：</p>
<ol>
<li><strong>提供点对点的详细优先控制（IntServ）</strong>。针对特定应用（源、目IP地，源、目端口，协议号完全内容一致）间的通信进行质量控制。<br> · InServ在必要时要求在路由器上进行设置，也称”流量控制”。实现这种控制的协议为RSVP。RSVP传送控制包，并在发送端和接收端间所有路由进行质量控制设定。路由器随后根据这些设定进行处理。<br> · 机制负杂，大型网络实施困难。提出DiffServ<br><img src="https://img-blog.csdnimg.cn/20200701163902118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>提供相对较粗粒度的优先控制（DiffServ）<br>进行DiffServ质量控制的网络叫做DiffServ域。在域中的路由器会对所有进入该域IP包首部的<a href="#DSCP">DSCP字段</a>进行替换。对期望被优先处理的包设置优先值。<br>· 根据供应商的合作要求控制，机制简单，实用性较好。</li>
</ol>
<p><strong>显示拥塞通知</strong>（ECN，Explicit Congestion Notification）<br>· 为解决TCP通过数据包实际损坏情况判断是否发生拥塞的方法，不能在数据包损坏前减少包发送量，在IP层使用<strong>显示拥塞通知机制</strong>，即ECN。<br>· <strong>ECN机制</strong>：在发送包IP首部中记录路由器是否遇到拥塞，并在返回包的TCP首部中通知是否发生拥塞。拥塞检测在网络层中进行，而拥塞通知在传输层进行，这两层的互相协作实现了通知拥塞功能。<br><img src="https://img-blog.csdnimg.cn/20200702093756686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h1><p><strong>Mobie IP</strong><br>· 背景：IP地址中“网络地址”表示全网中子网的位置，因此不同地域它的值不同。手机等移动设备每连接到不同的子网，都会由DHCP或手动分配到不同的IP地址。<br>与移动设备通信时，所连接的子网一旦发生变化，则无法通过TCP继续通信。因为TCP是面向连接的协议，自始至终需要发送端和接收端主机IP不变。UDP情况也不行。<font color=#FF9000>(原因？)</font>不过UDP面向非连接，可在应用层面处理IP地址问题。但很麻烦。<br>· Mobie IP在主机所连接子网IP变化时，主机IP地址仍然保持不变。<br>· 工作机制：移动之后经代理通信。对于移动前正在进行的通信，代理装作移动主机发送ARP消息，并接收以移动主机为目标地址的数据包，相当于“中转站”，采用IP隧道把消息转发给移动主机。对于常规的IP包，进行常规路由控制<font color=green>（此时采用移动地址进行通信）</font>。<br><img src="https://img-blog.csdnimg.cn/20200702093946683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>移动主机（MH：Moblie Host）：指移动了位置，IP地址不变的设备。未移动时，连接的网络为归属网络，IP地址叫归属地址，移动了也不会改变。移动了会被设置成所处子网中的IP地址，称为移动地址（CoA，Care-of Address）</li>
<li>归属代理（HA：Home Agent）：处于归属网络下，监控移动设备位置，并转发数据给MH。</li>
<li>外部代理（FA：Foreign Agent）：使用于支持移动主机的移动设备。所有需要接入网络的移动主机都需要使用它。<br>· 问题：</li>
<li>为了提高安全，一个域可以设置成，若非是从本域发送过来的包，则丢弃。进行常规路由控制时，当移动主机向通信节点发送数据包时，为了保证位置的透明性，移动主机的源地址设置为自己的归属地址。目的地路由器很可能会丢弃这个包。为避免，移动主机向通信对端发送IP包要经过归属代理（双向隧道）但效率太低。</li>
<li>IP包三角形路线效率低。</li>
<li>没有外部代理的网络不能通信。</li>
</ol>
<p><strong>Moblie IPv6</strong>解决了这些问题：</p>
<ol>
<li>IPv6首部源地址中赋予移动地址，不让防火墙丢弃。通信节点接收到后，自动把数据包的源地址替换成归属地址，保证透明性。</li>
<li>不经过归属代理进行通信。</li>
<li>外部代理功能由实现Moblie IPv6的移动主机自己承担。<br><a href="http://www.doc88.com/p-6631786224184.html" target="_blank" rel="noopener">详细请参考该博客</a><br>必须移动主机、通信对端都支持Mobile IPv6，才可实现上述所有功能。</li>
</ol>
<h2 id="第六章-TCP与UDP"><a href="#第六章-TCP与UDP" class="headerlink" title="第六章 TCP与UDP"></a>第六章 TCP与UDP</h2><p><strong>传输层的作用</strong><br>· 一个应用程序可以有多个端口号<br>· 在UNIX系统中：服务端程序称为守护进程。例如：http的服务端程序是httpd（http守护进程），sshd……只需要启动一个可以代表他们接收客户端请求的inetd（互联网守护进程）服务程序即可。它是一种超级守护进程。它接收到客户端请求后，会创建（fork）一个新的进程并转换（exec）为sshd等各个守护进程。<br>· 确认请求发给哪个守护进程，通过端口号。<br>· TCP是面向连接的、可靠的流协议。流，意味着数据不中断。例如发送10次100字节的消息，接收端接收到的就是1000字节连续数据。<br>  具备“顺序控制”、“重发控制”、“流控制（流量控制）”、“拥塞控制”、提高网络利用率等功能。<br>· UDP不具备可靠性的数据报协议。可确保发送消息的大小。例如发送一个100字节的消息，那么消息长度的数据也会发送给接收端，让接收端以100字节为长度接收数据。<br>· TCP主要用于在传输层有必要实现可靠传输的情况。而UDP主要用于实时性和高速传输有较高要求的情况，如电话等。此外，在多播或广播通信中也使用UDP<font color=#FF9000>（why？是因为不需要保证可靠性，而且可以降低网络开销吗）</font>RIP，DHCP等基于广播的协议也需要依赖UDP。<br>· API：应用编程接口，操作系统提供的类库。使用TCP/UDP通信时，广泛使用套接字（Socket）的API。<br><img src="https://img-blog.csdnimg.cn/20200703205625792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>端口号</strong>：传输层中的识别地址，也称程序地址<br>· TCP/IP或UDP/IP通信中常采用5个信息量来识别一个通信:源IP地址、目标IP地址、协议号、源端口号、目标端口号。<br>· 确定端口号：<br>    1. 标准既定的端口号（静态方法）：0<del>1023为知名端口号，正式注册的端口号在1024</del>49151间。<br>    2. 时序分配法（动态方法）：客户端应用程序不需要自己设置端口号，全权交给操作系统分配。在49152~65535间。<br>· 不同的传输协议可以使用相同的端口号，只要端口一致，都将分配给同一种程序处理。但处理不会相互影响。例如，数据到达IP层，根据协议号的不同，传给相应的协议模块进行处理。</p>
<p><strong>UDP</strong>（User Datagram Protocol）<br>· 收到数据那一刻，立即按照原样发送到网络上的一种机制。<br>· 没有流量控制，不负责重发，包顺序混乱无纠正。这些功能交给UDP的应用程序处理。<br>·常用于：<br>    1. 包较少的通信（DNS、SNMP等）<br>    2. 即时通信（视频、音频）<br>    3. 广播通信（广播、多播）<br>    4. 限定于LAN等特定网络中的应用通信</p>
<h1 id="7-3"><a href="#7-3" class="headerlink" title="7.3"></a>7.3</h1><p><strong>TCP</strong><br>· 常用于：数据量较多，对可靠性要求较高<br>· TCP通过检验和、序列号、确认应答、重发机制、连接管路、窗口控制等实现可靠传输。<br>· 序列号（seq）是按顺序给发送数据的每个八位字节编上序号。初始序列号（ISN）随机，一个段在网络中寿命小于ISN生成器，所以默认初始序列号唯一。如果一段时间未得到确认应答，认为丢失，并重发。重发超时的时间，为每次发包时计算出的往返时间（RTT）+ 偏差 + ε。<br>· UDP不用检查对端是否能通信，但TCP需要通信前发一个SYN包请求建立连接并等待确认应答。在通信结束时会进行断开连接的处理（FIN包）<br>· 三次握手：一个连接的建立与断开，至少需要来回发七个包。从SYN到FIN，必须是同一个IP地址。<br><img src="https://img-blog.csdnimg.cn/20200703205806341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>⭐<font color=#FF9000>为什么是三次握手？</font><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">知乎参考</a><br>· 在三次握手中，可计算出MSS（Maximum Segment Size，最大消息长度），这是TCP传送数据的分割大小单位。<br>· TCP窗口满，就对多个段同时进行确认应答的处理。在收到确认之前，缓存区保存这些数据。错误需要重发。<br>· 高速重发控制：在窗口较大，又出现报文丢失下，同一个序号的确认应答将会被重复三次返回。则发送端对对应的数据段重发。<br>· <strong>流控制</strong>：让发送端根据接收端实际接收能力控制发送的数据量。大小限度就是窗口大小。过了重发时间没收到窗口更新通知，则发送窗口探测，获取最新窗口大小信息。<br>· <strong>拥塞控制</strong>：“拥塞窗口”就是网络此刻能承受的、通信时的最大数据量。选择拥塞窗口和接收端主机通知的窗口大小中小的那一个，发送更小一点的值。<br>初始窗口设为1，之后指数增长，到达阈值，线性增长。<strong>超时重发</strong>时，执行<strong>慢启动</strong>算法。阈值调整为拥塞窗口的一半大小，同时同时设置拥塞窗口大小为1，进入慢开始阶段。到达阈值，实行规避算法。<strong>重复确认应答</strong>进行高速重发控制时，执行<strong>快恢复</strong>算法。阈值大小设为现在拥塞窗口大小的一半，窗口大小为慢启动阈值+3个数据段（MSS）的大小。<br>· 提高网络利用率：<br>Nagle算法，延迟发送的一种机制。满足以下其中之一，才能发送数据：</p>
<ol>
<li>可以发送最大段长度（MSS）的数据时</li>
<li>已发送的数据都已经收到确认应答时<br>延长确认应答：为解决糊涂窗口综合征（如果接收端每次立即回复确认应答，因为刚接收完数据，缓存区是满的，只能返回一个较小窗口，导致发送端以这个大小进行后续的数据发送），收到数据后，延迟一段时间应答，最多0.5s。TCP文件传输中，绝大部分两个数据段返回一次应答。<br>捎带应答：发送端收到接收端的确认应答后，先不马上发送确认应答。而是在下一次发送数据时，捎带发送确认应答。</li>
</ol>
<h1 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h1><p>· UDP-Lite，UDP扩展协议。功能在UDP基础上修改了校验和的范围可以自行决定。设置不校验的部分即使发生错误也忽略不计。<br>· SCTP，流控制传输协议。与TCP相似，是可靠的传输层协议。<br>特点：</p>
<ol>
<li>以消息为单位收发。TCP中接收端并不知道发送端决定的消息大小。</li>
<li>支持多重宿主。TCP当从以太网切换到无线LAN时，会断开连接。但SCTP中，各自的NIC会获得不同IP地址，所以连接不会断开。</li>
<li>支持多数据流通信。TCP中建立多个连接才能进行通信的效果<font color=#FF9000>（⭐？为什么）</font>，SCTP中一个连接就能进行通信。<br><font color=#FF4500>举例说明：</font><br><img src="https://img-blog.csdnimg.cn/2020070515261247.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200705153010662.png" alt="在这里插入图片描述"><br>· DCCP，数据报拥塞控制协议。辅助UDP的传输层协议。<br>特点：</li>
<li>与UDP一样，不能提供发送数据的可靠运输</li>
<li>面向连接，在建立和断开连接上具有可靠性</li>
<li>能进行拥塞控制。“类似TCP（TCP-Like）拥塞控制”和“TCP友好升级控制”（TCP-Friendly Rate Control）</li>
</ol>
<p>UDP首部格式<br><img src="https://img-blog.csdnimg.cn/20200704100635589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· 包长度：UDP首部和数据的长度和，单位为8位字节。<br>· 校验和需要对UDP伪首部进行校验。因为TCP/IP中识别一个进行通信的应用需要五大因素，其中三项“源IP地址”、”目标IP地址”、“协议号”在IP首部里，对5项都进行校验，从而实现IP首部不可靠情况下提供可靠通信传输。</p>
<p>TCP首部格式<br><img src="https://img-blog.csdnimg.cn/20200704100700838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· 序列号：初始序列号通过SYN包传送给接收端主机。在建立、断开连接时发送的SYN、FIN包虽然并不携带数据，但会增加一字节序列号。<br>· 数据偏移：表示TCP传输的数据部分从TCP包的哪个位开始计算，可看成TCP首部长度。该字段四位，<font color=#FF4500>单位为四字节（即32位）</font>。例如TCP首部为20字节长，那数据偏移为5。<br>· 保留：用于实验目的<br>· 控制位<br><img src="https://img-blog.csdnimg.cn/20200704100738486.png" alt="在这里插入图片描述"><br>URG（Urgent Flag）：为1时，有紧急数据要处理。<br>ACK：=1，确认应答字段变为有效。<br>PSH（Push Flag）：=1，立即将收到数据传给上层应用协议。<br>RST（Reset Flag）：=1，TCP连接异常，强制断开。<br>SYN（Synchronize Flag）：=1，希望建立连接。<br>FIN（Fin Flag）：=1，希望断开连接。<br>· 窗口大小：单位8位字节。如果窗口为0，发送一字节的窗口探测，了解最新窗口大小。<br>· 校验和：与UDP类似，但是TCP校验和无法关闭。利用伪首部校验。<br><img src="https://img-blog.csdnimg.cn/20200704100758701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· 紧急指针：URG=1时有效，从数据部分的首部到紧急指针为紧急数据。如何处理紧急数据属于应用问题。紧急指针也用做表示数据流分段的标志。<br>· 选项：根据数据偏移进行控制，因此长度最大为40字节。<br><font color=#FF9000>为什么是40？</font><br><font color=#FF4500>1）TCP首部：由 20字节的固定长度 和 可变长字段（选项和填充）组成。<br>2）TCP首部总长度：由TCP头中的“数据偏移”字段决定。该字段占4bit，取最大的1111时，也就是十进制的15，TCP首部的偏移单位为4byte，那么TCP首部长度最长为15*4=60字节。<br>3）选项和填充 的长度：＝ TCP首部总长度 － 20字节的固定长度。由2）的计算可知，TCP首部总长度最大为60字节，那么“选项和填充”字段的长度最大为40字节。填充是为了使TCP首部为4byte的整数倍。</font><br><a href="https://blog.csdn.net/mary19920410/article/details/72857764" target="_blank" rel="noopener">参考博文</a></p>
<p>最大吞吐量 = 窗口大小/RTT</p>
<h2 id="第七章-路由协议"><a href="#第七章-路由协议" class="headerlink" title="第七章 路由协议"></a>第七章 路由协议</h2><p>· 路由控制分静态路由和动态路由。静态路由是在路由器和主机中事先人为设置好路由信息，而动态路由，管理员只需要设置好协议，路由器定时与相邻路由器互发信息进行信息交换。<br>· 路由控制范围常用路由协议为EGP外部网关协议，IGP内部网关协议。路由协议是用来保证路由信息正确的。<br>· ISP、区域网络都属于自治系统AS。AS内部动态路由采用IGP，AS之间的路由控制采用EGP。<br>· IGP中还可以使用RIP路由信息协议，RIP2，OSPF开放式最短路径优先等协议。EGP中使用的是BGP边界网关协议。<br>· 路由控制算法：<br>    1. <strong>距离向量</strong>算法DV根据距离（也就是经过的路由器个数作为代价）和方向决定目标网络或目标主机位置。每个路由器掌握的信息都不相同。<br>    使用该算法的路由协议：RIP、RIP2<br>    2. <strong>链路状态</strong>算法则根据每个网络的成本作为代价（为每条链路赋予一个权重，选择总代价最小的那条）。每个路由器掌握的信息同步，保存的是网络拓扑结构图。即使网络中有环路，也能进行稳定路由控制。<br>    使用该算法的路由协议：OSFP<br>RIP<br>· RIP广泛应用LAN。路由控制信息每30s向全网广播，若没收到路由控制信息等到第6次后（180s）断开连接。<br> &emsp; · 根据距离向量库生成路由控制表。<br> &emsp; · RIP中包类型只有一种，利用路由控制信息，一本确认是否连接网络，一边传送网络信息。<br> &emsp;· RIP不交换子网掩码信息，但可以用于子网 掩码的网络环境。<font color=#FF9000>（“该情况下需要注意的点”这部分没有看懂）</font><br> &emsp; · 为了解决无限计数问题（其中某个网络断开，其他的路由器并不知道，在之后的广播中，其他路由器仍然把原来的距离发送给连接故障的路由器，从而使得路由距离不断增加），有两种方法：</p>
<ol>
<li>最长距离不超过16；</li>
<li>水平分割。规定路由器不再把所收到的路由消息原路返回给发送端。<br>但在有环路情况下，依旧无法解决。采用“毒性逆转”和“触发更新”两种方法。毒性逆转指当网络中发生链路断开时，将这个无法通信的消息传播出去，即发送一个距离为16的消息。触发更新是指当路由信息发生变化时，不等待30s就立即发送出去。</li>
</ol>
<p>· RIP2改良RIP：</p>
<ol>
<li>使用多播</li>
<li>与OSPF相似，支持在其交换的路由信息中加入子网掩码信息</li>
<li>与OSPF的区域相似，在同一个网络中可以使用逻辑上独立的多个RIP</li>
<li>与OSPF相似，RIP包中携带密码，能识别才接收数据，否则忽略</li>
<li>通常用于把从BGP等获得的路由控制信息通过RIP传递到AS内</li>
</ol>
<h1 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h1><p><strong>OSPF</strong><br>· OSPF引入区域概念，这是将一个AS划分为若干个更小的范围。<br>   · 根据拓扑信息生成路由控制表<br>   · 根据不同作用分为5种类型的包<br><img src="https://img-blog.csdnimg.cn/20200705095432536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· LAN中10s发送一个HELLO包，直到第四次（40s）后仍无反馈认为连接断开。之后无论连接断开或恢复连接，都会发送链路状态更新包通知变化。<br>· 链路状态更新包传达的消息分为：网络LSA（网络链路状态通告）和路由器LSA。一个是以网络为中心生成的信息，一个是以路由器。<br>· 主干区域，所有区域都与它连接。与外部相连接的：AS边界路由器；只与主干区域内连接的：主干路由器；区域内的：内部路由器；连接区域与主干区域的：区域边界路由器<br>· 末端区域，区域边界路由器只有一个的区域。它的区域边界路由器将成为默认路径传送路由信息。所以它不需要了解其他各个网络的距离。</p>
<p><strong>BGP</strong><br>· 只有BGP，RIP，OSPF共同进行路由控制，才能进行整个互联网的路由控制。<br>· BGP路由控制表由网络地址和下一站路由器组成，它会根据所要经过的AS个数来进行路由控制。使用路径向量协议。能检测出环路，并且支持策略路由（在发送数据包时，可以选择或者指定所要通过的AS）</p>
<p><strong>MPLS多协议标记交换技术</strong><br>· 路由技术基于IP地址中最长匹配原则进行转发，而标记交换则对每个IP包设定一个标记值来进行转发。<br><img src="https://img-blog.csdnimg.cn/20200705095457545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· 如果数据链路本身有有一个相当于标记的信息，只需要直接进行映射。如果没有（比如以太网）就需要追加一个垫片头，包含标记信息。介于IP首部和数据链路首部之间。<br>· MPLS中可通过高速硬件实现转发。利用标记生成虚拟的路径（标记交换路径LSP），并在上面实现IP等数据包的通信。所以，IP网也可以提供基于MPLS的通信质量控制、带宽保证和VPN等功能。</p>
<h1 id="7-5-1"><a href="#7-5-1" class="headerlink" title="7.5"></a>7.5</h1><h2 id="第8章-应用层协议"><a href="#第8章-应用层协议" class="headerlink" title="第8章 应用层协议"></a>第8章 应用层协议</h2><p>· 应用层协议：让应用进行特定通信处理，相当于OSI参考模型中5、6、7层协议。<br>· <strong>远程登陆</strong>：为了实现TSS分时系统环境，将主机和终端关系应用到计算机网络的一个结果，即实现从自己本地计算机登录到网络另一端计算机功能的应用。通过TELNET和SSH两种协议。<br>· TELNET利用TCP的一条连接，向主机发送文字命令并在主机上执行。<br>· SSH是加密的远程登陆系统。端口转发（将特定端口号所收到的消息转发到特定IP地址和端口号）情况下，SSH客户端程序、SSH服务端程序都起到一个网关作用。<br>· <strong>文件传输</strong>：FTP协议是两个相连计算机间进行文件传输时使用的协议。需要在登录到对方计算机后才能进行相应操作。<br>· FTP通过两条TCP连接：一条控制，一条数据传输（建立方向与控制相反）。<br>· 控制使用TCP21号端口；传输通常使用20号，出于安全考虑，普遍使用随机数分配。<br>· <strong>电子邮件</strong>：SMTP协议提供电子邮件服务，为了实现高效发送，在传输层使用TCP协议。<br>· 早期是写好后内容保存到发送端主机硬盘中，然后两台主机建立TCP连接，邮件发送到接收端主机硬盘。发送正常结束后，再从本地硬盘删除邮件。如果途中发现对端计算机因没插电，或未连网等原因接受失败，等待一段时间后重发。<br><img src="https://img-blog.csdnimg.cn/20200706160920722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· 只使用SMTP只能处理文本格式邮件。MIME在SMTP上使用，可以发送静态图像，动画，声音等各种数据。相当于表示层。<br>· 个人电脑不可能长时间开机状态，因此引入POP协议。用于接收电子邮件的协议。当发送端邮件根据SMTP转发到一直处于插电状态的POP服务器，客户端再根据POP协议从POP服务器接收邮件。<br>· IMAP也是接收邮件协议。不同于POP的邮件由客户端进行处理，MAP中邮件由服务器进行处理。所以不必从服务器上下载所有的邮件就可以阅读。在不同的计算机上打开邮箱，也能保持同步。</p>
<p>· <strong>WWW</strong>：访问信息的手段与位置（URI）、信息的表现形式（HTML）、信息转发（HTTP）等操作。<br>· HTTP默认80端口，工作机制：服务端向服务器的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。在HTTP1.0中，每个命令和应答都会触发一次TCP连接的建立和断开，HTTP1.1开始，允许在一个TCP连接上发送多个命令与应答。<br>· CGI（Common Gateway Interface）是web服务器调用外部程序时所使用的一种服务器应用的规范。在一般web通信中，是按照客户端需求，将保存至web服务器硬盘中的数据转发，这样每次获得的就是同样的静态数据。引入CGI后，客户端每次请求会触发web服务器端运行另一个程序，客户端所输入的数据也会传送给这个外部程序。该程序运行结束后，会将生成的HTML和其他数据再返回给客户端。<br>· Cookie：web应用为了获得用户信息而使用的机制。cookie常用于保存登录信息或网络购物中放入购物车的商品信息。web服务器用Cookie在客户端保存信息，这样就不用放到服务器里了。<br>· 网络管理 SNMP，基于UDP协议，可能会丢包。<br>· SNMP的处理可以分为从设备读取数据（Fetch）和向设备写入数据（Store）。网络设备状况发生变化，通知SNMP管理器使用Trap，这样即使没有管理器到代理的请求，也能设备发生变化时候获得代理发来的通知。<br>· SNMP中的交换信息是MIB（Management Information Basde），MIB是在树形结构的数据库中为每个项目附加编号的一种信息结构，能在网络上传输，相当于SNMP的表示层。SNMP可以将MIB值写入代理，也可以读取。使用易于理解的数字序列访问信息。<br>· RMON：MIB是监控网络中某个设备接口（某个点）的众多参数构成，而RMON是监控网络上线路的众多参数组成（一条线）。可监控内容也增加了，如网络流量统计等。<br>· RTP实时协议：用UDP实现实时多媒体通信时需要附加一个表示报文顺序的序列号字段。设置时间戳和数字序列号，接收端对统一时间戳的数据进行排序，掌握是否丢包。<br>· MPEG决定数字压缩规范<br>· P2P：<br><img src="https://img-blog.csdnimg.cn/20200706161006574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· 不支持P2P的环境：在服务器与客户端分离型的环境中，服务器要在一个互联网能够访问到的地方，而客户端在NAT内测也不会有问题，但P2P不行。它必须具备从互联网越过NAT令双方终端能够访问的功能。</p>
<h2 id="第9章-网络安全"><a href="#第9章-网络安全" class="headerlink" title="第9章 网络安全"></a>第9章 网络安全</h2><p>· PKI（公钥基础结构）用户通过CA颁发的“数字证书”验证通信时对方的真实性。公钥信息可以用于加密数据或验证对应私钥的签名。使用公钥信息加密后的数据，只能由持有数字证书的一方读取。<br>· 公钥加密：银行手上有公钥和私钥，公钥是对外公布的。客户使用公布的公钥加密信息，并发送给银行，银行收到了密文，使用自己的私钥解密恢复明文。只有私钥才能解密公钥加密的密文。<br>· 私钥签名：我用私钥加密，由于大家都知道我的公钥，所以都能看到我的内容。A说有人冒充我。我就把信，内容为B，用私钥加密，发给A，告诉他用我的公钥解密是否能看到B。能用我的公钥解密数据，说明肯定是用我的私钥加的密。那么只有我知道我的私钥，所以这封信肯定是我发的，就能确认我的身份了。<br>· 加密是指利用密钥对明文的数据加密成密文数据的过程。<br>· VPN 通过IPsec加密IP包：</p>
<ol>
<li>传输模式：主机进行加密解密，只加密TCP首部和数据部分。</li>
<li>隧道模式：VPN路由器进行加密解密，包括IP首部在内的整个IP包加密，并追加IP首部。</li>
</ol>
]]></content>
      <categories>
        <category>阅读记录</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入了解Java虚拟机》第七章</title>
    <url>/2020/07/25/%E3%80%8A%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p>在Class中描述的信息最终都需要加载到虚拟机中之后才能被运行和使用。本章主要讲虚拟机如何加载class文件，class文件中的信息加载后会发生什么变化。<br><strong>虚拟机加载机制</strong>：JVM把描述类的数据从Class文件加载进入内存，通过校验、转换解析、初始化，形成虚拟机能够直接使用的java类型的过程。<br>· 和其他在编译期间需要连接的语言不同，java语言<font color = #F9000>在运行期间类型的加载、连接、初始化</font>，所以java语言天生具有<font color = #F9000>动态扩展性</font>。例如接口可以在运行时再指定实现的实现类。还有现在可以在运行时，用户通过预置或自定义加载器，从网上直接加载一个<font color = #F9000>二进制流</font>作为代码一部分。这种动态组装应用广泛，从简单的JSP到复杂的OSGi技术，都是基于java语言在运行期间进行类加载的特性。<br>约定：<br>    1. 每个Class文件都有代表一个接口或者类的可能，后文未明确指出，默认同时蕴含两种可能性。<br>    2. 与上章一致，提到的Class文件并不是特指真的存储在磁盘中的文件，而是一串<font color = #F9000>二进制字节流</font>，存在形式不限。如磁盘文件，网络，数据库，内存，动态产生等。</p>
<h2 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2  类加载的时机"></a>7.2  类加载的时机</h2><p><img src="https://img-blog.csdnimg.cn/20200728175851256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>· 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这个顺序<font color = #F9000>开始</font>（可能会在一个阶段执行时调用另一个阶段），但是<font color = #F9000>解析阶段</font>不一定：某些情况下可以在初始化之后开始，这是为了支持java运行时绑定特性（动态绑定）。<br>· 第一阶段加载开始时间由虚拟机的具体实现自由把握。不过初始化在开始了前三个阶段后，在面对以下六种情况（<font color = #F9000>有且只有</font>）必须立即<strong>对类初始化</strong>：</p>
<ol>
<li>遇到new、getstatic、putstatic、invokestatic这四个指令时，类型没有初始化。生成这四条<font color = #F9000>指令</font>的典型java代码场景：<br>· 使用new实例化对象<br>· 调用一个类型的静态方法<br>· 读取或者设置一个类型的静态字段（被final修饰、已在编译期把结果放到常量池的静态字段除外）</li>
<li>使用java.lang.reflect的方法对类型进行<font color = #F9000>反射调用</font>的时，类型没有初始化。</li>
<li>虚拟机启动时，用户需要指定一个要执行的主类（main方法所在的类），虚拟机会先初始化这个<font color = #F9000>主类</font>。</li>
<li>初始化类的时候，发现这个类的父类没有被初始化，先触发其<font color = #F9000>父类的初始化</font>。</li>
<li>当一个接口在中定义了<font color = #F9000>默认方法</font>（被default修饰），如果由这个接口的实现类发生初始化，那该接口要在它之前被初始化。</li>
<li>当使用jdk7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个<font color = #F9000>方法句柄</font>对应的类没有进行初始化，先触发其初始化。<br>这六种场景中的行为称为“对一个类型的<font color = #F9000>主动引用</font>”。除此之外的所有引用类型的方式都不会触发初始化，称为“<font color = #F9000>被动引用</font>”。</li>
</ol>
<ul>
<li>对于静态字段，只有直接定义这个字段的类才会被初始化。<br>例如通过子类来引用父类中定义的静态字段，只会触发父类初始化。是否触发子类加载和验证阶段，取决于虚拟机的具体实现。</li>
<li>通过数组定义来引用类，不会触发此类的初始化。<br>例如SuperClass[] sca = new SuperClass[10]; 不会触发类org.fenixsoft.classloading.SuperClass的初始化阶段，但会触发另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段。这是一个由虚拟机自动生成的，直接继承于Object的子类，创建动作由newarray触发。这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应有的属性方法都在这个类中实现。因为越界检查封装在数据访问的指令中，所以比起c/c++直接翻译为指针的移动，java对数组访问更加安全。</li>
<li>A类引用B类的常量，并不会触发B类的初始化。因为在编译阶段通过常量传播优化，直接将要调用的常量值存储到A类的常量池中，之后对于这个常量的引用，都转换成对自身常量池的引用了。也就是说，当编译成class文件后，这两个类就不存在任何联系了。</li>
</ul>
<h2 id="7-3-类加载的过程"><a href="#7-3-类加载的过程" class="headerlink" title="7.3  类加载的过程"></a>7.3  类加载的过程</h2><h3 id="7-3-1-加载"><a href="#7-3-1-加载" class="headerlink" title="7.3.1 加载"></a>7.3.1 加载</h3><p>步骤：</p>
<ol>
<li>从类全限定名中获取这个类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转变为<font color = #F9000>方法区的运行结构</font></li>
<li>在内存中生成一个代表该类的java.lang.Class对象，作为访问这个类的入口<br>· 虚拟机实现的灵活度极大。如第一步只是说获取，获取的地方、方式都可以自由发挥：</li>
<li>从Zip压缩包中获取，如 JAR、WAR格式</li>
<li>从网络中获取，如Web Applet</li>
<li>运行时计算生成，如动态代理技术。用一个方法特定接口生成代理类的二进制字节流<br>……<br>· 在整个类加载阶段，非数组类型的加载中获取二进制流的过程最具有可控性。加载阶段既可以使用JVM内置的引导类加载器完成，也可以使用自定义的类加载器（重写类加载器的findClass()、loadClass()方法）完成。<br>· 对于数组类而言，情况有所不同。因为数组类本身不通过类加载器创建，而是JVM本身在内存中直接构造出来的。不过数组元素类型是需要靠类加载器完成的。</li>
</ol>
<ul>
<li>如果数组的组件类型为引用类型，通过递归根据上面的加载过程加载出来的。数组将被标识在加载此组件类型的类加载器的类名称空间中。</li>
<li>如果数组的组件类型不是引用类型，JVM将会把数组标记为与在引导类加载器关联。<br>· 数组类的可访问性与数组组件类型一致，如果组件类型不是引用类型，默认public。<br>· 加载阶段结束后，虚拟机外的二进制字节流就按照虚拟机设定的格式存储在方法区中了，方法区的数据存储格式是自定义的。<br>· 通常来说加载阶段与连接阶段部分动作（如字节码文件格式验证）是交叉进行的，只需保持两个阶段固定的<strong>开始顺序</strong>即可。</li>
</ul>
<h3 id="7-3-2-验证"><a href="#7-3-2-验证" class="headerlink" title="7.3.2 验证"></a>7.3.2 验证</h3><p>验证是连接阶段的第一步，为了保证class文件的字节流包含的信息符合《java虚拟机规范》的全部约束，防止字节码危害到虚拟机安全。<br>java语言本身是相对安全的，不能越界访问，跳转到不存在代码等（会抛出异常、拒绝编译）。但是由于class文件不止由java源文件编译而来，还可以从网上加载或者在二进制编辑器中得到二进制字节流，不安全的动作能够在字节码层实现。这会威胁到java虚拟机安全。所以验证阶段是必不可少的。2011年《java虚拟机规范》开始较为详细地建立了验证的约束与规则。验证阶段主要包括：</p>
<ol>
<li><p><strong>文件格式验证</strong><br>验证字节流是否符合class文件格式的规范，能否被当前版本的虚拟机处理。保证字节流正确解析存储在方法区内。<br>验证内容包括且不限于：<br>(1) 是否以魔术开头<br>(2) 主、次版本号是否在当前JVM接受范围内<br>(3) 常量池是否有不被支持的常量类型<br>(4) 指向常量的各种索引值中是否有指向不存在或不符合类型常量<br>……<br>只有这个阶段是基于二进制字节流进行的，通过这个阶段，字节流就能被允许进入JVM方法区中进行存储。之后三个验证阶段都是基于方法区的存储结构进行的。</p>
</li>
<li><p><strong>元数据验证</strong><br>对类的元数据信息进行语义校验，保证描述的信息符合《java虚拟机规范》的要求。<br>验证内容包括且不限于：<br>(1) 这个类是否有父类（除了object类，其他都应该有父类）<br>(2) 这个类是否继承了不被允许继承的类<br>(3) 如果该类不是抽象类，是否实现了父类或接口要求实现的所有方法<br>……</p>
</li>
<li><p><strong>字节码验证</strong>（最复杂）<br>根据数据流和控制流分析，确保程序语义符合规范，就是检查方法体中进行校验分析，保证在运行期间不会出现对虚拟机危害的行为。<br>验证内容包括且不限于：<br>(1) 栈操作数据类型和指令代码序列时刻保持一致<br>(2) 保证任何跳转指令不会跳转到方法体以外的字节码指令<br>(3) 保证方法体中的类型转换都是有效的，例如把一个子类对象赋值给父类数据类型是安全的，反过来不行<br>……<br>不能通过字节码验证的程序一定存在问题，但通过了不一定就肯定安全。<br>数据流和控制流分析十分复杂耗时，JDK6后进行了优化，将尽可能多的校验措施挪到了javac编译器里进行。具体来说，在code的属性表中增加了一项“StackMapTable”属性，只需要检查该属性里面的记录是否合法即可，不需要再根据程序推导这些状态的合法性。即将字节码验证的类型推导变为类型检查。</p>
</li>
<li><p><strong>符号引用验证</strong><br>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作在连接的第三阶段——解析阶段中发生。符号引用验证，是对类自身以外的各类信息进行匹配性校验。看是否缺少或者禁止访问该类所依赖的外部类、方法、字段等。目的是为了确保解析行为能顺利进行。如果无法通过验证会报错。如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。<br>验证内容包括且不限于：<br>(1) 符号引用中的全限定名是否能找到对应的类<br>(2) 在指定类中是否存在符合方法描述符及简单名称所描述的方法、字段<br>(3) 符号引用中类、方法、字段的可访问性是否能被当前类访问</p>
</li>
</ol>
<p>7.3.3 准备</p>
<blockquote>
<ul>
<li>只要是对象实例，必然会在java堆中分配。</li>
<li>所有Class相关的信息都应该存放在方法区之中，但方法区的实现不同虚拟机可以灵活处理。JDK7以后Hotspot虚拟机选择把静态变量和类型在java语言一端的映射Class对象存放在一起，存储于java堆之中。</li>
</ul>
</blockquote>
<p>准备阶段是正式为<font color = #F9000>类变量</font>（静态成员变量）分配内存、设置初值的阶段。从<font color = #F9000>逻辑概念</font>上讲，这些变量是在方法区中分配的，jdk7及之前，Hotspot虚拟机使用永久代实现方法区，完全符合这种逻辑概念；但jdk7之后，类变量与class对象一起放在Java堆中，这时候方法区只是一个逻辑上的表述了。</p>
<p>注意：</p>
<ol>
<li>准备阶段内存分配仅包括类变量，不包括实例变量，实例变量会在对象实例化的时候随对象一起分配在java堆中。</li>
<li>设置的初始值【一般为】数据类型的零值。例如<code>public static int a = 123</code>准备阶段后为0，而不是123.因为这时候还未开始执行任何java方法，把a赋值为123的putstatic指令是在程序被编译后，存放在类构造器<clinit>()方法之中，所以要等到类初始化阶段才会被赋值为123。<br><img src="https://img-blog.csdnimg.cn/20200728180601337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p>【特殊情况】：如果类字段的字段属性表中存在ConstantValue属性，那么编译时javac会为该变量生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue属性的设置将变量值赋值。例如<code>public static final int a = 123</code>准备阶段后为123。</p>
<h3 id="7-3-4-解析"><a href="#7-3-4-解析" class="headerlink" title="7.3.4 解析"></a>7.3.4 解析</h3><p>解析阶段是JVM将常量池内的符号引用替换为直接引用的过程。</p>
<blockquote>
<p>· <strong>符号引用</strong>：符号引用是用一组符号来描述所要引用的目标。符号可以是任意字面量。<br>各虚拟机能够接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。符号引用与虚拟机的内存布局无关，引用的目标也不一定是已加载到虚拟机中的内容。<br>· <strong>直接引用</strong>：能够直接或者间接地定位到目标。<br>与虚拟机内存布局直接相关，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不同。引用的目标也一定已经加载到虚拟机中了。</p>
</blockquote>
<p>解析阶段开始时间不固定，只是要求在执行getstatic、invokedynamic、instanceof等17个用于<font color = #F9000>操作符号引用</font>的字节码指令之前，对他们所使用的符号引用进行解析。所以虚拟机实现可以根据需要，在类被加载器加载时就对符号引用解析，还是等到一个符号引用被使用前去解析。</p>
<p>对同一个符号引用进行多次解析请求是很常见的事。<br><strong>除了invokedynamic指令</strong>，虚拟机实现可以对第一次解析的结果进行缓存，从而避免解析动作重复进行。如果一个符号引用之前已经被成功解析过，那么之后的解析请求也会一直成功；如果第一次失败，其他指令对这个符号的解析请求也会失败。静态：刚完成加载阶段，还未开始执行代码就可以提前进行解析。<br><strong>对于invokedynamic指令</strong>，当碰到前面已经由该指令触发过的符号引用，并不意味着这个解析结果对其他invokdynamic指令也同样生效。因为这个指令本身用于动态语言支持，它对应的引用称为“<font color = #F9000>动态调用点限定符</font>”。动态：当程序实际执行到这条指令时，解析动作才能进行。</p>
<p>解析动作主要针对：</p>
<table>
<thead>
<tr>
<th>符号引用</th>
<th>对应的常量池的常量类型</th>
</tr>
</thead>
<tbody><tr>
<td>类或接口</td>
<td>CONSTANT_Class_info</td>
</tr>
<tr>
<td>字段</td>
<td>CON-STANT_Fieldref_info</td>
</tr>
<tr>
<td>类方法</td>
<td>CONSTANT_Methodref_info</td>
</tr>
<tr>
<td>接口方法</td>
<td>CONSTANT_InterfaceMethodref_info</td>
</tr>
<tr>
<td>方法类型</td>
<td>cCONSTANT_MethodType_info</font></td>
</tr>
<tr>
<td>方法句柄</td>
<td><font color = #F9000>CONSTANT_MethodHandle_info</font></td>
</tr>
<tr>
<td>调用点限定</td>
<td><font color = #F9000> CONSTANT_Dynamic_info</font>和<font color = #F9000>CONSTANT_InvokeDynamic_info </font></td>
</tr>
<tr>
<td>注：后四种与动态语言支持相关。</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li><strong>类或接口的解析</strong><br>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或者接口C的直接引用，那虚拟机完成整个过程需要三步：<br>1）如果C不是一个数组类型，那么虚拟机把代表N的全限定名传给D的类加载器去加载这个C。在加载过程中，由于元数据验证、字节码验证的需要，可能会触发其他相关类的加载动作，例如父类或者实现的接口。一旦加载过程出现异常，解析过程失败。<br>2）如果C是一个数组类型，N的描述符类似“[Ljava/lang/Integer”形式，那么先按照规则1加载数组元素类型“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。<br>3）若1，2没有异常，C在虚拟机中实际上已经成为一个有效类或接口了，但解析完成前还需要进行符号引用验证，确定D是否具备访问C的权限，不具备抛出IllegalAccessError。JDK9引入模块化后，还需要检查模块间访问权限。</li>
</ol>
<blockquote>
<p><strong>“D拥有C的访问权限”</strong>意味着以下三条中至少存在一条：</p>
<ul>
<li>被访问类C是public，并且与访问类D处于同一个模块</li>
<li>被访问类C是public，与访问类D不处于同一个模块，但C允许D的模块进行访问</li>
<li>被访问类C不是public，但与访问类D处于同一个包</li>
</ul>
</blockquote>
<ol start="2">
<li><strong>字段解析</strong><br>要解析一个未被解析过的字段符号引用：<br>1）对字段表内class_index项中的索引的CONSTANT_Class_info符号引用（就是字段所属类或接口C的符号引用）进行解析；<br>2）如果这个解析过程出现异常，字段符号引用解析将失败；如果解析成功，对C进行后续字段的搜索：<br>&emsp;① 如果C本身包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束。<br>&emsp;② 否则，如果C中实现了接口（或者C不是Object类），那么会向上递归查找各个接口（或父类），如果在接口（或父类）中包含了简单名称和字段描述符都与目标相匹配的字段，直接返回这个字段的直接引用，查找结束。<br>&emsp;③否则，查找失败，抛出NoSuchFieldError异常。<br>&emsp;如果成功返回引用，将会对该字段进行权限验证，不具备抛出IllegalAccessError异常。</li>
</ol>
<p>以上规则能够保证JVM获得字段唯一的解析结果。实际中，Javac编译器更严格。如果有个同名字段同时出现在某个类的接口和父类中，或者同时在自己或父类的多个接口中出现，Javac可能拒绝编译。</p>
<ol start="3">
<li><p><strong>方法解析</strong><br>方法解析的第一步与字段解析一样，先解析出方法表的class_index项中索引的方法所属类或接口C的符号引用，如果成功，按照以下进行搜索：<br>&emsp;① 因为在class文件格式中，类和接口的方法符号引用的常量类型定义是分开的，所以如果在类的方法表中发现class_index索引的C是接口，直接抛出IncompatibleChangeError异常（不相容交换错误）。<br>&emsp;② 如果通过第一步，在C中查找是否有简单名称和描述符都匹配目标的方法，有的话返回这个方法的直接引用，查找结束。<br>&emsp;③ 否则，在类C的父类中递归查找是否有都匹配的方法，有则返回直接引用，查找结束。<br>&emsp;④ <font color = green>否则，在类C实现的接口列表及它们的父接口中递归查找都匹配的方法，如果存在，说明C是一个抽象类，查找结束，抛出AbstractMethodError异常。</font><br>&emsp;⑤ 否则，宣告查找失败，抛出NoSuchMethodError。<br>&emsp;如果查找成功返回了直接引用，将会对这个方法进行权限验证，不具备抛出IllegalAccessError异常。</p>
</li>
<li><p><strong>接口方法解析</strong><br>同样需要先解析出接口方法表class_index项中索引的方法所属类或接口C的符号引用，如果解析成功，进行后续搜索步骤：<br>&emsp;① 与类方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，直接抛出IncompatibleClassChangeError异常。<br>&emsp;② 如果通过第一步，在C中查找是否有简单名称和描述符都匹配目标的方法，有的话返回这个方法的直接引用，查找结束。<br>&emsp;③ 否则，在类C的父接口中递归查找（查找范围包括Object类中方法）是否有都匹配的方法，有则返回直接引用，查找结束。<br>&emsp;④ 对于规则③，由于java的接口允许多继承，如果C的不同父接口中有多个与目标匹配的方法，就从这些中返回一个并结束查找。但与字段查找类似，有的Javac编译器有可能会按照更严格约束拒绝编译。<br>&emsp;⑤ 否则，宣告查找失败，抛出NoSuchMethodError异常。</p>
</li>
</ol>
<p>在JDK9前，Java接口中所有方法都默认public，也没有模块化的访问约束，所以不存在访问权限问题。<br>JDK9中增加了接口的静态私有方法和模块化，所以也会有可能抛出IllegalAccessError异常。</p>
<h3 id="7-3-5-初始化"><a href="#7-3-5-初始化" class="headerlink" title="7.3.5 初始化"></a>7.3.5 初始化</h3><p>&emsp;类的初始化阶段是类加载过程中最后一个阶段，在之前的几个阶段，除了加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其他都是完全由JVM主导控制。初始化阶段，JVM才真正开始执行类中编写的Java程序代码，将主导权交给应用程序。<br>&emsp;在准备阶段，变量已经赋值过一次零值的初始值。<font color = #F9000>初始化阶段就是执行<clinit>()方法的过程。</font><br>· <clinit>()是Javac编译器自动生成物。<br>· <clinit>()是<strong>编译器自动收集类中</strong>的<strong>所有类变量的赋值动作</strong>和<strong>静态语句块中的语句</strong>合并产生的。<br>· 编译器收集的顺序是由语句在源文件中出现的顺序决定的。静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量只能赋值不能访问。<br>· <clinit>()与实例构造器<init>()方法不同，不需要显式地调用父类构造器，<strong>JVM会保证在执行子类的<clinit>()方法之前父类的<clinit>()方法已经执行完毕</strong>。所以JVM中第一个被执行的<clinit>()方法一定是Object。<br>· 父类中定义的静态语句块优先于子类的变量赋值操作。<br>· <clinit>()方法对类或接口来说并不是必不可少的。如果一个类中没有静态语句块，也没有对变量的赋值动作，编译器就不会为该类生成此方法。<br>· 接口中不可使用静态语句块，但可以有变量赋值操作。但与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()。<strong>只有当父接口中定义的变量被使用时，父类接口才会被初始化</strong>。同样，<strong>接口的实现类在初始化时也不会执行接口的<clinit>()方法</strong>。<br>· JVM必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，当一个线程执行这个类的<clinit>()方法时，别的线程需要阻塞等待，直到活动线程完毕。之后别的线程也不会再进行初始化该类，因为同一个类加载器下，一个类只会初始化一次。<br>· 如果在一个类的<clinit>()方法中有耗时长的操作，就可能造成多进程阻塞。</p>
<h2 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h2><p>JVM将“通过一个类全限定名获取描述该类的二进制字节流”这个动作放到虚拟机外面实现，实现这个动作代码称为“类加载器”。</p>
<h3 id="7-4-1-类与类加载器"><a href="#7-4-1-类与类加载器" class="headerlink" title="7.4.1 类与类加载器"></a>7.4.1 类与类加载器</h3><p>· 类本身和它的类加载器共同确定了这个类在JVM中的唯一性。每个类加载器都有一个独立的类名称空间。<br>· 加载类的类加载器不同，这两个类一定不相等。</p>
<h3 id="7-4-2-双亲委派模型"><a href="#7-4-2-双亲委派模型" class="headerlink" title="7.4.2 双亲委派模型"></a>7.4.2 双亲委派模型</h3><p>· 从JVM角度来看，类加载器可分为两种：<br>1）启动类加载器。c++语言实现，是虚拟机自身一部分<br>2）其他所有类加载器。java语言实现，独立于虚拟机外部<br>· 从java开发人员角度来看，自从jdk1.2之后，java一直保持着<font color = #F9000>三层类加载器、双亲委派的类加载结构</font>。</p>
<p><strong>启动类加载器</strong>：这个类加载器负责把存放在<JAVA_HOME>\lib目录，或者被参数-Xbootclasspath指定的路径中存放的，并且能够被虚拟机正确识别的类库加载到虚拟机内存中。启动器类无法被java程序直接引用，如果要委派给引导类加载器中，使用null值替代即可。</p>
<p><strong>扩展类加载器</strong>：它负责加载<JAVA_HOME>\lib\ext目录，或者被java.ext.dirs系统变量指定的路径中所有类库。<br>· 是java类库的扩展机制。jdk9之后被模块化天然扩展能力取代。<br>· 此类加载器在类ClassLoader中以java代码形式实现的，所以可直接在程序中使用它来加载class文件。</p>
<p><strong>应用程序类加载器</strong>：负责加载用户路径（ClassPath）上所有类库。<br>· 由AppClassLoader类实现，也叫做“系统类加载器”。<br>· 开发者也可以直接在代码中使用这个类加载器。<br>· 一般应用程序如果没有自定义自己的类加载器，默认用这个。</p>
<p>JDK9前java应用都需要由这三种类加载器互相配合完成加载的，用户还可以加入自定义类加载器进行扩展。这些类加载器间的协作关系也被称为类加载器的<font color = #F9000>双亲委派模型</font>：<br><img src="https://img-blog.csdnimg.cn/20200729213903150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>除了启动类加载器，都有父类加载器。</li>
<li>父子关系<font color = #F9000>通常</font>（该模型JDK1.2引入，是一个最佳推荐模型，<font color = #F9000>并非强制性约束</font>）使用组合关系来复用父加载器代码。</li>
<li>工作过程：一个类加载器收到了类加载的请求，先不断将委托上派，最终到达启动类加载器。只有当父加载器反馈无法完成这个加载请求（搜索范围没有找到需要的类），子加载器才会去尝试加载。</li>
<li>代码逻辑：先检查请求加载的类型是否被加载过，没有则调用父加载器的loadClass()方法，如果父加载器为空，默认使用启动类加载器作为父加载器。如果父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试加载。</li>
<li>好处：保证同一个类被同一个类加载器加载。反之如果没有双亲委派模型，系统中可能会出现多个不同的类，程序混乱。</li>
</ol>
<h3 id="7-4-3-破坏双亲委派模型"><a href="#7-4-3-破坏双亲委派模型" class="headerlink" title="7.4.3 破坏双亲委派模型"></a>7.4.3 破坏双亲委派模型</h3><p><strong>第一次“破坏”</strong>：jdk1.2之前，用户已经自定义了类加载器代码，java设计者们在引入双亲委派模型时不得不做出一些妥协，增加protected方法findClass()，让用户尽可能重写该方法，保证写出来的类加载器符合双亲委派规则。</p>
<p><strong>第二次“破坏”</strong>：模型自身缺陷导致。双亲委派模型解决了各个类加载器工作时基础类型一致性问题，但是如果有基础类型，但是又需要调用回用户代码，就会出现问题。<br>因此java设计者引入了：<font color = #F9000>ContextClassLoader (线程上下文类加载器)</font>。这个类加载器可以通过Thread类中的方法设置。如果创建线程时还没设置，就从父线程中继承一个，如果在应用程序的全局范围内都没有设置过，就默认为应用程序类加载器。<br>这是一种父类加载器去请求子了加载器完成类加载行为的逆向类加载器。java中涉及SPI（服务提供者接口）的加载基本都采用该方式，如JDBC等。<br>为了不让SPI有多个服务提供者时候，采用硬编码判断，JDK6后引入ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，给SPI的加载提供了一种方案。</p>
<p><strong>第三次“破坏”</strong>：由于用户对程序<font color = #F9000>动态性</font>的追求导致的。<br>· 动态性：代码热替换、模块热部署等。其实就是希望java应用程序能够像鼠标这样的外设一样，即插即用，不用关机重启。<br>· OSGI实现模块化热部署的关键是它自定义的类加载器机制的实现。每一个程序模块（Bundle）都有一个自己的类加载器，当要替换一个bundle时，就连同类加载器一起换掉，实现代码的热替换。<br>· OSGI环境下，类加载器不是双亲委派模型推荐的树状结构，而是发展为更复杂的<font color = #F9000>网状结构</font>。当收到类加载请求时，OSGI将按照以下步骤顺序搜索：</p>
<ol>
<li>将以java.*开头的类，委派给父类加载器加载</li>
<li>否则，将委派列表名单内（配置文件org.osgi.framework.bootdelegation中定义）的类，委派给父类加载器加载</li>
<li>否则，检查是否在Import-Package中声明，如果是，则委派给Export类的Bundle的类加载器加载</li>
<li>否则，检查是否在Require-Bundle中声明，如果是，则将类加载请求委托给required bundle的类加载器</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载</li>
<li>否则，查找类是否在自己的Fragment Bundle 中，如果在，则委派给Fragment Bundle的类加载器加载</li>
<li>否则，查找Dynamic Import-Package（Dynamic Import只有在真正用到此Package的时候才进行加载）的Bundle，委派给对应Bundle的类加载器加载</li>
<li>否则，类查找失败<br>除了开头两点符合双亲委派规则的原则，剩余都是平级类加载器中查找的。</li>
</ol>
<h2 id="7-5-Java模块化系统"><a href="#7-5-Java模块化系统" class="headerlink" title="7.5 Java模块化系统"></a>7.5 Java模块化系统</h2><p>jdk9中引入了java模块化系统（Java Platform Module System，<font color = #F9000>JPMS</font>）。<br>· 为了实现模块化的关键目标——<font color = #F9000>可配置的封装隔离机制</font>，JVM对类加载架构做了相应调整。JDK9的模块不仅同之前jar包那样仅充当代码容器，还包含：</p>
<ul>
<li>依赖其他模块的列表</li>
<li>导出的包列表，即其他模块可以使用的列表</li>
<li>开放的包列表，即其他模块可以反射访问模块的列表</li>
<li>使用的服务列表</li>
<li>提供服务的实现列表<br>· 可配置的封装隔离机制，首先要解决JDK9之前<font color = #F9000>基于类路径（classpath）来查找依赖的可靠性问题</font>。此前，如果类路径缺失运行时依赖类型，只有当代码运行到发生该类型加载、链接时才会报错。但是jdk9以后，如果启动了模块化封装，模块能够声明对其他模块的显示依赖，jvm在启动时会检查依赖关系在运行期是否完备，如果缺失直接启动失败。<br>· 其次解决了<font color = #F9000>原来类路径上跨JAR文件的public类型访问问题</font>。JDK9之后，必须声明哪一些public的类型可以被哪一些模块访问。这种访问控制也是在类加载中完成的。</li>
</ul>
<h3 id="7-5-1-模块兼容性"><a href="#7-5-1-模块兼容性" class="headerlink" title="7.5.1 模块兼容性"></a>7.5.1 模块兼容性</h3><p>为了使封装隔离机制能兼容原来的类路径查找机制，JDK9提出了“<strong>模块路径</strong>（ModulePath）”：某个类库到底是模块还是传统jar包，只取决于存放在哪个路径上。</p>
<p>模块化系统按照以下规则，来保证使用传统类路径依赖的java程序能直接运行在jdk9及以上的版本（<font color = #F9000>向后兼容</font>），保证了传统程序可以访问到所有标准类库模块中导出的包。<br>    - <strong>JAR文件在类路径的访问规则</strong>：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个<font color = #F9000>匿名模块</font>里。这个模块几乎没有任何隔离。<br>    - <strong>模块在模块路径的访问规则</strong>：模块路径下的具体模块只能访问到它列明的依赖模块和包，匿名模块中所有内容对<font color = #F9000>具体模块</font>不可见，即看不到传统jar包。<br>    - <strong>JAR文件在模块路径的访问规则</strong>：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块。尽管不包含module-info.class，但<font color = #F9000>自动模块</font>默认依赖于整个【模块路径】中所有模块，也默认导出自己的包。</p>
<p><strong>模块间的管理和兼容性问题</strong>：如果一个模块有很多版本，就只能由开发人员在编译打包时人工选择正确版本的模块来保证依赖的正确性。<br>· Java模块系统目前不支持在模块定义中加入版本号来管理和约束依赖，也不支持版本选择功能。<br>· JDK9加入class文件格式的Module属性，用户可以在编译时指定模块版本，也存在API接口在运行时获得模块版本号。<br>· 但“JPMS目的不是代替OSGi”，希望维持一个足够简单的模块化系统。但Jigsaw仿佛在刻意给OSGi让出空间，使得IBM不反对Jigsaw，代价是JPMS不可能拥有OSGi那样的支持多版本模块并存、支持运行时热替换、热部署模块的能力。所以JDK9后实现这种目的，只能将OSGi和Jigsaw混合使用，没有内置Java模块化系统和Java虚拟机中，必须<font color = #F9000>通过类加载器实现</font>。<br>· JVM内置的JVMTI接口提供了一定程度的运行时修改类的能力，不过有很多限制。不可能直接用来实现OSGi那样的热替换和多版本并存，可以用在IDEA，Eclipse这些IDE上做HotSwap(指IDE编辑方法的代码后不需要重启即可生效)。</p>
<h3 id="7-5-2-模块化下的类加载器"><a href="#7-5-2-模块化下的类加载器" class="headerlink" title="7.5.2 模块化下的类加载器"></a>7.5.2 模块化下的类加载器</h3><p>为了兼容性，JDK9并未从根本上动摇三层类加载器架构以及双亲委派模型。不过模块化下的类加载器为了模块化系统的施行，主要进行了如下几方面的变动：</p>
<ol>
<li>扩展类加载器被<font color = #F9000>平台类加载器</font>取代。整个JDK都基于模块化构建（原来的rt.jar和tools.jar被拆分成10个JMOD文件），先天具有了可扩展性，扩展类加载器没有存在必要，无需再保留<JAVA_HOME>\lib\ext目录。类似的，新版JDK中也取消了<JAVA_HOME>\jre目录，因为可以根据组合构建出程序运行所需的JRE。</li>
<li><font color = #F9000>平台类加载器、应用程序类加载器都不再派生自URLClassLoader</font>，如果有程序依赖这个类或特有方法，那么代码很可能在JDK9及更高版本中崩溃。<br>· 现在，启动类加载器、平台类加载器、应用程序类加载器都继承于<code>jdk.internal.loader.BuiltinClassLoader</code>。在这个类中实现了在新的模块化架构下，如何从模块中加载的逻辑，以及模块中资源可访问性的处理。<br>· 启动类加载器现在是在JVM内部和java类库共同协作实现的类加载器尽管有了BootClassLoader这样的Java类，但为了与之前的代码保持兼容，所有获得启动类加载器的场景中仍然会返回null，而不是BootClassLoader的实例。<br><img src="https://img-blog.csdnimg.cn/20200729214550167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>JDK9中虽然仍维持着三层类加载器和双亲委派的架构，但委派关系发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载之前，要先判断该类是否能够归属到某个系统模块中，如果可以就先委派给负责该模块的类加载器完成加载。<br>Java模块化系统明确规定了三个类加载器负责各自的加载模块。</li>
</ol>
]]></content>
      <categories>
        <category>阅读记录</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>虚拟机类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入了解Java虚拟机》第九章</title>
    <url>/2020/07/31/%E3%80%8A%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="第九章-类加载及执行子系统的案例与实战"><a href="#第九章-类加载及执行子系统的案例与实战" class="headerlink" title="第九章 类加载及执行子系统的案例与实战"></a>第九章 类加载及执行子系统的案例与实战</h1><p>Class文件何种形式存储，类型何时加载、如何连接，虚拟机如何执行指令都是由虚拟机直接控制的行为。能通过程序操作的 ，主要是<font color = #F9000>字节码生成</font>和<font color = #F9000>类加载器</font>两部分功能。</p>
<h2 id="9-2-案例分析"><a href="#9-2-案例分析" class="headerlink" title="9.2 案例分析"></a>9.2 案例分析</h2><h3 id="9-2-1-Tomcat：正统的类加载器架构"><a href="#9-2-1-Tomcat：正统的类加载器架构" class="headerlink" title="9.2.1 Tomcat：正统的类加载器架构"></a>9.2.1 Tomcat：正统的类加载器架构</h3><p>· 主流的Java Web服务器，都实现了自定义的类加载器，且一般不止一个。<br>· 一个功能健全的Web服务器，都要解决这些问题：</p>
<ol>
<li>部署在同一服务器上的<font color = #F9000>两个web应用程序</font>所使用的<font color = #F9000>Java类库</font>可以实现<font color = #F9000>相互隔离</font>。<br> 两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求每个类库在一个服务器只能有一份，服务器应当能保证两个独立应用程序的类库可以<font color = #F9000>互相独立使用</font>。</li>
<li>部署在同一个服务器上的两个web应用程序所使用的类库可以<font color = #F9000>共享</font>。</li>
<li><font color = #F9000>服务器</font>需要尽可能<font color = #F9000>保证自身安全</font>不受部署的web应用程序的影响。因为目前很多服务器也是使用java实现的，有自身的类库依赖，需要与应用程序的类库相互独立。</li>
<li>支持JSP应用的Web服务器，基本都需要<strong>支持HotSwap功能</strong>。<br> JSP文件最终要编译成Java的Class文件才能被虚拟机执行，但JSP文件由于其<font color = #F9000>纯文本存储</font>的特性，运行期被修改的概率远远大于第三方类库或程序自己的class文件。PHP、JSP等网页应用也把修改后不需要重启作为很大的优势。<br> 因此，主流的web服务器都会支持JSP生成类的热替换。</li>
</ol>
<p>· 由于存在上述问题，在部署web应用时，单独一个ClassPath不够。各种服务器都提供了许多类路径（多以lib，classes命名），来<strong>存放不同访问范围和服务对象</strong>的第三方类库。<br>· <strong>通常每个目录下有一个对应的自定义类加载器</strong>，去加载放置在里面的java类库。</p>
<p><strong>以Tomcat为例</strong>：<br>Tomcat目录结构中，可以设置三组目录（/common/<em>、/server/</em>和/shared/<em>，但默认不一定是开放的，可能只有/lib/</em>目录存在）用于放java类库，还有一个存放web应用程序自身的“/WEB-INF/*”目录，一共4组。把Java类库放置在这四组目录中：</p>
<ul>
<li>放置在<strong>/common目录</strong>中。类库可被Tomcat和所有的web应用程序共同使用。</li>
<li>放置在<strong>/server目录</strong>中。类库可被Tomcat使用，对所有的Web应用程序都不可见。</li>
<li>放置在<strong>/shared目录</strong>中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li>
<li>放置在<strong>/WebApp/WEB-INF目录</strong>中。类库仅可被该web应用程序使用，对Tomcat和其他web程序不可见。</li>
</ul>
<p>为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器，按照双亲委派模型来实现。<br>下图是Tomcat 6以前默认的类加载器结构：<br><img src="https://img-blog.csdnimg.cn/20200801211211623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>最上面三个是JDK默认提供的类加载器。下面是Tomcat自己定义的类加载器：</p>
<table>
<thead>
<tr>
<th align="center">类加载器</th>
<th align="center">加载的Java类库的目录</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Common类加载器</td>
<td align="center">/common/*</td>
</tr>
<tr>
<td align="center">Catalina类加载器（也称为Server类加载器）</td>
<td align="center">/server/*</td>
</tr>
<tr>
<td align="center">Shared类加载器</td>
<td align="center">/shared/*</td>
</tr>
<tr>
<td align="center">Webapp类加载器</td>
<td align="center">/WebApp/WEB-INF/</td>
</tr>
</tbody></table>
<p>  · 其中<strong>WebApp类加载器</strong>和<strong>JSP类加载器</strong>通常还会存在多个实例，每个Web应用程序/JSP文件对应一个WebApp类加载器/JasperLoader类加载器。<br><font color = #F9000>（一对多关系）</font></p>
</li>
<li><p>Common类加载器能加载的类都可以被Catalina和Shared类加载器使用。</p>
</li>
<li><p>Catalina和Shared类加载器自己加载的类是相互隔离的。</p>
</li>
<li><p>WebApp类加载器可以使用Shared类加载器加载到的类，但各个WebApp类加载器实例之间相互隔离。</p>
</li>
<li><p>JasperLoader的加载范围只是这个JSP文件所编译出来的那一个Class文件。<br>存在目的就是为了被丢弃：当服务器检测到JSP文件被修改，会替换掉目前的JasperLoader实例，并再建立一个新的JSP类加载器来实现<strong>JSP文件的热交换功能</strong>。</p>
</li>
</ul>
<p>· Tomcat 6及之后，<strong>简化</strong>了默认的目录结构。</p>
<ul>
<li>只有指定了tomcat/conf/catalina.properties配置文件的<code>server.loader</code>和<code>share.loader</code>项后，才会真正建立起Catalina类加载器和Shared类加载器的实例。</li>
<li>否则需要用到这两个类加载器的地方都用Common类加载器的实例代替。</li>
<li>默认配置文件中没有设置这两项，所以Tomcat 6及之后把/common、/server和/shared这3个目录默认合并到一起变成1个<strong>/lib目录</strong>。它相对于以前/common目录中类库的作用。</li>
</ul>
<h3 id="9-2-2-OSGi：灵活的类加载器架构"><a href="#9-2-2-OSGi：灵活的类加载器架构" class="headerlink" title="9.2.2 OSGi：灵活的类加载器架构"></a>9.2.2 OSGi：灵活的类加载器架构</h3><p>· OSGi是一个基于Java语言的<strong>动态模块化规范</strong>。现多用于智慧城市、智慧农业等地方。Eclipse IDE也是基于OSGi规范实现的。<br>· OSGi的每个模块（Bundle）与普通的Java类库区别不大，都以JAR格式进行封装。内部存储的都是Java的Package和Class。但一个Bundle可以声明它所依赖的包（通过Import-Package描述），也可以声明它允许导出的包（Export-Package）。<br>· 一个模块只有被被Export过的Package才可能被外界访问，其他的Package和Class将会被隐藏起来。<br>· 在OSGi里面，Bundle间的依赖关系，从<font color = #F9000>上层模块依赖底层模块</font>转变为<font color = #F9000>平级模块间</font>的依赖。</p>
<p>· 以上<strong>静态的模块化特性</strong>原本也是OSGi核心追求之一，但由于与后来出现的java的模块化系统（<strong>JPMS</strong>）重叠了，所以现在主要发展方向是<strong>动态模块化系统</strong>。今天引入OSGi主要是为了实现模块级的<strong>热插拔功能</strong>。譬如Eclipse中的安装、卸载、更新插件不需要重写启动。</p>
<p>· OSGi有以上诱人特点，必须归功于它<strong>灵活的类加载器架构</strong>。OSGi的Bundle之间，只有规则，<strong>没有固定的委派关系</strong>。<br>· 在不涉及到某具体的Package时，所有Bundle都是平级关系。<br>· 只有具体到使用某个Package时和Class时，才会根据Package导入导出定义来构造Bundle间的委派与依赖。<br>· 另外，当一个Bundle提供服务时，要根据<code>Export-Package列表</code>严格<strong>控制访问范围</strong>。如果一个类存在于类库中，但没有被Export，那这个Bundle类加载器可以找到这个类，但是不会提供给别的类使用，OSGi也不会把其他Bundle的类加载请求委派给它。</p>
<p>· 在OSGi里，类加载时可能进行的<strong>查找规则</strong>如下：</p>
<ol>
<li>以<strong>java.*</strong>开头的类，委派给父类加载器加载。</li>
<li>否则，<font color = green><strong>委派列表名单</strong></font>内的类，委派给父类加载器加载。</li>
<li>否则，<strong>Import列表</strong>中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找<strong>当前Bundle的Classpath</strong>，使用自己的类加载器加载。</li>
<li>否则，查找是否在自己的<strong>Fragment Bundle</strong>中，如果是则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找<strong>Dynamic Import列表</strong>的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找<strong>失败</strong>。</li>
</ol>
<p>· OSGi中，加载器之间的关系为网状结构。虽然灵活性更高，但也有新的隐患。如经常<strong>产生死锁</strong>。<br>· 例如：Bundle A依赖Bundle B的Package B，而Bundle B又依赖了Bundle A的Package A<br>· Bundle A加载Package B里的类时，首先需要锁定当前类加载器的实例对象（<code>ClassLoader.loadClass()</code>是一个同步方法），然后<strong>把请求委派给Bundle B的加载器处理</strong>。这时候如果Bundle B也想加载Package A的类，那就会<strong>锁定自己的加载器再去请求Bundle A的加载器处理</strong>。就会产生死锁。<br>· Equinox提供了一个以牺牲性能为代价的解决方案：用户可以启用<code>osgi.classloader.singleThreadLoads参数</code>，按照<strong>单线程串行化</strong>的方式<strong>强制</strong>进行类加载操作。<br>· JDK7时出现<strong>JDK层面</strong>的解决方案，升级了类加载器架构，在<br>ClassLoader中增加了<code>registerAsParallelCapable方法</code>，对<strong>可并行的类加载</strong>进行注册声明，把<font color = #F9000>锁的级别</font>从ClassLoader对象本身，降低为<font color = #F9000>要加载的类名</font>这个级别。从底层避免以上这类死锁问题的出现。<br>· 换句话说，只要多线程加载的不是同一个类的话，loadClass方法都不会锁住。<br><font color = green>注：依旧以上面的死锁为例。Bundle A中类C中想要加载Package B的类G，Bundle B中类D想要加载Package A的类F。</font></p>
]]></content>
      <categories>
        <category>阅读记录</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>类加载器</tag>
        <tag>字节码生成技术</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入了解Java虚拟机》第八章</title>
    <url>/2020/07/29/%E3%80%8A%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章  虚拟机字节码执行引擎"></a>第八章  虚拟机字节码执行引擎</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><p>· 执行引擎是JVM核心的组成部分之一。“虚拟机”是一个相对于“物理机”而言的，“物理机”的执行引擎是直接建立在处理器、缓存、指令集、操作系统层面上的，“虚拟机”的执行引擎是由软件自行实现的。<br>·《Java虚拟机规范》中制定了概念模型，成为各大发行商的JVM执行引擎的统一外观。<br>· 在不同的虚拟机实现中，执行引擎在执行字节码时，通常会有<font color = #F9000>解释执行</font>（通过解释器执行）和<font color = #F9000>编译执行</font>（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，也可能几个不同级别的即时编译器一起工作。<br>· 外观上看，执行引擎的输入是<font color = #F9000>字节码二进制流</font>，处理过程是<font color = #F9000>字节码解析执行的等效过程</font>，输出的是<font color = #F9000>执行结果</font></p>
<h2 id="8-2-运行时栈帧结构"><a href="#8-2-运行时栈帧结构" class="headerlink" title="8.2 运行时栈帧结构"></a>8.2 运行时栈帧结构</h2><p>· JVM以<font color = #F9000>方法</font>作为最基本的执行单元。<br>· <strong>栈帧</strong>：<br>    ①是用于<font color = #F9000>支持虚拟机</font>进行<font color = #F9000>方法调用</font>和<font color = #F9000>方法执行</font>背后的<strong>数据结构</strong>。<br>    ②是虚拟机<font color = #F9000>运行时数据区</font>中的虚拟机栈的<strong>栈元素</strong>。<br>    ③<strong>存储了</strong>方法的局部变量表、操作数栈、动态连接、方法返回地址和一些额外附加信息。<br>注： 每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。<br>· 在编译java程序源码时候，栈帧中需要多大的局部变量表，操作数栈需要多深就已经被分析出来，并写入方法表的Code属性中。<br>· 一个栈帧需要分配多少内存，并不会受到运行时数据影响。只取决于<font color = #F9000>源码</font>和具体虚拟机实现的<font color = #F9000>栈内存布局形式</font>。<br>· 一个线程中的<font color = #F9000>方法调用链</font>可能会很长，<strong>以Java程序的角度看</strong>，同一时刻、同一条线程里，在<font color = #F9000>调用堆栈的所有方法</font>都同时处于<font color = #F9000>执行状态</font>。<strong>而对于执行引擎来讲</strong>，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”，与这个栈帧所关联的方法称为“当前方法”。<br>· 执行引擎所运行的所有的字节码指令都只针对<font color = #F9000>当前栈帧操作</font><br><img src="https://img-blog.csdnimg.cn/20200731153510105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="8-2-1-局部变量表"><a href="#8-2-1-局部变量表" class="headerlink" title="8.2.1 局部变量表"></a>8.2.1 局部变量表</h3><p>· 一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。<br>· 在编译成class文件时，就在方法的code属性的max_locals项中确定了该方法所需分配的内存大小。<br>· <strong>变量槽</strong>为最小单位，但一个变量槽应占多少内存并未明确指出。只是说都应能存放boolean、byte、char、short、int、float、reference、returnAddress 8种32位以内的数据类型。<br>注：<br>· java语言和JVM中基本数据类型的概念有本质区别。<br>· <strong>reference</strong>：对一个对象实例的引用。虚拟机至少都应通过引用做到：</p>
<ol>
<li>直接或间接地找到对象在<font color = #F9000>java堆中</font>的数据存放的起始地址或索引。</li>
<li>直接或间接地找到对象所属数据类型在<font color = #F9000>方法区中</font>的存储的类型信息。<br>· <strong>returnAddress</strong>：基本不用。是为jsr等字节码指令服务的，古老虚拟机使用这几条指令实现异常处理的跳转，现已经被异常表替代。</li>
</ol>
<p>· 对于64位数据类型，JVM采用高位对其方式为其分配2个变量槽。Java语言中规定只有long和double。这里把它们分割存储的方法与“long和double的非原子协定”中允许把一次long和double读写分割为2次32位读写做法类似。<br>· 局部变量表建立在<font color = #F9000>线程堆栈</font>中，属于线程私有数据，所以无论两个连续变量槽是否为原子操作都不会引起数据竞争和线程安全问题。<br>· 局部变量表采取索引定位的方式访问。索引值从0开始。如果是64位数据类型，一次性访问第N和N+1个变量槽，如果单独访问某一个，在类加载的校验阶段抛出异常。</p>
<p>· 当一个方法调用时，JVM根据局部变量表完成实参到形参的传递。<br>· 如果是<font color = #F9000>实例方法</font>（没有被static修饰），第0位变量槽固定存放用于传递该方法所属对象实例的引用，在方法中可以通过this访问这个默认隐含参数，其余参数根据参数列表顺序从1开始排列。<br>· 参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余变量槽。<br>· 变量槽可以重用，不过某些情况下会直接影响到系统的垃圾收集行为。<br>· 比如一个方法，前面定义了一个占用内存极大但实际已经不会再使用的变量，后面的代码有一些耗时很长的动作，<font color = #F9000>手动赋值null的操作</font>来优化内存回收。<br>（这个操作极端情况有奇用：在对象占用内存大、此方法的栈帧长时间不能回收、方法调用次数达不到即时编译器的编译条件）<br>· 虽然确实有用，但不该产生特别依赖。</p>
<ul>
<li>其一，从编码角度讲，以恰当变量作用域控制回收时间才是最好解决办法。</li>
<li>其二，从执行角度讲，这个操作是建立在执行引擎概念基础上的，但由于”公有设计私有实现”，虚拟机使用解释器执行的时候，通常与概念模型还比较很接近，但是经历即时编译器优化后，差异更大。<br>而实际中，即时编译才是虚拟机执行代码的主要方式，赋null值在经过即时编译优化后几乎是一定会被当作无效操作清除的。</li>
</ul>
<p>· 局部变量不像类变量那样存在“准备阶段”。如果一个局部变量定义了但没有赋值，它是完全不能使用的。</p>
<h3 id="8-2-2-操作数栈"><a href="#8-2-2-操作数栈" class="headerlink" title="8.2.2 操作数栈"></a>8.2.2 操作数栈</h3><p>· 也叫操作栈，操作数后入先出。<br>· 与局部变量表类似，在编译时往code属性的max_stacks属性中写入了操作数栈的最大深度。<br>· 操作数栈每个元素可以为任意Java数据类型。32位所占的栈容量为1，64位的栈容量为2。<br>· Javac编译器的数据流分析工作保证方法执行的任何时候，操作数栈的深度都不会超过max_stacks里面设置的最大值。</p>
<p>· 当一个方法开始执行的时候，栈为空。方法执行过程中，会有各种入栈出栈的操作（指令往栈中写入或者提取内容）。譬如，调用其他方法的时候是通过操作数栈来进行方法参数的传递。<br>· 操作数栈元素数据类型必须与字节码指令的序列匹配。在编译代码时，编译器必须严格保证，在类校验阶段，数据流分析还会进行验证。比如，对于iadd指令，操作数栈顶两个元素必须都为int。<br>· 模型概念中两个不同的栈帧是完全独立的。实际中，虚拟机会进行优化处理，让<font color = #F9000>两个栈帧有重叠部分</font>。一方面节约内存，一方面在方法调用时直接共享部分数据，不需要再参数复制传递。<br><img src="https://img-blog.csdnimg.cn/2020073115371060.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· java虚拟机的<font color = #F9000>解释执行引擎</font>被称为“<font color = #F9000>基于栈的执行引擎</font>”。</p>
<h3 id="8-2-3-动态连接"><a href="#8-2-3-动态连接" class="headerlink" title="8.2.3 动态连接"></a>8.2.3 动态连接</h3><p>· 每个栈帧都包含一个引用，指向<font color = #F9000>运行时常量池</font>中该栈帧所属方法。<br>· 持有这个引用的目的：支持方法调用过程中的动态连接。<br>· Class文件中的常量池有大量符号引用，字节码中的方法调用指令就是以常量池中<font color = #F9000>指向方法的符号引用</font>作为参数。一部分在类加载阶段或者第一次使用时候就转化为直接引用，称为“静态解析”。另一部分在每次运行期间都转换为直接引用，称为“动态连接”。</p>
<h3 id="8-2-4-方法返回地址"><a href="#8-2-4-方法返回地址" class="headerlink" title="8.2.4 方法返回地址"></a>8.2.4 方法返回地址</h3><p>方法开始执行后，只有两种退出方法。</p>
<ol>
<li>“<strong>正常调用完成</strong>”：执行引擎遇到了任意一个方法返回的字节码指令，这时候可能会有返回值返回给上一层的<font color = #F9000>方法调用者（或者称为主调方法）</font>。是否有返回值、返回值类型都由何种指令决定。</li>
<li>“<strong>异常调用完成</strong>”：方法体内有异常，或者是使用athrow指令产生异常，并且在本方法的font color = #F9000&gt;异常表</font>中没有搜索到匹配的&lt;异常处理器，就会导致方退出。不会给上层调用者提供返回值。<br>注：方法退出都必须返回到方法被调用的位置。方法正常退出，主调方法的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个值。方法异常退出，返回地址要通过异常处理器表来确定，栈帧中通常不会保存这个值。<br>· 方法退出时可能的执行操作有：</li>
<li>恢复上层方法的局部变量表和操作数栈</li>
<li>如果有返回值，将值压入调用者的操作数栈中</li>
<li>调整PC计数器的值以指向下一条指令<br>注：说可能是因为这是基于概念模型的讨论，具体实现要看虚拟机</li>
</ol>
<h3 id="8-2-5-附加信息"><a href="#8-2-5-附加信息" class="headerlink" title="8.2.5 附加信息"></a>8.2.5 附加信息</h3><p>《Java虚拟机规范》允许虚拟机实现中增加一些规范中没有描述的信息到栈帧中，比如有关调试的信息。<br>· 通常讨论概念时，把附加信息、返回地址、动态连接归为一类，称“<strong>栈帧信息</strong>”</p>
<h2 id="8-3-方法调用"><a href="#8-3-方法调用" class="headerlink" title="8.3 方法调用"></a>8.3 方法调用</h2><p>· 方法调用阶段唯一任务是确定调用哪一个方法。进行方法调用是程序运行时最频繁的操作之一。<br>· Class文件的编译过程不包含连接步骤，一切方法调用在Class文件里存储的都只是符号引用。<br>该特性给Java带来更强大的动态扩展能力，但过程也变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h3 id="8-3-1-解析"><a href="#8-3-1-解析" class="headerlink" title="8.3.1 解析"></a>8.3.1 解析</h3><p>类加载的解析阶段，会将一部分的符号引用转化为直接引用，这种解析成立前提：方法在程序真正运行之前，就有一个可确定的调用版本，在运行期间该版本也不可改变。这类方法的调用称为“<strong>解析</strong>”。<br>· 符合“<font color = #F9000>编译期可知，运行期不变</font>”特性的主要是<font color = #F9000>静态方法和私有方法</font>。前者与类型有关，后者在外部不能访问，这种特性决定了它们不可能通过继承等方式重写出其他版本，因此都适合在类加载的解析阶段解析。<br>· 调用不同类型的方法，字节码指令不同。</p>
<ol>
<li>invokestatic：静态方法</li>
<li>invokespecial：实例构造器<init>()方法、私有方法、父类中的方法</li>
<li>invokevirtual：所有虚方法</li>
<li>invokeinterface：接口方法，运行时再确定一个实现该接口的对象</li>
<li><font color = green>invokedynamic</font>：先在运行时动态解析出<font color = #F9000>调用点限定符</font>所引用的方法，然后再执行该方法。<br>注：前四条指令的分派逻辑固定在JVM内部，而最后一条由用户设定的引导方法决定。<br>· 只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段确定唯一调用版本。符合这样条件的方法有：静态方法、实例构造器方法、私有方法、父类方法四种，再加上final修饰的方法（被invokevirtual调用），这五种方法调用在类加载时候就可以进行解析。这些方法称为“<font color = #F9000>非虚方法</font>”，其他的就称为“<font color = #F9000>虚方法</font>”。<br>· 被final修饰的方法，历史设计原因，是使用invokevirtual调用的，但是因为它也无法被覆盖，没有其他版本的可能，所以调用版本肯定也是唯一的，因此<strong>final方法也属于非虚方法</strong>。<br>· 解析调用一定是个<strong>静态</strong>的过程。在编译期间完全确定，在类加载的解析阶段就把涉及到的符号引用转化为直接引用。而另一种主要的方法调用形式：分派，既有静态又有动态，根据<strong>宗量数</strong>可以分为单分派和多分派。两类分派形式两两组合，就用4种情况。<br>注：方法的接收者与方法的参数统称为<font color = #F9000>方法的宗量</font></li>
</ol>
<h3 id="8-3-2-分派"><a href="#8-3-2-分派" class="headerlink" title="8.3.2 分派"></a>8.3.2 分派</h3><ol>
<li><p><strong>静态分派</strong><br> “Method Overload Resolution”。分派一词本身具有动态性，只是许多资料称为“静态分派”.</p>
<p> <code>Human human = new Man();</code><br> · Human称为变量的“<font color = #F9000>静态类型</font>”或者“外观类型”，Man称为变量的“<font color = #F9000>实际类型</font>”或“运行时类型”。<br> · 静态类型和实际类型在程序中都可能发生变化。<br> · 静态类型在编译器是可知的，并且静态类型的变化仅在使用时发生（如强制转型），但这个改变在编译期也是可知的<br> · 实际类型是不确定的，只有到运行到这行代码才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p>
<p> <strong>静态分派和重载</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StaticDispatch() &#123;</span><br><span class="line">    static abstract class Human &#123;&#125;</span><br><span class="line">    static class Man extends Human &#123;&#125;</span><br><span class="line">    static class Woman extends Human &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Human guy) &#123;</span><br><span class="line">        system.out.println(&quot;hi,human&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayHello(Man guy) &#123;</span><br><span class="line">        system.out.println(&quot;hi,man&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayHello(Woman guy) &#123;</span><br><span class="line">        system.out.println(&quot;hi,woman&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human man &#x3D; new Man();</span><br><span class="line">        Human woman &#x3D; new Woman();</span><br><span class="line">        StaticDispatch sr &#x3D; new StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 运行结果：<br> hi,human<br> hi,human</p>
<p> · main方法两次调用重载方法，在<font color = #F9000>方法接收者</font>已经确定是对象“sr”的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。<br> · 代码故意定义了两个静态类型相同，实际类型不同的变量作为调用方法的参数，但是编译器在重载时是通过参数的静态类型作为判断依据的。因此选择了sayHello(Human)作为调用目标。<br> · 由于静态类型在编译期可知，所以编译阶段，<font color = #F9000>Javac编译器</font>就根据<font color = #F9000>参数的静态类型</font>决定使用的重载版本，并把这个方法的符号引用写到main方法里的两条invokevirtual指令的参数中。</p>
<p> · 所有依赖静态类型来决定方法执行版本的分派动作，就是“<strong>静态分派</strong>”。<br> · 静态分派最典型表现就是方法重载。<br> · 静态分派发生在编译阶段，因此确定静态分派的动作实际上并不是由虚拟机执行的，所以有的资料把它归为“解析”而非“分派”。<br> 注：javac编译器往往只能确定一个“相对更合适的”版本。原因是<strong>字面量的模糊性</strong>。</p>
<p> · <strong>选择静态分派目标的过程</strong>（<font color = #F9000>Java语言实现【<strong>方法重载</strong>】的本质</font>）：<br> 1）如果传入参数是‘a’，最佳会选择参数类型为<code>char</code>的重载方法<br> 2）如果没有，也可能会选择参数为<code>int</code>类型的重载方法。因为‘a’除了能代表一个字符串，也可以代表数字97（发生一次自动类型转换）<br> 3）如果没有，可能选择long类型的重载方法97-&gt;97L（二次自动类型转换）<br> …<br> 【<strong>按照<code>char&gt;int&gt;long&gt;float&gt;double</code>的顺序转型进行匹配</strong>】<br> 4）如果都没有，可能会匹配到参数为<code>Character</code>类型的重载方法（发生一次<strong>自动装箱</strong>）<br> 5）如果没有，可能会匹配到参数为<code>Serializable</code>（序列化）的重载方法。<br> 原因：自动装箱后还是找不到装箱类，但找到了装箱类所实现的接口类型，所以发生又一次自动转型。但Character绝不能转型为Integer，它只能安全转型为它的实现的<strong>接口或者父类</strong>。Serializable和Comparable<Character>是它实现的两个接口。<br> 参数为Serializable和Comparable<Character>的重载方法优先级相同。如果这两个同时存在会提示<font color = #F9000>类型模糊</font>，拒绝编译。<br> 必须调用时显示指定字面量的静态类型，如<code>(Comparable&lt;Character&gt;)&#39;a&#39;</code>才能编译通过<br> 6）如果没有，可能会匹配到参数为<code>Object</code>的重载方法。<br> 这时是char装箱后转型为父类了，如果有多个父类，将在继承关系中从下往上搜索<br> 7）如果没有，可能会匹配到参数为<code>char…</code>的重载方法。<br> 可见，<strong>变长参数</strong>的重载优先级是最低的。此时‘a’被当成是char[]的元素。<br> 注：有些在单个参数中能成立的自动转型（char-&gt;int）,在变长参数中是不成立的。<br> 解析和分派不是二选一关系，而是在不同层次上去筛选、确定目标方法的过程。例如静态方法是在编译期确定、类加载期间解析，而选择重载版本的过程是通过静态分派完成的。</p>
</li>
<li><p><strong>动态分派</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DynamicDispatch() &#123;</span><br><span class="line">	static abstract class Human &#123;</span><br><span class="line">		protected abstract void sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">	static class Man extends Human &#123;</span><br><span class="line">		@Override</span><br><span class="line">		protected void sayHello() &#123;</span><br><span class="line">			system.out.println(&quot;man say hello&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static class  Woman extends Human &#123;</span><br><span class="line">		@Override</span><br><span class="line">		protected void sayHello() &#123;</span><br><span class="line">			system.out.println(&quot;woman say hello&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Human man &#x3D; new Man();</span><br><span class="line">		Human woman &#x3D; new Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">		woman.sayHello();</span><br><span class="line">		man &#x3D; new Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 运行结果：<br> man say hello<br> woman say hello<br> woman say hello</p>
<p> javap命令输出代码的字节码，分析：</p>
<pre><code>Human man = new Man();
Human woman = new Woman();</code></pre></li>
</ol>
<ul>
<li><p>0~15行对应这两步，建立man、woman的内存空间，调用man、woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表的变量槽中。</p>
</li>
<li><p>之后，16、20行aload指令分别把刚刚创建的两个对象的引用压到栈顶，这个对象是将要执行sayHello()的接收者。</p>
</li>
<li><p>17、21行都是利用方法调用指令invokevirtual，参数为Human.sayHello()的符号引用，<font color = #F9000>但是这两条指令最终执行的目标方法不同。因此，关键在于指令本身。</font></p>
<p>  指令invokevirtual的运行时解析过程大概分为以下几步：<br>  1）找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C（<font color = green>man的<strong>实际类型</strong>为Man</font>）<br>  2）如果在类型C中找到与常量描述符和简单名称都相符的方法，则进行访问权限校验，如果通过返回这个方法的直接引用，查找过程结束；不通过返回java.lang.IllegalAccessError异常（<font color = green>在Man类中寻找与sayHello()匹配的方法，找到</font>）<br>  3）否则，按照继承关系从下往上对C的各个父类进行第二步<br>  4）如果始终没有找到，抛出java.lang.AbstractMethodError异常</p>
<p>  <font color = green>所以<code>man.sayHello();</code>和<code>woman.sayHello();</code>分别输出<code>man say hello</code>和<code>woman say hello</code>。</font></p>
<p>  · 我们把这种在<strong>运行期</strong>根据<strong>方法接收者的实际类型</strong>确定方法执行版本的分派过程称为<strong>动态分派</strong>。这个过程是Java语言【<strong>方法重写</strong>】的本质。<br>  <font color = green>注：方法的接收者这里理解为<code>Human man = new Man();</code>中的man</font><br>  · 静态类型相同的对象调用重写方法，结果不同。这种多态性的根源在于虚方法调用指令invokvirtual的执行逻辑，因此我们得出的结论<font color = #F9000>只对方法有效，对字段无效</font>。因为字段不使用该指令。<br>  · 事实上，在java中只有虚方法存在，没有虚字段。即字段永远不参与多态。当子类声明了与父类相同名称的字段时，子类字段会掩蔽父类同名字段。<br>  · 哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段<br>  <img src="https://img-blog.csdnimg.cn/20200731154558404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  <img src="https://img-blog.csdnimg.cn/20200731154617397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>  · Son类创建时，先隐式调用Father的构造函数。Father构造函数中对showMeTheMoney()的调用是一次<font color = #F9000>虚方法调用</font>，执行的是子类版本，而此时子类的money为0.要到子类构造函数执行时才会初始化。<br>  · Son的构造函数往后执行，对money赋值为4，调用自己的函数。<br>  · 最后一句通过静态类型访问到了父类的money，为2。</p>
</li>
</ul>
<ol start="3">
<li><p><strong>单分派与多分派</strong></p>
<blockquote>
<p>根据分派基于多少种宗量（方法的接收者和方法的参数）<br> 划分。单分派是根据一个宗量<font color = #F9000>对目标方法进行选择</font>，多分派则是根据多于一个宗量对目标方法进行选择。</p>
</blockquote>
<p> · 如今的java语言是一门<strong>静态多分派、动态单分派</strong>的语言。<br> <img src="https://img-blog.csdnimg.cn/20200731154646430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> main方法中调用两次hardChoice()方法。</p>
</li>
</ol>
<ul>
<li><p>首先关注编译阶段中编译器的选择过程，也就是<font color = #F9000>静态分派</font>过程。<br>  · 这时候选择目标方法的依据有两点：一是静态类型是Father还是Son，二是方法参数是QQ还是360。<br>  · 选择的最终产物：产生两条invokvirtual指令，参数分别是常量池中指向<code>Father::hardChoice(360)</code>及<code>Father::hardChoice(QQ)</code>方法的符号引用。<br>  · 这是<font color = #F9000>根据两个宗量</font>进行选择，所以Java静态分派属于多分派类型。</p>
</li>
<li><p>再看运行阶段中虚拟机的选择，也就是<font color = #F9000>动态分派</font>的过程。<br>  · 在执行<code>son.hardChoice(new QQ())</code>时，准确说执行这行代码所对应的invokvirtual指令时，由于编译期已经决定目标方法的签名必须为hardChoice(QQ)，这时候参数的静态类型、实际类型都对方法的选择不会产生影响。<br>  · 唯一可以影响虚拟机选择的因素只有该方法接收者的实际类型是Father还是Son。<br>  · <font color = #F9000>只有一个宗量</font>作为选择依据，所以Java动态分派属于单分派类型。</p>
<p>  · JDK10时Java出现了var关键字，与dynamic有本质区别：<strong>var</strong>是在编译时根据声明语句中<strong>等号右侧的表达式类型</strong>来静态推断类型，本质是种<font color = green>语法糖</font>；而<strong>dynamic</strong>在编译时完全不关心类型是什么，等运行的时候再进行类型判断。<br>  · Java语言通过内置动态语言（如JavaScript）执行引擎、加强与其他JVM上动态语言交互能力的方式，来间接满足动态性的需求。<br>  · Java虚拟机层面，早在JDK7就开始提供对动态语言的方法调用的支持了，如JDK7引入了invokedynamic指令。</p>
</li>
</ul>
<ol start="4">
<li>虚拟机动态分派的实现<br> · 虚拟机不同，实现也会有区别。<br> · 动态分派的方法版本选择需要运行时，在接收者类型的方法元数据中搜索合适的目标方法。JVM基于执行性能考虑，真正运行时不会频繁反复搜索类型元数据。<br> · 一种基础而常见的优化手段：为类型在方法区中建立一个<strong>虚方法表</strong>（vtable，与之对应的，在invokeinterface执行时也会用到<strong>接口方法表</strong>——itable），使用虚方法表索引来代替元数据查找以提高性能（与直接搜索元数据相比。实际算最慢的一种分派，只在解释执行状态时使用）<br> · 虚方法表中存放着各个方法的实际入口地址。<br> · 如果某个方法在子类中没有被重写，那子类虚方法表中的入口地址和父类中该方法的入口地址相同，都指向父类的实现入口。<br> · 如果子类重写了这个方法，那子类虚方法表中的入口地址会替换成子类实现版本的入口地址。<br> · 具有相同签名的方法，在父子类的虚方法表中具有一样的索引号。<br> · 虚方法表一般在<strong>类加载的连接阶段</strong>进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚拟机表一同初始化完毕。<br> <img src="https://img-blog.csdnimg.cn/20200731155250877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li><p>如图，Son重写了父类所有方法，所以没有指向父类的箭头。但它们都没有重写Object的方法，所以都指向Object的数据类型。</p>
<p>  · 由于java对象里面的方法默认（即不使用final修饰）为虚方法， 除了查虚方法表外，还有类型继承关系分析（Class Hierarchy Analysis，CHA）、守护内联（Guarded Inlining）、内联缓存（InlineCache）等多种非稳定的激进优化来争取更大性能空间。</p>
</li>
</ul>
<h2 id="8-4-动态类型语言支持"><a href="#8-4-动态类型语言支持" class="headerlink" title="8.4 动态类型语言支持"></a>8.4 动态类型语言支持</h2><p>· JDK7增加了invokedynamic指令。<br>· 这条指令是实现动态类型语言支持而进行的改进之一，也是为JDK8顺利进行Lambda表达式做的技术储备。</p>
<h3 id="8-4-1-动态类型语言"><a href="#8-4-1-动态类型语言" class="headerlink" title="8.4.1 动态类型语言"></a>8.4.1 动态类型语言</h3><p>· 与动态语言不同。<br>· <strong>动态类型语言</strong>的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的。例如JavaScript、Python、PHP、Ruby等语言。<br>· 相对的，在编译期就进行类型检查过程的语言，譬如c++和java等就是最常用的<strong>静态类型语言</strong>。<br>· 动态类型语言的一个核心特征：<font color = #F9000>变量无类型而变量值才有类型</font><br>· 编译与运行示例<br><img src="https://img-blog.csdnimg.cn/20200731155345835.png" alt="在这里插入图片描述"></p>
<ul>
<li>上面这段java代码能正常编译，但在运行过程中会抛出<code>NegativeArraySizeException异常</code>（属于运行时异常）。</li>
<li>运行时异常指只要代码不执行到这一行就不会出现问题</li>
<li>· 连接时异常，例如<code>NoClassDefFoundError</code>，即使无法执行到这一句，<strong>类加载时</strong>（java的连接过程不在编译阶段，在类加载阶段）也会抛出异常。<br>  · 然而同样语义的代码在c语言的编译期就直接报错。<br>  · 因此，哪门语言哪种检查行为要在运行期进行或者在编译期进行没有必然逻辑关系。在于语言规范中的人为设立的约定。<br>· <strong>类型检查</strong>：<br><code>obj.println(&quot;hello&quot;);</code></li>
<li>Java语言中如果obj的静态类型是一个接口（PrintStream类），那么obj的实际类型必须是实现这个接口的类，否则即使obj属于一个确实包含了这个方法相同签名方法的类型，代码依旧无法运行。类型检查不合法。</li>
<li>JavaScript语言中，无论obj具体是何种类型，无论继承关系如何，只要这个变量所属的类确实包含有println(String)方法，能找到相同签名的方法，调用就可以成功。</li>
<li><strong>原因</strong>：<br>  · <strong>Java语言</strong>在编译期已经将println(String)方法完整的<strong>符号引用</strong>（本例中为一项CONSTANT_InterfaceMethodref_info常量）生成出来，并作为方法调用指令的参数存储到Class文件中。<br>  · <strong>动态类型语言</strong>，变量obj本身没有类型，变量obj的值才有类型。所以编译器在编译时只能确定方法名、参数、返回值信息，而不会确定方法所在的具体类型（<strong>方法接收者不固定</strong>）<br>  注：符号引用包含该方法定义在哪个类型中，方法名，参数顺序，参数类型，方法返回值等信息。</li>
</ul>
<h3 id="8-4-2-Java与动态类型"><a href="#8-4-2-Java与动态类型" class="headerlink" title="8.4.2 Java与动态类型"></a>8.4.2 Java与动态类型</h3><p>java语言运行在Java虚拟机上，而许多动态类型语言现在也运行于Java虚拟机上，不过还有所欠缺。主要表现值方法调用方面：</p>
<ul>
<li>JDK7前的4条方法调用指令（invokevirtual、invokespecial、invokestatic、invokeinterface）的第一个参数都是被调用的方法的符号引用（CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info常量）。</li>
<li>方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定方法的接收者。</li>
<li>所以在JVM上实现动态类型语言只能“曲线救国”（如编译时留一个占位符，运行时动态生成字节码，实现具体类型到占位符类型的适配），但这样会带来额外内存开销。其中最严重的性能瓶颈是：动态类型方法调用时，由于无法确定调用对象的静态类型，而导致<strong>方法内联无法有效进行</strong>。<br>  注：方法内联是其他优化措施的基础，是十分重要的一项优化<br><img src="https://img-blog.csdnimg.cn/20200731155551787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>动态类型语言下这样的代码没有问题，但即使每个元素的类型中都有sayHello()，也无法在编译优化的时候就确定具体的sayHello()代码在哪里。编译器只能不停编译每一个方法，缓存起来供运行期选择、调用、内联。如果元素过多，内联缓存压力很大，导致缓存内容不断失效和更新。</li>
<li>这类问题应当在JVM层次上去解决。</li>
<li>因此，JVM层面上提供动态类型的直接支持亟待解决。这就是JDK7时JSR-292提案中invokedynamic指令以及java.lang.invoke包出现的技术背景。</li>
</ul>
<h3 id="8-4-3-java-lang-invoke包"><a href="#8-4-3-java-lang-invoke包" class="headerlink" title="8.4.3 java.lang.invoke包"></a>8.4.3 java.lang.invoke包</h3><p>· 目的：在之前单纯依靠符号引用来确定调用目标方法以外，提供一种新的<strong>动态确定目标方法</strong>的机制，称为“<strong>方法句柄</strong>”（类比c/c++中的函数指针）<br>· 在c/c++中，可以把函数当作参数，用函数指针进行传递。java语言中无法做到，普遍做法是设计一个带有这个函数方法的接口，把接口的实现对象作为参数传递。<br>· 但拥有“方法句柄”后，Java语言也可以拥有类似函数指针这样的工具了。<br>· <strong>方法句柄和反射的区别</strong>：</p>
<ol>
<li>Reflection和MethodHandle机制本质上都是在模拟方法调用，但前者在模拟Java<strong>代码层次</strong>的方法调用，而后者在模拟<strong>字节码层次</strong>的方法调用。<br>在<code>MethodHandles.Lookup</code>上的3个方法findStatic()、findVirtual()、findSpecial()正是为了对应于invokestatic、invokevirtual（以及invokeinterface）和invokespecial这几条指令的执行权限校验行为，而这些底层细节使用<code>Reflection API</code>时是不需要关心的。<br>方法的作用：在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</li>
<li>Reflection中的<code>java.lang.reflect.Method对象</code>远比MethodHandle机制中的<code>java.lang.invoke.MethodHandle对象</code>所包含的信息多。<br>· 前者是方法在<font color = #F9000>java端的全面映像</font>，包含了方法的签名、描述符、方法属性表中各种属性的Java端表示方式，还有执行权限等运行期信息。（重量级）<br>· 后者仅包含执行该方法的相关信息。（轻量级）</li>
<li>MethodHandle是对方法指令调用的模拟，所以理论上虚拟机在这方面的各种优化在其上都可以采取相同思路去支持。而反射几乎不可能。</li>
<li>仅站在Java语言的角度，两者的效果相似。而Reflection API的设计目标是只为Java语言服务的，而MethodHandle则设计为可服务于所有Java虚拟机之上的语言。</li>
</ol>
<h3 id="8-4-4-invokedynamic指令"><a href="#8-4-4-invokedynamic指令" class="headerlink" title="8.4.4 invokedynamic指令"></a>8.4.4 invokedynamic指令</h3><p>· 某种意义上说，invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke<em>”指令方法分派规则完全固化在虚拟机之中的问题。把如何查找目标方法的决定权转交到程序员手上。只是后者是用上层代码和API实现，前者是用字节码和class中其他属性、常量来完成 。<br>· 每一处含有invokedynamic指令的位置都被称为“*</em>动态调用点**”。这条指令的第一个参数不再是代表方法符号引用的<code>CONSTANT_Methodref_info常量</code>，而是JDK7新加入的<code>CONSTANT_InvokeDynamic_info常量</code>。<br>· 从这个新常量中能够获得：</p>
<ol>
<li>引导方法<br> · 存放在新增的BootstrapMethods属性中<br> · 是固有参数<br> · 返回值是<code>java.lang.invoke.CallSite</code>对象，代表了真正要执行的目标方法调用</li>
<li>方法类型</li>
<li>方法名称<br>· 根据上述信息，虚拟机能找到并执行引导方法，从而获得一个CallSite对象，最终调用到要执行的目标方法上（把对象返回给invokedynamic指令，实现对目标方法的调用）<br>· 由于invokedynamic指令面向的主要服务对象是JVM上动态类型语言，因此只靠Javac，在JDK7时甚至没办法生成带有这个指令的字节码。直到JDK8引入Lambda表达式和接口默认方法后，java语言才开始享受到这个指令的好处。<br><img src="https://img-blog.csdnimg.cn/20200731155829622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p>Java语言中，如果要访问祖父类：输出 I am grandfather</p>
<ol>
<li>在JDK7 Update 9之前，可以使用方法句柄来解决问题。<br><img src="https://img-blog.csdnimg.cn/2020073115585759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在JDK7 Update 10开始，修正了这个逻辑，必须保证findSpecial()查找方法版本时受到访问约束（对访问控制的限制、参数类型的限制）应与使用invokespecial指令一样。因为invokespecial指令的分派逻辑是固定的，只能按照接收者的实际类型进行分派，所以修正后，输出也变为了<code>I am father</code>。</li>
<li>在新版本的JDK中，可以通过MethodHandles.Lookup类中<code>allowedModes参数</code>来控制访问保护。虽然这个参数只是在Java类库本身使用，没开放给外部设置，不过我们可以通过反射打破限制。<br> <img src="https://img-blog.csdnimg.cn/20200731155927493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h2 id="8-5-基于栈的字节码解释执行引擎"><a href="#8-5-基于栈的字节码解释执行引擎" class="headerlink" title="8.5  基于栈的字节码解释执行引擎"></a>8.5  基于栈的字节码解释执行引擎</h2><p>许多JVM的执行引擎在执行Java代码时有解释执行（解释器执行）和编译执行（即时编译器产生本地代码执行）两种选择。本节中分析了<strong>概念模型</strong>下JVM<strong>解释执行</strong>字节码时，执行引擎是如何工作的。</p>
<h3 id="8-5-1-解释执行"><a href="#8-5-1-解释执行" class="headerlink" title="8.5.1 解释执行"></a>8.5.1 解释执行</h3><p>· 大部分程序代码转换成物理机的目标代码或者是虚拟机的执行指令集之前，都需要经过以下各步骤。<br><img src="https://img-blog.csdnimg.cn/20200731160101988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>下面的那条分支，就是传统编译原理中，程序代码 -&gt; 目标机器代码的生成过程；中间那条分支，就是解释执行的过程。</li>
<li>在执行前先进行词法分析、语法分析，把源码转化成<font color = #F9000>抽象语法树</font>（AbstractSyntax Tree，<font color = #F9000>AST</font>）。</li>
<li>对任何一门语言实现来说，词法、语法分析以至后面的优化器，目标代码生成器，都可以选择独立于执行引擎，形成一个完整意义的编译器去实现。代表：c/c++</li>
<li>也可以选择把其中一部分步骤（如生成AST前的步骤）实现为一个半独立的编译器。代表：Java</li>
<li>还可以把这些步骤和执行引擎全部集中封装起来，如大多数的JavaScript执行引擎。</li>
</ul>
<p>· Java语言中，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历树生成<strong>线性字节码指令流</strong>的过程。这一部分动作部分在JVM外部进行的，而解释器在虚拟机内部，所以Java程序的编译是<strong>半独立实现</strong>的。</p>
<h3 id="8-5-2-基于栈的指令集与基于寄存器的指令集"><a href="#8-5-2-基于栈的指令集与基于寄存器的指令集" class="headerlink" title="8.5.2 基于栈的指令集与基于寄存器的指令集"></a>8.5.2 基于栈的指令集与基于寄存器的指令集</h3><p>· javac编译器输出的字节码指令流，基本上是<strong>基于栈的指令集架构</strong>（Instruction Set Architecture，<strong>ISA</strong>）。<br>注：“基本上”是因为有部分指令带有参数，而纯粹<font color = #F9000>基于栈的指令集架构</font>应该不存在显示参数（零地址指令）<br>· 基于栈的指令集架构依赖操作数栈进行工作。<br>· 基于寄存器的指令集，典型的有x86的二地址指令集，通俗讲就是目前主流PC机中物理硬件直接支持的指令集架构，依赖寄存器工作。<br>· <strong>两者区别</strong>：<br>e.g 计算“1+1”<br>基于栈的指令集：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure>
<ul>
<li>两条指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个变量槽中。</li>
<li>这种指令流通常不带参数，使用操作数栈中数据作为指令的运算输入，运算结果也存放到栈中。</li>
</ul>
<p>基于寄存器的指令集：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV EAX, 1</span><br><span class="line">ADD  EAX, 1</span><br></pre></td></tr></table></figure>
<ul>
<li>先把EAX寄存器值设为1，然后再用ADD指令把这个值加1。</li>
<li>这种二地址指令是x86指令集中的主流，每个指令包含两个输入参数，依赖于寄存器来访问、存储数据。</li>
</ul>
<p>· <strong>两者比较</strong>：<br>基于栈的指令集的优点：</p>
<ol>
<li>基于栈的指令集主要优点是可移植。因为物理机上的寄存器是由硬件直接提供。即使是虚拟机上，也会希望把寄存器尽可能映射到物理寄存器上，获得更高性能。</li>
<li>依赖寄存器不可避免会受到硬件的约束。如果使用栈架构的指令集，用户程序不会直接使用到这些寄存器，就可以由虚拟机实现把访问最频繁的数据（程序计数器、栈顶内存）放到寄存器中，以获得更好性能。</li>
<li>栈架构的指令集代码更紧凑。字节码中每一个字节就代表一条指令，多地址指令集还需要存放参数。</li>
<li>编译器实现更简单。不需要考虑空间分派问题，所需空间都在栈上操作。<br>基于栈的指令集的缺点：<br>理论上解释执行状态下的执行速度慢一些。原因：<br>1) 栈实现在内存中，频繁的栈访问，意味着频繁的内存访问。而对于处理器来说，内存始终是执行速度的瓶颈。<br>&emsp;尽管虚拟机可以采用栈顶缓存的优化方法，把最常用的操作映射到寄存器中避免直接内存访问，但解决不了本质问题。<br>2) 虽然代码紧凑，但是完成相同功能的指令数量会更多。<br>如果采用即时编译器，输出成物理机上的汇编指令流，就与虚拟机采用哪种架构无关了。</li>
</ol>
]]></content>
      <categories>
        <category>阅读记录</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>虚拟机字节码执行引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入了解Java虚拟机》第六章</title>
    <url>/2020/07/22/%E3%80%8A%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 类文件结构"></a>第六章 类文件结构</h1><p><strong>Java虚拟机优势：</strong></p>
<ol>
<li>java虚拟机可以运行在各种不同硬件平台和操作系统上，这些虚拟机可以载入和执行同一种平台无关的字节码（所有平台统一支持的程序存储格式），从而实现“一次编写，到处运行”。</li>
<li>实现语言无关性。java虚拟机只与class这种二进制文件格式关联。Class文件中包含了Java虚拟机指令集、符号表、若干其他辅助信息。虚拟机不关心是什么语言被转换成Class文件。Class文件是jvm执行引擎的数据入口。<br><img src="https://img-blog.csdnimg.cn/20200724165340758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h2 id="class类文件的结构"><a href="#class类文件的结构" class="headerlink" title="class类文件的结构"></a>class类文件的结构</h2><p>· 任意一个Class文件都存储了一个类或者接口的定义信息。但是反过来，类和接口并不一定都定义在文件中。<br>· Class文件是以8字节为基础单位的二进制流，文件中没有分隔符。当遇到占用8字节以上的数据项时候，会按照高位在前分割成若干8字节进行存储。<br>· Class文件格式有两种数据类型“无符号数”和“表”。无符号数是基本数据类型，而表是由无符号数或者表作为数据项构成的复合数据类型，所有表的命名习惯以“_info”结尾。</p>
<ol>
<li>每个Class文件头4字节称“<strong>魔数</strong>”，值为“0xCAFEBABE”确定这个文件是否为一个能被虚拟机接受的class文件。</li>
<li>接着四个字节存储Class文件的<strong>版本号</strong>：5，6为此版本，7，8为主版本号。</li>
<li>接着是<strong>常量池</strong>入口，通常是占用Class文件空间最大的数据项目之一。是表类型数据项目。放置一个u2类型数据代表常量池容量计数值（class文件结构只有它是从第1项开始计数，其他都是第0项），如果不引用任何一个常量池项目值就设为0。<br>• 常量池主要存放：字面量和符号引用。符号引用包括：包，类和接口的全限定名，方法名称和描述，字段名称和描述，方法句柄和方法类型，动态调用点和动态常量。<br>• Class文件不会直接保存各个方法、字段最终在内存中的布局信息，而是当虚拟机做类加载时从常量池中获得对应符号引用，再在类创建或者运行的时候解析、翻译到具体的内存地址中。<br>• 常量池中每一项常量都是一个表。开始为11种表结构数据，为了更好支持动态语言调用，增加4种，之后为了支持java模块化系统，又增加2种。至JDK13有17种。<br>每种结构第一位都是u1类型的标志位，区分常量类型。</li>
<li>接着的两个字节代表<strong>访问标志</strong>。用于识别一些类或者接口层次的访问信息，包括：是接口还是类，是否定义为public，是否定义为abstract等。</li>
<li>紧接着，<strong>类索引</strong>、<strong>父类索引</strong>是一个u2的数据，<strong>接口索引集合</strong>是一组u2类型的集合，这三种数据确定该类型的继承关系。<br>类索引用于确定这个类的全限定名，而父类索引除了Object类外，所有的java类的父类索引都只有一个，且不为0。类索引、父类索引各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过索引值找到定义到CONSTANT_Utf8_info类型的常量中的全限定名字符串。<br><img src="https://img-blog.csdnimg.cn/20200724165640426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接口索引集合则描述这个类实现了哪些接口。（按从左到右的顺序排列到集合中）入口的第一项u2的数据为接口计数器，表示索引表的容量。如果没有实现任何接口值为0。</li>
<li><strong>字段表</strong>用于描述接口或者类中声明的变量。字段修饰符放在access_flags的u2的数据中。之后是name_index和descriptor_index，它们是对常量池的引用，分别代表字段的简单名称及字段和方法的描述符。这三个为固定数据项目。<br><img src="https://img-blog.csdnimg.cn/20200724165704576.png" alt="在这里插入图片描述"><br>字段表集合入口第一个u2类型的数据为容量计数器fields_count，说明字段表数据个数。之后就是access_flags，name_index，descriptor_index。之后跟随着一个属性表集合，用于存储一些额外的信息。</li>
</ol>
<p><em>Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</em></p>
<blockquote>
<p>全限定名，简单名称，描述符概念<br>全限定名就是把类全名中的“.”换成”/“，最后以“；”表示结束。<br>简单名称指没有类型和参数修饰的方法或者字段名称。<br>（字段在Java中，包括类级变量以及实例级变量）<br>描述符用来描述字段的数据类型、方法的参数列表（包括数量、类型、顺序）和返回值。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200724170214499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>对于数组类型，一维使用一个前置”[“描述，二维用两个”[“。例如，int[]将记录成“[I”。描述方法时，参数列表按照顺序放在括号内。如int indexOf(char[]source，intsourceOffset，int sourceCount，char[]target，int targetOffset，inttargetCount，int fromIndex)的描述符为“([CII[CIII)I”</p>
</blockquote>
<p>字段表不会列出继承而来的字段，但可能还出现代码中不存在的字段。另外在java语法中，字段无法重载，但在class文件中，只要两字段描述符不完全相同，字段重名就合法。</p>
<p>7.class文件中对方法的描述与对字段的描述几乎一样，<strong>方法表</strong>中依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。<br><img src="https://img-blog.csdnimg.cn/20200724170300589.png" alt="在这里插入图片描述"><br>方法中的代码经编译成字节码指令后，被存放在方法属性表集合中的一个叫“Code”的属性里面。属性表集合是class文件格式中最具扩展性的一种数据项目。</p>
<p>&emsp;方法表集合入口第一个u2类型的数据为容量计数器fields_count，代表集合中有几个方法。之后为access_flags，name_index，descriptor_index。接下来属性表计数器attributes_count的值表示此方法的属性表集合有几项属性，属性名称的索引值有个对应常量，例如0x0009，对应常量为“Code”，说明此属性是方法的字节码描述。<br>&emsp;与字段表相对于的，如果父类方法在子类中没有被重写，那么方法表集合中不会出现来自父类方法的信息。但也会出现编译器自动添加的方法，最常见的是类构造器“<clinit>()”方法和实例构造器“<init>()”。<br>java中重载一个方法：</p>
<ol>
<li>方法名相同 </li>
<li>拥有一个与原方法不同的特征签名（指一个方法中各个参数在常量池中的字段符号引用的集合，不包括返回值）<br>但是class文件格式中，特征签名的范围更大，只要描述符不完全一致就可以共存。</li>
</ol>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><pre><code>class文件、字段表、方法表都可以携带自己的属性表集合，描述某些场景专有的信息。</code></pre><p>属性表集合限制较宽松，不需要属性表具有严格顺序，只要不与已规定属性名重复，任何人实现的编译器可以向属性表中写入自己定义的属性信息，jvm会自动忽略认不得的属性，所有jvm都能识别的属性已有29项。每个属性名称都是从常量池中引用一个CONSTANT_Utf8_info类型的常量表示，而属性值的结构都是自定义的，在之前只需要一个u4的数据项来说明长度即可。<br><img src="https://img-blog.csdnimg.cn/20200724170417716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li><p><strong>Code属性</strong><br>java经编译后的方法体变成字节码指令存储在这里面。不是每个方法表都需要该属性。如果存在该属性，则code属性表结构为：<br><img src="https://img-blog.csdnimg.cn/20200724170525236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> · attribute_name_index指向常量池的CONSTANT_Utf8_info型常量的索引，常量值固定为“Code”，代表属性的属性名称<br> · attribute_length指示了属性值的长度<br> · max_stack代表了操作数栈的最大深度值<br> · max_locals代表了局部变量表所需要的存储空间。单位是“变量槽slot”（除了double、long占2变量槽，其他长度不超过32位的数据类型每个局部变量都占一个），变量槽是虚拟机为局部变量分配内存最小单位。局部变量表中存放：方法参数（包括隐藏this），try-catch的catch块定义的异常处理参数，方法体中的局部变量。JVM会重用变量槽，所以运行过程中同时生存的最大局部变量数量和类型来计算max_locals大小<br> · code_length和code存储的是字节码指令信息， code_length表示字节码长度。虽然是u4类型，但是JVM规定一个方法长度不超过（65535，u2的长度），超过就拒绝编译。每条指令是一个u1类型的单字节，jvm访问到这个单字节就能知道对应的指令、是否需要参数、参数如何解析等信息。code可以一共表达256条指令，不过目前只有200多条<br> · 之后的异常表集合并不是必须存在的。规定使用异常表来实现java异常及finally处理机制<br> 如果把一个java程序分为代码（方法体中的代码）和元数据（包括类、字段、方法定义及其他），那么Code属性描述代码，其他属性都描述元数据。</p>
</li>
<li><p><strong>Exceptions属性</strong></p>
<blockquote>
<p>方法表中与Code属性平级的一个属性，与异常表不同。作用是列举出可能抛出的受查异常</p>
</blockquote>
<p> <img src="https://img-blog.csdnimg.cn/20200724170636273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> number_of_exceptions项表示受查异常的个数，每一种异常使用一个exception_index_table项表示。exception_index_table是指向常量池中CONSTANT_Class_info型常量的索引，表示该异常的类型。</p>
</li>
<li><p><strong>LineNumberTable属性（可选）</strong><br> 描述源代码行号和字节码行号之间的对应关系。<br> <img src="https://img-blog.csdnimg.cn/20200724170820107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> line_number_table是一个长度为line_number_table_length，类型为line_number_info的集合。line_number_info表包含start_pc和line_number两个u2类型的数据项，分别代表字节码行号，和源码行号。</p>
</li>
<li><p><strong>LocalVariableTable及LocalVariableTypeTable属性（可选）</strong><br> Code属性的子属性。用于描述栈帧中局部变量表的变量与java源码中定义的变量之间的关系。<br> <img src="https://img-blog.csdnimg.cn/20200724170910311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 其中local_variable_info项目代表了一个栈帧和源码中的局部变量的关联。<br> <img src="https://img-blog.csdnimg.cn/20200724170933900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> · Start_pc和length分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度。结合起来就是这个局部变量在字节码中的作用范围。<br> · name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了这个局部变量的名称和描述符。<br> · index是这个局部变量在栈帧的局部变量表中变量槽的位置。如果数据类型为64位，那么占用index，index+1两个变量槽。</p>
<p> JDK5引入泛型之后，增加了一个LocalVariableTypeTable属性。仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature）。对于非泛型，描述符和特征签名信息吻合，对于泛型，描述符不能准确描述泛型类型，需要用特征签名。</p>
</li>
<li><p><strong>SourceFile及SourceDebugExtension属性（可选）</strong><br> SourceFile属性记录Class文件对应的源码文件名。java中多数类名与文件名一致，也有例外（例如内部类）<br> <img src="https://img-blog.csdnimg.cn/2020072417101570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。<br> JDK 5时，新增了SourceDebugExtension属性用来存储程序员新增的自定义额外代码调试信息。一个类最多只允许存在一个这个属性。</p>
</li>
<li><p><strong>ConstantValue属性</strong><br> 通知JVM自动为静态变量赋值。<br> 对于不用static修饰的实例变量的赋值是在实例构造器<init>()方法中进行的；对于类变量，可以使用类构造器<clinit>()方法，也可以使用ConstantValue属性。Oracle公司的javac编译器的选择是：如果用了final和static修饰，并且数据类型为基本类型或者String的话，就会生成ConstantValue属性进行初始化；否则就选择<clinit>()方法初始化。<br> ConstantValue属性只支持基本数据类型和字符串类型的原因：此属性的属性值是一个常量池的索引号，而class文件中常量类型只有与基本数据类型和字符串相对应的字面量。<br> <img src="https://img-blog.csdnimg.cn/20200724171133920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 此属性是个定长属性，所以attribute_length数据项值必须固定为2。constantvalue_index数据项代表了常量池中一个字面量常量的引用，可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info和CONSTANT_String_info常量中的一种。</p>
</li>
<li><p><strong>InnerClasses属性（可选）</strong><br> 记录内部类与宿主类间的关系。如果一个类中有内部类，编译器会自动生成该属性。<br> <img src="https://img-blog.csdnimg.cn/2020072417120767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>· inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，代表内部类和外部类的符号引用。</code></pre><p> · inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，匿名类值为0.<br> · inner_class_access_flags是内部类的访问标志，值代表不同含义，如是否为public，是否为接口等等。</p>
</li>
<li><p><strong>Deprecated及Synthetic属性</strong><br> 两个属性都是属于标志类型的布尔属性。没有属性值需要设置，attribute_length数据项的值必须为0x00000000。<br> Deprecated用于表示某个类、字段、方法，不再推荐使用。<br> Synthetic属性代表此字段或者方法是由编译器自行添加的，实现越权访问等功能，是早期优化的技巧。jdk5之后可以通过设置ACC_SYNTHETIC标志位来完成Synthetic属性的功能。</p>
</li>
<li><p><strong>StackMapTable属性</strong><br> JDK6增加进入Code属性的属性表中，是一个变长属性。在虚拟机加载字节码验证阶段被新类型检查验证器使用，代替之前消耗性能的基于数据流分析的类型推导验证器。新的验证器省去了推导验证器在运行期的通过数据流分析字节码行为逻辑合理性的步骤，改成直接在编译阶段将一系列验证类型记录到class文件中，通过检查这些验证类型代替类型推导过程。<br> 每个StackMapTable中包含0到多个栈映射帧（Stack Map Frame），每个帧都显示或隐式代表了一个字节码的偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。<br> 对于版本号&gt;=50的class文件，如果code属性没有附带该属性，就认为携带一个隐式的StackMap属性。这个属性相当于number_of_entries值为0的StackMapTable属性。一个方法最多只能有一个StackMapTable属性。</p>
</li>
<li><p><strong>Signature属性（可选）</strong><br>JDK5加入的一种变长属性，可以出现在类、字段表、方法表结构的属性表中。Java使用的是擦除式的“伪泛型”，就是当编译完成时直接清除掉泛型的信息（类型变量、参数化类型）。优点是简单，在运行时能够节约内存空间，但是缺点是运行的时候无法像c#等有真泛型支持的语言那样，把泛型类型与用户定义的普通类型同等对待，例如运行期间不能获得泛型信息。Signature属性就是为了弥补这个缺陷，记录泛型签名信息。现在java的反射API最终能够获得泛型信息，数据也就是来源这个属性。<br><img src="https://img-blog.csdnimg.cn/20200724171242493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Signature_index项的值为指向常量池的CONSTANT_Utf8_info结构的索引。如果当前signat属性是类文件/方法表/字段表的属性，则CONSTANT_Utf8_info结构表示类签名/方法类型签名/字段类型签名。</p>
<pre><code>11. BootstrapMethods属性</code></pre><p>Jdk7新增的一个变长属性，位于类文件的属性表中。这个属性用于保存InvokeDynamic指令引用的引导方法限定符。<br>规定如果常量池中曾经出现过CONSTANT_InvokeDynamic_info类型的常量，那么这个类文件属性表就需要有一个BootstrapMethods属性（有且只有一个）。</p>
</li>
<li><p><strong>MethodParameters属性</strong><br>jdk8时新加入class文件，用在方法表中的变长属性。用来记录方法的各个形参名称和信息。LocalVariableTable属性如果没有方法体就没有局部变量表，就不能保存方法参数名称。而MethodParameters属性<br>与code属性平级，可以运行时通过反射API获取。</p>
</li>
<li><p><strong>模块化相关属性</strong><br>jdk9的重量级功能为java模块化功能。因为模块描述文件（module-info.java）最终要以模块形式编译成独立文件，所以class文件格式也扩展了Module、ModulePackages和ModuleMainClass三个属性来支持模块化功能。<br>· module属性是一个变长属性，表示该模块的名称、版本、标志信息、模块导出包信息等内容。<br>· ModulePackages属性是一个变长属性，描述的是模块中所有的包（无论是export或者open的）。<br>· ModuleMainClass属性是一个定长属性，用于确定该模块的主类（Main Class）</p>
</li>
<li><p><strong>运行时注解相关属性</strong><br>JDK5，提供对注解的支持。为了存储注解信息，Class文件中增加了RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、RuntimeVisibleParameterAnnotations和RuntimeInvisibleParameter-Annotations四个属性。JDK8，进一步加强注解的使用范围，新增注解类型，class文件同步增加了RuntimeVisibleTypeAnnotations和RuntimeInvisibleTypeAnnotations两个属性。<br>这六个属性很相似，以RuntimeVisibleAnnotations为代表进行介绍。一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注解。<br><img src="https://img-blog.csdnimg.cn/20200724171330629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>num_annotations是annotations数组的计数器，每个数组元素代表一个运行时可见注解。注解在class文件中以annotation的结构来存储。<br><img src="https://img-blog.csdnimg.cn/20200724171352539.png" alt="在这里插入图片描述"><br>· type_index是一个指向常量池CONSTANT_Utf8_info常量的索引值，常量以字段描述符来表示一个注解。num_element_value_pairs是element_value_pairs数组的计数器，element_value_pairs中每个元素为一个键值对，代表该注解的参数和值。</p>
</li>
</ol>
<h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><p>jvm的指令由一个字节长度的数字（操作码opcode）以及之后0到多个的操作所需的参数（操作数operand）构成。由于jvm采用面向操作数栈的架构，所以大多数指令不包含操作数，操作数都存放在操作数栈中。<br>因为class文件格式放弃了编译后操作数长度对齐，意味着jvm处理超过1字节的数据时，不得不在运行时从字节中重建出具体的数据结构。这种操作会导致解释执行字节码时将损失一些性能，也有优势：可以省略大量填充和间隔符，获得精干的编译代码。</p>
<h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p><strong>大多数指令包含其操作对象所对应的数据类型信息</strong>。两条操作数据类型不同的指令，在虚拟机内部可能会是由同一段代码来实现，但在class文件中它们必须拥有各自独立的操作码。<br>指令中有特殊的字符来表明为哪种数据类型服务：符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。还有的指令并没有用特殊字符来指明，因为它只为一种数据服务。<br>但是如果每种数据类型和每个操作都有对应的指令，操作码只有一个字节数量太少。所以指令集设计成<font color = #9000><strong>非完全独立的</strong></font>。利用替换指令模板中的T，得到一个具体的字节码指令。<br>大部分指令不支持byte、char、short类型，没有任何指令支持Boolean类型。编译器会在编译或者运行期间扩展为int型数据，将Boolean和char类型零位扩展为int数据类型。<strong>在处理这四类数组时，也会转换成int型数组</strong>。</p>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><p><img src="https://img-blog.csdnimg.cn/20200725170712633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="公有设计，私有实现"><a href="#公有设计，私有实现" class="headerlink" title="公有设计，私有实现"></a>公有设计，私有实现</h2><p>· JVM应有的共同程序存储格式：class文件格式以及字节码指令集。这些内容与硬件、操作系统、JVM实现之间都是完全独立的。<br>· JVM都必须实现：1.能够读取class文件；2.精确实现包含在其中的代码语义。一个优秀的JVM，在约束内，对具体实现进行修改优化是可行的，在后台如何处理class文件是实现者自己的事，<font color = #9000><strong>只需要外部接口与规范保持一致</strong></font>。不必完全逐字实现《java虚拟机规范》。<br>· 根据虚拟机实现者关注的是性能、内存消耗、可移植性，使用上面的伸缩性来获得。虚拟机实现的方法主要有以下两种：</p>
<ol>
<li>将输入的jvm代码在加载或者执行时翻译成另一种虚拟机的指令集；</li>
<li>将输入的jvm代码在加载或者执行时翻译成宿主机处理程序的本地指令集（即时编译器代码生产技术）</li>
</ol>
<h2 id="Class-文件结构的发展"><a href="#Class-文件结构的发展" class="headerlink" title="Class 文件结构的发展"></a>Class 文件结构的发展</h2><p>· Class 文件结构一直处于相对稳定的状态，改进基本集中于可扩展数据结构中新增内容（访问标志、属性表等）。<br>· Class 文件格式所具备的平台中立、紧凑、稳定、可扩展的特点，是java技术体系实现平台无关、语言无关的重要支柱。</p>
]]></content>
      <categories>
        <category>阅读记录</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Class类文件结构</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入了解Java虚拟机》第十章</title>
    <url>/2020/08/02/%E3%80%8A%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="第十章-前端编译与优化"><a href="#第十章-前端编译与优化" class="headerlink" title="第十章 前端编译与优化"></a>第十章 前端编译与优化</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><pre><code>本只讨论第一类编译期和编译器。</code></pre><p>· <strong>“编译期”</strong></p>
<ol>
<li>有可能指一个编译器的前端把<font color = #F9000><em>.java</font>文件转变成<font color = #F9000></em>.class</font>文件的过程；</li>
<li>也可能指Java虚拟机的<strong>即时编译器</strong>（<strong>JIT编译器</strong>，Just In Time Compiler）运行期把字节码转变为本地机器码的过程；</li>
<li>还可能指使用静态的<strong>提前编译器</strong>（<strong>AOT编译器</strong>，Ahead Of Time Compiler）直接把<font color = #F9000>程序编译成与目标机器指令集相关的二进制代码</font>的过程。<br>· 上面<em>三类编译过程</em>中有一些比较有代表性的编译器产品：</li>
</ol>
<ul>
<li>前端编译器：JDK的<strong>Javac</strong>、Eclipse JDT中的增量式编译器(ECJ)。</li>
<li>即时编译器:HotSpot虚拟机的C1、C2编译器，Graal编译器。</li>
<li>提前编译器：JDK的Jaotc、GNU Compiler for theJava（GCJ）、Excelsior JET。<br>· Javac这类前端编译器对代码的运行效率几乎没有任何优化措施可言，基本都集中到了即时编译器中。<br>· 如果把“优化”定义放宽，把对开发阶段的优化也算进来Javac确实做了许多针对Java语言编码过程的优化措施来降低编码复杂度，提高编码效率。<br>· 相当多新生的java语法特性，都是靠编译器的“<font color = #F9000>语法糖</font>”来实现，而不是依赖字节码或JVM的底层改进来支持。</li>
</ul>
<h2 id="10-2-Javac编译器"><a href="#10-2-Javac编译器" class="headerlink" title="10.2 Javac编译器"></a>10.2 Javac编译器</h2><h3 id="10-2-1-Javac的源码与调试"><a href="#10-2-1-Javac的源码与调试" class="headerlink" title="10.2.1 Javac的源码与调试"></a>10.2.1 Javac的源码与调试</h3><p><strong>javac发展过程</strong>：</p>
<ol>
<li>JDK6之前，Javac并不属于标准Java SE API的一部分，它实现代码单独存放在tools.jar中，要在程序中使用的话就必须把这个库放到<strong>类路径</strong>上。</li>
<li>JDK6及之后，Javac编译器的实现代码晋升成为标准Java类库之一。</li>
<li>JDK9时，整个JDK所有的Java类库都采用模块化进行<strong>重构划分</strong>，Javac编译器就被挪到了<code>jdk.compiler模块</code>。</li>
</ol>
<p>· Javac编译器除了JDK自身的标准类库外，就只引用了JDK_SRC_HOME/langtools/src/share/classes/com/sun/<em>里面的代码，所以我们的代码编译环境建立时基本无须处理依赖关系。<br>*</em>e.g** Eclipse IDE为开发工具，先建立一个Java工程，然后将上述目录下的文件全部复制到工程的源码目录中。之后，就可以运行main方法来执行编译了。使用参数与Javac命令相同。</p>
<ul>
<li>源码文件有的可能会提示“Access Restriction”（访问限制），被Eclipse拒绝编译。</li>
<li>这是Eclipse为了防止引用非标准类库导致出现兼容性问题。在“JRE System Library”设置中默认包含了一系列的代码访问规则（Access Rules），如果代码引用了规则中禁止的类，就会报错。</li>
<li>我们可以通过自行添加一条允许访问规则来解决。</li>
</ul>
<p>· 从Javac代码总体结构看，编译过程大致可以分为“<font color = #F9000>1准备3处理</font>”过程：<br>    1) 准备过程：初始化插入式注解处理器<br>    2) 解析与填充符号表过程：<br>    · 词法、语法分析。将源代码字符流转变成<font color = #F9000>标记集合</font>，构造出抽象语法树。<br>    · 填充符号表。产生<font color = #F9000>符号地址和符号信息</font>。<br>    3) 插入式注解处理器的注解处理过程<br>    4) 分析与字节码生成过程，包括：<br>    · 标注检查。对语法的静态信息进行检查。<br>    · 数据流及控制流分析。对程序动态运行过程进行检查。<br>    · 解语法糖。将简化代码编写的<font color = #F9000>语法糖还原</font>为原有的形式。<br>    · 字节码生成。将前面各步骤生成的信息转化为字节码。<br>注：上述三个处理过程里，执行插入式注解时可能会产生新的符号，一旦产生，就需要转会之前的处理中第二步，重新处理这些新符号。<br><img src="https://img-blog.csdnimg.cn/20200802144943847.png" alt="在这里插入图片描述"><br>· Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类。代码逻辑集中在这个类的compile()和compile2()中。<br><img src="https://img-blog.csdnimg.cn/20200802145014574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="10-2-2-解析与填充符号表"><a href="#10-2-2-解析与填充符号表" class="headerlink" title="10.2.2 解析与填充符号表"></a>10.2.2 解析与填充符号表</h3><ol>
<li><p>词法、语法分析<br> <strong>词法分析</strong>是将源代码的<font color = #F9000>字符流</font>转变为<font color = #F9000>标记（Token）集合</font>的过程。<br> · 单个字符是程序编写的最小元素，但是标记才是编译时的最小元素。<br> · 标记包括：关键字、变量名、运算符、字面量。<br> e.g  <code>int a=b+2</code> 这句代码中就包含了6个标记，int关键字由三字符构成，但是只是一个独立标记。</p>
<p> 语法分析是根据<font color = #F9000>标记序列</font>构造<font color = #F9000>抽象语法树(AST)</font>的过程。<br> · AST是一种用来<font color = #F9000>描述程序语法结构</font>的树形表示方式，每个节点代表程序代码中一个语法结构。<br> · 语法结构（Syntax Construct）包括：包、类型、修饰符、接口、返回值、代码注释等。</p>
<p> 解析之后，编译器就不会对源码字符流操作了，后续操作都是建立在<strong>抽象语法树</strong>上。</p>
<ol start="2">
<li>填充符号表<br>· <strong>符号表</strong>是由一组<font color = #F9000>符号地址和符号信息</font>构成的<strong>数据结构</strong>。实现形式多样，如哈希表、有序符号表、树状符号表等。<br>· 符号表中所登记的信息，在编译不同阶段都会用到。譬如，<strong>语义分析</strong>阶段，将用于语义检查（如一个名字的使用与原先的声明是否一致）和产生中间代码。在<strong>目标代码生成</strong>阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。<br>· Javac源代码中，填充符号表的过程由com.sun.tools.javac.comp.Enter类实现。<br>· 该过程的产物是一个待处理表，其中包含了每一个编译单元的AST的顶级节点，以及<code>package-info.java</code>（如果存在的话）的顶级节点。</li>
</ol>
</li>
</ol>
<h3 id="10-2-3-注解处理器"><a href="#10-2-3-注解处理器" class="headerlink" title="10.2.3 注解处理器"></a>10.2.3 注解处理器</h3><p>· JDK5后，Java语言提供了对注解的支持。<br>· 注解设计原本与普通java代码一样，在运行期发挥作用。但JDK6中提出并通过提案，设计了一组“插入式注解处理器”的标准API，将处理提前至编译器。<br>· 我们可以将<strong>插入式注解处理器</strong>看作是一组<strong>编译器的插件</strong>，当这些插件工作时，允许读取、修改、添加<strong>抽象语法树中的任意元素</strong>。<br>· 如果这组插件在处理注解期间对树进行过修改，编译器将会回到解析及填充符号表的过程重新处理，直到所有插件没有再对树进行修改为止。每一次循环称为一个<strong>轮次（Round）</strong>。<br>· 有了注解处理器的标准API后，程序员代码才有可能干涉编译器的行为。由于语法树任意元素都能在插件中被访问到，所以通过注解处理器可以实现许多在编码中由人共完成的事情（譬如自动生成getter/setter方法）。</p>
<h3 id="10-2-4-语义分析与字节码生成"><a href="#10-2-4-语义分析与字节码生成" class="headerlink" title="10.2.4 语义分析与字节码生成"></a>10.2.4 语义分析与字节码生成</h3><p>· 经过语法分析后，编译器获得了表示一个结构正确的源程序的抽象语法树。但是，并不能保证源程序的语义是符合逻辑的。<br>· 语义分析要做的事就是对结构正确的源程序进行<strong>上下文性质的相关性检查</strong>，譬如类型检查、控制流检查、数据流检查等。<br>· 我们编码时看到的红线标注，绝大多数是源于语义分析的检查结果——不合逻辑，拒绝编译。<br>· 语义分析过程分为<strong>标注检查</strong>和<strong>数据及控制流分析</strong>两步：</p>
<ol>
<li><p>标注检查<br> · 主要检查内容包括：变量使用前是否声明，变量与赋值间的数据类型是否匹配等。<br> · 还会进行一个<strong>常量折叠</strong>的代码优化，这是Javac编译器对源代码做的极少量优化措施之一。<br> e.g <code>int a = 1  + 2;</code> 优化前抽象语法树上能看到的“1”“2”“+”，优化后折叠为字面量“3”（这个值称为“插入式表达式的值”）<br> · 标注检查步骤在Javac源码中的实现类是<code>com.sun.tools.javac.comp.Attr类</code>和<code>.Check类</code>。</p>
</li>
<li><p>数据及控制流分析<br> · 是对程序上下文逻辑的进一步验证。<br> · 可检验出：局部变量使用前是否有赋值，受查异常是否都被正确处理，方法的每一条路径是否都有返回值等。<br> · <strong>编译期</strong>与<strong>类加载时</strong>的的数据及控制流分析目的基本一致，但是校验范围有所区别。<br> e.g final语义校验：一个只能在编译期而不能在运行期中检查的例子<br> <img src="https://img-blog.csdnimg.cn/20200802145445188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
<ul>
<li>观察这两段代码编译出来的字节码，会发现它们是没有任何一点区别的，每条指令，甚至每个字节都一模一样。</li>
<li>由于第六章中已知，局部变量在常量池中并没有CONSTANT_Fieldref_info的符号引用，自然不可能有<strong>访问标志</strong>，所以有没有final修饰在Class文件中都无法得知。</li>
<li>因此，是否把局部变量声明为final，对运行期都完全没有影响。变量的不变性仅靠Javac在编译期保证。</li>
<li>· 数据及控制流分析的入口是图10-5中过程3.2的flow()方法，具体操作由<code>com.sun.tools.javac.comp.Flow类</code>来完成。</li>
</ul>
<ol start="3">
<li><p>解语法糖<br> ·<mark> 语法糖，也称糖衣语法</mark>，指的是在计算机语法中添加一些语法，这些语法在编译结果和功能上没有任何影响，但能方便程序员使用该语言。<br> · 使用语法糖，能够减少代码量，增加程序可读性，从而减少程序出错机会。<br> · Java相对于JVM上其他的语义来说，属于“低糖语言”，尤其在JDK5之前。<br> · Java中最常见的语法糖包括：泛型、变长参数、自动装箱拆箱等。<br> · JVM运行时并不直接支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为<strong>解语法糖</strong>。<br> · 在Javac的源码中，过程由desugar()方法触发，在<code>com.sun.tools.javac.comp.TransTypes类</code>和<code>.Lower类</code>中完成。</p>
</li>
<li><p>字节码生成<br> · 在Javac的源码中，由<code>com.sun.tools.javac.jvm.Gen类</code>来完成。<br> · 字节码生成过程不仅是把之前阶段生成的信息（语法树、符号表）转化为字节码指令写到磁盘中，编译器还进行了少量代码添加与转换工作。<br> · 例如实例构造器&lt;init&gt;()方法和类构造器&lt;clinit&gt;()方法就是在这个阶段被添加到语法树之中的。</p>
<blockquote>
<p>注：</p>
<ol>
<li>这里的实例构造器并不等同于默认构造函数，如果代码没有提供构造函数，在<strong>填充符号表阶段</strong>，编译器就会添加一个没有参数、可访问性与当前类型一致的默认构造参数。</li>
<li>&lt;init&gt;()和&lt;clinit&gt;()这两个构造器的产生实际上是一种<strong>代码收敛</strong>的过程。<br>· 编译器会把<strong>语句块</strong>（对实例构造器而言是“{}”块，对类构造器而言是“static{}”块）、<strong>变量初始化</strong>（实例变量和类变量）、<strong>调用父类的实例构造器</strong>（&lt;clinit&gt;()方法中无须调用父类的&lt;clinit&gt;()方法，JVM会自动保证父类构造器的正确执行，但在&lt;clinit&gt;()方法中常会生成调用Object的&lt;init&gt;()方法的代码）等操作收敛到&lt;init&gt;()和&lt;clinit&gt;()方法之中。<br>· 并且保证，无论源码顺序如何，都一定按照执行父类的实例构造器、初始化变量、执行语句块的顺序进行。上面所述的动作由<code>Gen::normalizeDefs()</code>方法来实现。</li>
</ol>
</blockquote>
<blockquote>
<p>除此之外，还有其他的代码替换工作用于优化程序某些逻辑的实现方式。<br>如把字符串的加操作替换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK5）的append()操作等。</p>
</blockquote>
<p> · 完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到<code>com.sun.tools.javac.jvm.ClassWriter类</code>手上，由这个类的writeClass()方法输出字节码，生成最终的Class文件。到此，整个编译过程宣告结束。    </p>
</li>
</ol>
<h2 id="10-3-Java语法糖"><a href="#10-3-Java语法糖" class="headerlink" title="10.3 Java语法糖"></a>10.3 Java语法糖</h2><p>语法糖可以看作是前端编译器实现的一些“小把戏”，它可以使得效率提升，但我们也需要了解背后真面目，更好地利用它们。</p>
<h3 id="10-3-1-泛型"><a href="#10-3-1-泛型" class="headerlink" title="10.3.1 泛型"></a>10.3.1 泛型</h3><p>· 泛型本质是<strong>参数类型</strong>或者<strong>参数多态</strong>的应用，即将操作的数据类型指定为方法签名中的一种特殊参数，这种参数能够在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。<br>· 程序员能够针对泛化的数据类型，编写相同的算法。<br>    1. Java与C#泛型</p>
<ul>
<li><p>同年，Java 5.0和C#2.0各自添加了泛型的语法特性。</p>
</li>
<li><p>Java选择的泛型实现方式叫作“<font color = #F9000>类型擦除式泛型</font>”，而C#选择的泛型实现方式是“<font color = #F9000>具现化式泛型</font>”。</p>
</li>
<li><p>C#中的泛型，无论式源码里、编译后的中间语言表示(这时候泛型是一个占位符)里、运行期的CLR里都是切实存在的。例如List&lt;int&gt;与List&lt;string&gt;就是两个不同的类型，它们由系统在运行期生成，有着自己独立的虚方法表和类型数据。</p>
</li>
<li><p>Java中的泛型则不同。它只在源码中存在，在编译后的字节码文件里，全部泛型都被替换为<font color = green>裸类型</font>了，并且在相应地方插入了强制转换类型代码。因此早期Java，ArrayList&lt;Integer&gt;与ArrayList&lt;String&gt;其实是同一个类型。</p>
</li>
<li><p>这带来的不利影响是:<br>   1）<strong>使用效果落后</strong>。Java泛型在编码阶段产生不良影响：<br>   <img src="https://img-blog.csdnimg.cn/20200802145817481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   2）<strong>运行效率落后</strong>。C#引入泛型后，性能比java提高不少。因为在使用平台提供的容器类型时无需拆箱装箱。</p>
</li>
<li><p>唯一的优势是实现这种泛型的影响范围大：擦除式泛型实现几乎只需在Javac上做出改进即可。不需要改动字节码、虚拟机，甚至之前没有使用泛型的库也能直接运行在Java5.0上。</p>
</li>
</ul>
<ol start="2">
<li><p>泛型历史背景<br> · 把Pizza语言的泛型移植到Java语言上，形成了Java5.0的泛型实现。但事实上，Pizza语言中的泛型更接近C#的泛型。只是在移植过程中，受到许多约束。<br> 其中最紧的是由于Java需要完全向后兼容无泛型java，即保证“<font color = #F9000>二进制向后兼容性</font>”（在JDK之前版本编译出的Class文件，必须保证在之后的版本也能够正常运行）。<br> · 为了保证编译出来的Class文件可以在引入泛型之后继续运行，设计思路大体上有两条：<br> 1）需要泛化的类型，以前有的就保持不变，然后<font color = #F9000>平行加入</font>一套泛型化版本的新类型。<br> （e.g 假设：Vector（无泛型）和vector&lt;T&gt;（有泛型））<br> 2）直接把已有的、需要泛型化的类型都<font color = #F9000>原地泛型化</font>。<br> · C#走了第一条路，增加了一组新容器。但由于Java已经面世近10年了，遗留代码量巨大。所以Java选择了第二条路。但其实如果有足够时间好好设计与实现，完全能够做出更好的泛型系统，不至于今天的Valhalla项目还要偿还泛型偷懒的技术债了。</p>
</li>
<li><p>类型擦除<br> · 既要<strong>直接泛型化</strong>已有的类型（ArrayList&lt;T&gt;），又要保证之前用了这种类型（ArrayList）的代码在新版本中依旧可以运行，这就必须让所有泛型化的实例类型（ArrayList&lt;Integer&gt;）全部自动成为这种类型（ArrayList）的<strong>子类型</strong>，否则类型转换不安全。<br> · 所以引入“<font color = green>裸类型</font>”，它应当被视为所有该类型泛型化实例的共同父类型。<br> · 如何实现裸类型？主要有两种设计选择：<br> 1）在<strong>运行期</strong>由JVM自动、真实地生成实例类型（ArrayList&lt;Integer&gt;），并且自动实现从实例类型<strong>派生</strong>自原来类型（ArrayList）的<strong>继承关系</strong>。<br> 2）直接在编译期把实例类型（ArrayList&lt;Integer&gt;）还原为原来类型（ArrayList），只在元素访问、修改时插入一些<strong>强制类型转换和检查命令</strong>。</p>
<p> · Java采用了第二种方式。<br> · e.g 将一段使用泛化类型的代码编译成Class文件，再用字节码反编译工具进行反编译，会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，<strong>泛型类型都变回了裸类型</strong>，只在元素访问时插入了从<code>Object</code>到<code>String</code>的强制转型代码。<br> 泛型擦除前：<br> <img src="https://img-blog.csdnimg.cn/20200802150329568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 泛型擦除后：<br> <img src="https://img-blog.csdnimg.cn/2020080215034940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> · 缺点：<br> 1）目前Java<strong>不支持原生类型的泛型</strong>（ArrayList&lt;int&gt;）。Java解决方案就是都使用封装类型（ArrayList&lt;Integer&gt;）遇到原生类型，自动装箱拆箱。这就导致了许多开销，这也是Valhalla项目重点解决问题之一。</p>
<p> e.g 下图这种情况，一旦把泛型信息擦除后，到要插入强制转型代码的地方就没办法往下做了，因为不支持int、long（原生类型）与Object之间的强制转型。<br> <img src="https://img-blog.csdnimg.cn/2020080215054820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> 2）<strong>运行时</strong>无法取得泛型类型信息，使得代码变得啰嗦。例如<br> 前面图片所示的Java不支持的几种泛型用法，都是由于运行期JVM无法取得泛型类型而导致的。<br> 当我们参数需要取得参数化类型T，但由于不能直接取得，所以不得不加入一个类型参数。</p>
<p> 3）丧失了一些面向对象思维的优雅，带来些模棱两可的情况。<br> 如：函数重载，参数分别为List<String>和List<Integer>，代码拒绝编译。<strong>部分原因是</strong>因为编译后参数擦除，裸类型相同，导致这两个方法的特征签名一模一样。</p>
<p> · 如果添加两个并不需要实际使用到的、不一样的返回值类型，却发现重载成功了，即<font color = green>代码能够编译、执行</font>了。（在Javac中成功，其他版本或者ECJ中可能失败。因为前端编译器在《Java虚拟机规范》中没具体定义，各虚拟机实现不同）<br> · 这<strong>并不是</strong>与<font color = #F9000>Java语言中返回值不参与重载选择的认知违背</font>。<br> 【<font color = #F9000>Java代码层面的方法特征签名：方法名称、参数顺序、参数类型；字节码层面的方法特征签名：还包括返回值及受查异常表</font>】方法重载要求方法具备不同的特征签名，返回值并不包含在方法的特征签名中，所以返回值不参与重载选择。但是在<strong>Class文件格式</strong>之中，只要<strong>描述符</strong>不是完全一致的两个方法就可以共存。<br> · 因此这两个方法加入了不同返回值后，能共存于一个Class文件中。</p>
<p> 由于Java泛型的引入，各种场景下的方法调用有新的需求，如在泛型类中如何获取传入的参数化类型等。<br> · 所以《Java虚拟机规范》做出了相应的修改，引入了诸如Signature、LocalVariableTypeTable等新的属性用来解决参数类型识别问题。<br> · <strong>Signature</strong>：存储一个方法在<strong>字节码层面</strong>的特征签名。这个属性中保存的参数类型是<strong>包括了参数化</strong>类型的信息。<br> · 从Signature属性出现也可知，擦除只是对方法的Code属性中字节码进行擦除，实际上元数据中还是保留了泛型信息。<br> （编码时能通过反射手段获取参数化类型的根本依据）</p>
<ol start="4">
<li><p>值类型与未来的泛型<br>· 实现泛型的方式待定。可能被具现化，也可能继续维持兼容，不过可以选择不被完全擦除，相对完整地记录在Class文件中。<br>· 明确的是，未来Java应该会<strong>提供“值类型”</strong>的语言层面的支持。</p>
<p>· 在C#中，没有int等原生数据类型，开发人员甚至可以自定义自己的值类型，只要继承于ValueType即可。因为ValueType也是统一基类Object的子类，所以不会遇到int不装箱就无法转型为Object的尴尬。<br>· 值类型可以与引用类型一样，有构造函数、方法、属性字段，区别是值类型在赋值的时候是<font color = #F9000>整体赋值</font>，而不是像引用类型那样传递引用。<br>· 值类型的实例很容易实现<font color = #F9000>分配在方法的调用栈上</font>。这样值类型会随着当前方法的退出而自动释放，不会给垃圾收集带来压力。</p>
<p>· 在Valhalla项目中，Java的值类型方案被称为“<font color = #F9000>内联类型</font>”。计划通过关键字inline来定义，在字节码层也有专门的对应操作码（Q开头）来支撑。</p>
</li>
</ol>
</li>
</ol>
<h3 id="10-3-2-自动装箱、拆箱与遍历循环"><a href="#10-3-2-自动装箱、拆箱与遍历循环" class="headerlink" title="10.3.2 自动装箱、拆箱与遍历循环"></a>10.3.2 自动装箱、拆箱与遍历循环</h3><p>· 自动装箱、拆箱与遍历循环（foreach循环）这些语法糖，复杂度和蕴含思想都不及泛型。但这些是Java中使用最多的语法糖。</p>
<p>e.g 自动装箱陷阱：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Integer a &#x3D; 1;</span><br><span class="line">        Integer b &#x3D; 2;</span><br><span class="line">        Integer c &#x3D; 3;</span><br><span class="line">        Integer d &#x3D; 3;</span><br><span class="line">        Integer e &#x3D; 321;</span><br><span class="line">        Integer f &#x3D; 321;</span><br><span class="line">        Long g &#x3D;3L;</span><br><span class="line">        System.out.println(c&#x3D;&#x3D;d);</span><br><span class="line">        System.out.println(e&#x3D;&#x3D;f);</span><br><span class="line">        System.out.println(c&#x3D;&#x3D;(a+b));</span><br><span class="line">        System.out.println(c.equals(a+b));</span><br><span class="line">        System.out.println(g&#x3D;&#x3D;(a+b));</span><br><span class="line">        System.out.println(g.equals(a+b));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>true<br>false<br>true<br>true<br>true<br>false</p>
<p>注：<br>1.包装类的“==”在不遇到算术运算的情况下，不会自动拆箱，默认比较<strong>地址值</strong>；它们的equals()方法不处理数据转型的关系。<br>2.在Java中会有一个Integer缓存池，缓存的大小是：-128~127</p>
<h3 id="10-3-3-条件编译"><a href="#10-3-3-条件编译" class="headerlink" title="10.3.3 条件编译"></a>10.3.3 条件编译</h3><p>· java语言没有使用预处理器来解决<font color = #F9000>编译时的代码依赖问题</font>。而C/C++中使用预处理器指示符（#ifdef）来完成条件编译。<br>因为Java语言天然的编译方式：编译器并非一个个编译Java文件，而是将<font color = #F9000>所有编译单元的语法树顶级节点</font>输入到<font color = #F9000>待处理列表</font>后再进行编译。因此各个文件间可以互相提供符号信息。<br>· 不过Java依旧有方法进行条件编译：使用条件为常量的<strong>if语句</strong>。（不能使用其他条件语句完成条件编译）<br>· Java语言中条件编译的实现，也是一颗<font color = #F9000>语法糖</font>，根据布尔常量值的真假，编译器把分支中不成立的代码块消除掉。这一工作在编译器解除语法糖阶段完成。<br>· 因为使用的if语句，所以只能写在方法体内部，因此只能实现语句<font color = #F9000>基本块（Block）级别</font>的条件编译，没法根据条件，调整整个Java类的结构。</p>
<p><strong>Java程序命名规范</strong>：<br>    - 类（或接口）：符合驼式命名法，首字母大写。<br>    - 方法：符合驼式命名法，首字母小写。<br>    - 字段：<br>    · 类或实例变量。符合驼式命名法，首字母小写。<br>    · 常量。要求全部由大写字母或下划线构成，并且第一个字符不能是下划线。<br>注：驼式命名法，指混合使用大小写字母来分割名字。</p>
<p>总结：<br>· 在前端编译器中，“优化”手段主要用于提升程序的编码效率。之所以把Javac这类将<strong>Java代码</strong>转变为<strong>字节码</strong>的编译器称作“<strong>前端编译器</strong>”，是因为它只完成了从<strong>程序</strong>到<strong>抽象语法树或中间字节码</strong>的生成。<br>· 在此之后，还有一组内嵌于虚拟机内部的“<strong>后端编译器</strong>”来完成代码优化以及从<strong>字节码</strong>生成<strong>本地机器码</strong>的过程。即即时编译器或提前编译器。<br>这个后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标。</p>
]]></content>
      <categories>
        <category>阅读记录</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>前端编译与优化</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入了解Java虚拟机》第十一章</title>
    <url>/2020/08/03/%E3%80%8A%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="第十一章-后端编译与优化"><a href="#第十一章-后端编译与优化" class="headerlink" title="第十一章 后端编译与优化"></a>第十一章 后端编译与优化</h1><p>· 无论是提前编译器抑或即时编译器，都不是Java虚拟机必需的组成部分。但是它却是商业Java虚拟机中的核心。<br>· 2012年的Java世界中，<strong>提前编译器（AOT</strong>，Ahead OfTime）虽然早已有应用，但是<strong>即时编译器（JIT</strong>，Just InTime）才是主流。而这几年，AOT逐渐被主流JDK支持。<br>本章中所提及的都特指HotSpot虚拟机内置的即时编译器。</p>
<h2 id="11-2-即时编译器"><a href="#11-2-即时编译器" class="headerlink" title="11.2 即时编译器"></a>11.2 即时编译器</h2><p>· 目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过<strong>解释器</strong>进行解释执行的。<br>· 当虚拟机发现某个方法或者代码块的运行特别频繁，就会把这些代码认定为“<font color = #F9000>热点代码</font>”。为了提高热点代码执行效率，运行时，虚拟机就会把这些代码编译为本地机器码，并进行代码优化。运行时完成这个任务的后端编译器就称为“<font color = #F9000>即时编译器</font>”。<br>要解决的问题：</p>
<ol>
<li>为何HotSpot虚拟机要使用解释器与即时编译器并存的架构？</li>
<li>为何HotSpot虚拟机要实现两个（或三个）不同的即时编译器？</li>
<li>程序何时使用解释器执行？何时使用编译器执行？</li>
<li>哪些程序代码会被编译为本地代码？如何编译本地代码？</li>
<li>如何从外部观察到即时编译器的编译过程和编译结果？</li>
</ol>
<h3 id="11-2-1-解释器与编译器"><a href="#11-2-1-解释器与编译器" class="headerlink" title="11.2.1 解释器与编译器"></a>11.2.1 解释器与编译器</h3><p>目前主流的商用JVM，内部都同时包含了解释器和编译器。它们各自有各自的优势：</p>
<ul>
<li>当程序需要<strong>快速启动和执行</strong>时，<strong>解释器</strong>可以立即发挥作用；随着时间推移，编译器逐渐发挥作用，把越来越多的代码编译为本地机器代码，获得更高效率。</li>
<li>当程序运行环境中<strong>内存资源限制较大</strong>，可以使用<strong>解释执行</strong>节约内存（如部分嵌入式系统和部分JavaCard应用中只有解释器），反之可以使用编译执行提高效率。</li>
<li>解释器还可以作为<strong>编译器激进优化</strong>时的“逃生门”（情况允许，HotSpot还可能选择<strong>不进行激进优化的客户端编译器</strong>充当“逃生门”）。<br><font color = #F9000>激进优化</font>是根据概率选择一些不能保证所有情况都正确，但大多时候能提升运行速度的手段。<br>如果激进优化不成立，如加载新类，类型继承关系改变、出现“<font color = green>罕见陷阱</font>”可以立即采取<font color = #F9000>逆优化</font>，退回到解释状态运行。<br><img src="https://img-blog.csdnimg.cn/20200803214656578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· HotSpot虚拟机内置两个（或三个）即时编译器，其中两个分别为“<strong>客户端编译器</strong>”（也称C1编译器）和“<strong>服务端编译器</strong>”（也称C2编译器）。第三个<strong>Graal编译器</strong>是JDK10出现的，长期目标是替换C2。<br>· 在分层编译工作模式出现前，HotSpot通常采用<strong>解释器与其中一个编译器搭配</strong>的工作方式。程序使用哪个编译器，只取决于虚拟机运行的模式是客户端还是服务端模式。虚拟机一般根据版本和宿主机硬件性能选择模式，不过也可以通过<font color = #F9000>参数“-client”或“-server”</font>自行设置。<br>· 无论使用哪种编译器，这种搭配使用方式都称为“<strong>混合模式</strong>”。</li>
<li>用户可以使用<font color = #F9000>参数“-Xint”</font>强制使虚拟机运行在“<strong>解释模式</strong>”（Interpreted Mode），这时候编译器完全不介入工作，全部代码由解释方式执行。</li>
<li>用户可以使用<font color = #F9000>参数“-Xcom”</font>强制使虚拟机运行在“<strong>编译模式</strong>”（Compiled Mode），这时候优先<strong>采用编译方式执行</strong>。解释器作为“逃生门”。</li>
</ul>
<p>· 由于JIT编译本地代码需要占用程序运行时间，优化程度越高时间越久；而且想要编译出优化程度高的代码，需要解析器<strong>收集性能监控信息</strong>，这对<strong>解释执行阶段</strong>的速度也有影响。<br>· 为了权衡程序启动响应速度和运行效率，加入了分层编译功能。在JDK7的服务端模式虚拟机中作为默认编译策略被开启。划分编译层次，包括：<br>    - 第0层。纯解释执行。<strong>不开启</strong>性能监控功能（<strong>Profiling</strong>）<br>    - 第1层。使用客户端编译器。简单<strong>稳定优化</strong>，不开启性能监控功能。<br>    - 第2层。使用客户端编译器。仅开启方法及回边次数统计等<strong>有限性能监控功能</strong>。<br>    - 第3层。使用客户端编译器。开启<strong>全部</strong>性能监控，除了2层的信息，还收集分支跳转、虚方法调用版本等全部统计信息。<br>    - 第4层。使用服务端编译器。会启用更多编译<strong>耗时更长的优化</strong>，还会根据监控信息进行些不可靠<strong>激进优化</strong>。<br>以上层次并非固定不变，分层数量可以根据运行参数、版本调整。<br><img src="https://img-blog.csdnimg.cn/20200803220129455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实施分层编译后，解释器、C1、C2编译器就会同时工作。热点代码可能会被多次编译，用<strong>客户端</strong>编译器获取更好的<strong>编译速度</strong>，<strong>服务端</strong>编译器获得更好<strong>编译质量</strong>。解释器执行时无需额外承担收集监控信息任务；在服务端编译器采用复杂优化时，客户端编译器可<strong>先采用简单优化</strong>为它争取更多编译时间。</p>
<h3 id="11-2-2-编译对象与触发条件"><a href="#11-2-2-编译对象与触发条件" class="headerlink" title="11.2.2 编译对象与触发条件"></a>11.2.2 编译对象与触发条件</h3><p>· 被即时编译的目标是“<strong>热点代码</strong>”，包括：</p>
<ol>
<li>被多次调用的方法</li>
<li>被多次执行的循环体<br>· 对于这两种情况，编译的目标对象都是<strong>整个方法体</strong>。<br>· 第一种情况，由于是依靠<strong>方法调用触发</strong>的编译，编译器理应以整个方法作为编译对象。<br>· 对于第二种情况，尽管编译动作是由循环体触发的，热点只是方法的一部分，但编译器依旧要以<strong>整个方法</strong>作为编译对象，只是执行入口会有所不同。编译时会传入执行入口点<font color = #F9000>字节码序号（BCI</font>，Byte Code Index）。<br>· 这种编译方式因为编译发生在方法执行的过程中，因此称为“<font color = #F9000>栈上替换（OSR</font>，OnStack Replacement）。即方法的栈帧还在栈上，方法就被替换了。</li>
</ol>
<p>· <strong>热点探测</strong>：某段代码是不是热点代码，是不是需要触发即时编译。<br>· 目前主流的热点探测判定方式：</p>
<ol>
<li>基于<strong>采样</strong>的热点探测。采用这种方法的虚拟机会<font color = #F9000>周期性检查各个线程的调用栈顶</font>，如果发现某个（某些）方法<font color = #F9000>经常出现在栈顶</font>，就是“<strong>热点方法</strong>”。<br>好处：实现简单高效，很容易获取<font color = #F9000>方法调用关系</font>（<font color = green>将调用堆栈展开即可</font>）。<br>缺点：很难精准确认一个方法的热度，容易因受到<strong>线程阻塞</strong>或别的外界因素的影响而扰乱探测。</li>
<li>基于<strong>计数器</strong>的热点探测。采用这种方法的虚拟机为每个方法（甚至是代码块）<font color = #F9000>建立计数器</font>，当执行次数超过某个<font color = #F9000>阈值</font>，就认为是“<strong>热点方法</strong>”。<br>好处：统计结果更加严谨。<br>缺点：实现麻烦一些，需要为每个方法建立并维护计数器，而且<font color = #F9000>不能直接获取</font>方法的调用关系。</li>
</ol>
<p>· J9用过第一种，HotSpot使用的是第二种。<br>· 为了实现热点计数，HotSpot为每个方法准备了<strong>两类计数器</strong>：<font color = #F9000>方法调用计数器</font>（Invocation Counter）和<mark>回边计数器</mark>（Back Edge Counter，<mark>“回边”指在循环边界往回跳转。也可以说是，在字节码中遇到控制流向后跳转的指令</mark>）。当虚拟机运行参数确定的前提下，这两个计数器都有一个明确的<strong>阈值</strong>，一旦溢出，就会<strong>触发即时编译</strong>。</p>
<p>· <strong>方法调用计数器</strong>：统计方法被调用的次数。默认阈值在<strong>客户端</strong>模式下是1500次，<strong>服务端</strong>模式下是10000次。<br>· 当一个方法被调用时，虚拟机会先检查该方法<font color = #F9000>是否存在被即时编译过的版本</font>，如果存在，则<strong>优先</strong>使用<strong>编译后的本地代码</strong>来执行。如果不存在，则该方法的计数器加一，然后判断<strong>两类计算器</strong>（方法调用计数器和回边计数器）<strong>之和</strong>是否超过<strong>方法调用计数器的阈值</strong>。一旦超过，将会向即时编译器提交一个<font color = #F9000>该方法的代码编译请求</font>。</p>
<p>· 如果没有做过任何设置，<strong>执行引擎</strong>默认<font color = #F9000>不会同步等待编译请求完成</font>，而是继续<strong>进入解释器</strong>，按照<font color = #F9000>解释方式</font>执行字节码，直到<font color = #F9000>提交的请求</font>被JIT编译完成。<strong>当编译完成</strong>，这个方法的调用入口地址就会被系统自动改写成新值，下一次调用该方法时就会使用<font color = #F9000>已编译的版本</font>了。<br><img src="https://img-blog.csdnimg.cn/20200803220338765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· 默认设置下，方法调用计数器统计的并不是<strong>方法被调用的绝对次数</strong>，而是一个<strong>相对的执行频率</strong>，即<strong>一段时间内</strong>方法被调用的次数。<br>· 当超过一定的时间限度，方法的调用次数还没达到阈值，就把该方法的调用计数器减少一半，这个过程被称为<font color = #F9000>方法调用器热度的衰减</font>，而<strong>这段时间</strong>称为此方法统计的<font color = #F9000>半衰周期</font>。<br>· 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可用参数<font color = #F9000>关闭热度衰减</font>，这样只要系统运行<font color = #F9000>时间足够长</font>，程序中大部分都会被编译成本地代码。还可以设置半衰周期时间。</p>
<p>· <strong>回边计数器</strong>：统计一个方法中<font color = #F9000>循环体代码执行的次数</font>（准确说是<font color = #F9000>回边次数</font>，因为有的循环不是回边，比如空循环是自己跳到自己，不算控制流向后跳转，也不会被计数器统计）。<br>· 建立回边计数器统计的目的是为了<font color = green>触发栈上的替换编译</font>。<br>· 当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本。如果有，优先执行它；否则回边计数器值加一，然后判断两类计数器之和是否超过<strong>回边计数器的阈值</strong>。一旦超过，提交一个<font color = #F9000>栈上替换编译请求</font>，并把回边计数器的值降低一些，<font color = green>以便继续在解释器中执行循环</font>，等待编译器输出编译结果。<br><img src="https://img-blog.csdnimg.cn/20200803220439872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· 与方法计数器不同的是，回边计数器没有计数热度衰减的过程。因此该计数器统计的就是该方法循环执行的<strong>绝对次数</strong>。当计数器溢出的时候，方法计数器的值调到<strong>溢出状态</strong>，这样下次进入该方法时直接会执行已编译版本。</p>
<p>· 图11-2和11-3都仅是描述了<strong>客户端</strong>模式虚拟机的<strong>即时编译方式</strong>。对服务端模式虚拟机来说，执行情况更复杂。</p>
<h3 id="11-2-3-编译过程"><a href="#11-2-3-编译过程" class="headerlink" title="11.2.3 编译过程"></a>11.2.3 编译过程</h3><p>· 在默认条件下，无论是方法调用产生的<strong>标准编译请求</strong>，还是<strong>栈上替换编译请求</strong>，虚拟机在未完成编译前，都仍按照解释方式执行代码，而编译动作则在<strong>后台的编译线程</strong>中进行。<br>· 如果设置参数禁止后台编译，到达触发即时编译条件时，执行线程向虚拟机<strong>提交请求后</strong>，会一直<strong>阻塞等待</strong>，直到<strong>编译过程完成后</strong>再开始执行编译器输出的本地代码。<br>· 后台执行编译过程中，服务端和客户端编译器<strong>具体做的事</strong>有差别。<br>· 对于客户端编译器来说，是一个相对简单快速的<font color = #F9000>三段式编译器</font>，主要关注<font color = #F9000>局部性的优化</font>，而放弃了许多耗时较长的全局优化。</p>
<p>· <strong>第一阶段</strong>，一个<strong>平台独立的前端</strong>将字节码构造成一个<font color = #F9000>高级中间代码表示（HIR</font>，即与目标机器指令集无关的中间表示），HIR使用<font color = green>静态单分配（SSA）</font>的形式来表示代码值，这可以使一些在HIR构造之中和之和的优化动作更容易实现。在此之前，编译器已经在字节码上完成部分基础优化，如<strong>方法内联、常量传播</strong>等优化将会在字节码被构造成HIR之前完成。<br>· <strong>第二阶段</strong>，一个平台相关的后端会从HIR中产生<font color = #F9000>低级中间代码表示（LIR</font>，即与目标机器指令集相关的中间表示），在此之前会在HIR上完成另一些优化，如<strong>空值检查消除、范围检查消除</strong>等，以便让HIR达到更高效的代码表示形式。<br>· <strong>最后阶段</strong>，是在平台相关的后端使用<strong>线性扫描算法</strong>在LIR上分配寄存器，并在LIR做<font color = green>窥孔（Peephole）</font>优化，然后产生机器代码。客户端编译器大致执行过程如下：<br><img src="https://img-blog.csdnimg.cn/20200803221915120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>服务端编译器</strong>则是专门面向<strong>服务端典型应用场景</strong>、并为了服务端的性能配置<strong>针对性调整过</strong>、能容忍<strong>很高优化复杂度</strong>的<strong>高级编译器</strong>。</p>
<blockquote>
<p>它会执行大部分<strong>经典的优化</strong>动作，如：无用代码消除（Dead Code Elimination）、循环展开（LoopUnrolling）、循环表达式外提（Loop Expression Hoisting）、消除公共子表达式（Common Subexpression Elimination）、常量传播（Constant Propagation）、基本块重排序（BasicBlock Reordering）等。<br>还会实施一些<strong>与Java语言特性密切相关</strong>的优化技术，如范围检查消除（Range Check Elimination）、空值检查消除（Null Check Elimination，不过并非所有的空值检查消除都是依赖编译器优化的，有一些是代码运行过程中自动优化了）等。另外，还可能根据解释器或客户端编译器提供的性能监控信息，进行一些不稳定的预测性<strong>激进优化</strong>，如守护内联（Guarded Inlining）、分支频率预测（Branch FrequencyPrediction）等。</p>
</blockquote>
<p>· 服务端编译采用的寄存器分配器是一个<font color = green>全局着色分配器</font>，它可以充分利用一些处理器架构（如RISC）的大寄存器集合。以即时编译的标准来看，它无疑是缓慢的，但是编译速度还是远超<font color = green>静态优化编译器</font>，而且因为它能提供<strong>更高质量的代码</strong>，可以大幅度减少本地代码执行时间，从而<strong>抵消掉编译时间较长</strong>的缺点。所以有些非服务端应用也采用服务端模式的HotSpot虚拟机来运行。</p>
<blockquote>
<p><strong>基本块</strong>是指程序按照<strong>控制流</strong>分割出来的<strong>最小代码块</strong>，它的特点是只有唯一的一个入口和唯一的一个出口。只要基本块中第一条指令被执行了，那么基本块内所有指令都会<strong>按照顺序</strong>全部执行一次。<br>例如：图中数据流以虚线表示，控制流以实线表示。说明代码的执行顺序是先调用getX()方法，再调用getY()方法。（表达式：getX()+getY()）<br><img src="https://img-blog.csdnimg.cn/20200803222617737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="11-3-提前编译器"><a href="#11-3-提前编译器" class="headerlink" title="11.3 提前编译器"></a>11.3 提前编译器</h2><p>· 虽然提前编译器只比即时编译器晚几个月，但是由于Java当时的核心优势是平台中立性，这与提前编译理念产生冲突，因此一直沉寂。直到2013年Android使用提前编译的ART(Android Runtime)，直接终结了使用即时编译的Dalvik虚拟机，也震撼到Java世界。<br>· 毕竟有的人只追求更好的执行性能，平台中立性、字节膨胀（提前编译后本地二进制码体积明显变大）、动态扩展（提前编译只允许在封闭程序中，不能在外部加载新的字节码）都可舍弃。问题：AOT真的可以获得更好的执行性能吗？</p>
<h3 id="11-3-1-提前编译的优劣得失"><a href="#11-3-1-提前编译的优劣得失" class="headerlink" title="11.3.1 提前编译的优劣得失"></a>11.3.1 提前编译的优劣得失</h3><p>· 现在提前编译产品有两条明显分支：</p>
<ol>
<li>第一条与c/c++编译器类似，完成在程序运行前先把代码编译成机器码的<strong>静态翻译工作</strong>；</li>
<li>第二条是把<strong>原本JIT在运行时需要做的编译工作</strong>提前做好并且保存，下一次运行到这些代码，就<strong>直接加载</strong>进来使用。</li>
</ol>
<p>对于第一条：<br>· 传统的提前编译应用形式，Android 的ART就是这种形式。可以用运行前的时间来换取更好的性能。Android 7.0起，重启启动了解释执行和即时编译，<font color = #F9000>当空闲时系统再在后台自动进行提前编译</font>。<br>· 采用<strong>即时编译</strong>的最大弱点就是需要<strong>占用程序运行时间和运算资源</strong>。而<strong>提前编译</strong>刚好克制这个弱点。即使现在先进的JIT已经很快，甚至能够容忍相当大的优化复杂度了；即使有分层编译支持，能够用快速、质量低的JIT为高质量的JIT争取更多编译时间，但是，<strong>即时编译消耗的时间（资源）都是原本可用于程序运行的时间（资源）。</strong></p>
<blockquote>
<p>e.g 其中最耗时的优化之一是“<strong>过程间分析优化</strong>”，它需要在全代码范围进行大量工作，来获取诸如某个程序点上某个变量值是否一定为常量、某段代码段是否永不再被调用、在某个点调用的某个虚方法是否只能是单一版本等。<br>目前所见的虚拟机对该优化支持有限，要么借助大规模的<strong>方法内联</strong>，打通方法间的隔阂，以“过程内分析”（只考虑过程内部语句，不考虑过程调用分析）来模拟模拟过程间分析的部分效果；要么借助激进优化。<br>但如果是程序运行前做<strong>静态编译</strong>，这些耗时优化就可以大胆进行了。能够采取许多即时编译不会做的全程序优化措施来获得更好的运行性能。</p>
</blockquote>
<p>对于第二条：<br>· 本质是给<font color = #F9000>即时编译器</font>做缓存加速，去改善：1. Java程序的启动时间；2. 需要预热才能到达最高性能 这两个问题。<br>· 这种提前编译方式称为：<font color = #F9000>动态提前编译，即时编译缓存</font><br>· 目前的java体系中，这条路径已经完全被主流商用JDK支持。真正引起业界广泛关注的是OpenJDK/OracleJDK 9中所带的<code>Jaotc提前编译器</code>，是基于Graal编译器实现的工具。用户能够<strong>针对目标机器，为应用程序进行提前编译</strong>。<br>· 实现困难很多，譬如虚拟机运行时采用了不同的垃圾收集器，这原本就需要即时编译子系统的配合才能正常工作。如果要进行提前编译，就需要把这些配合工作<strong>平移</strong>过去。而且编译后的静态链接库只能支持运行在相同参数的虚拟机上。</p>
<p>· 尽管即时编译在时间、运算资源上的劣势无法忽视，但针对提前编译也有天然优势。</p>
<ol>
<li><font color = green>性能分析制导优化（PGO）</font>。前面提到，解释器或者客户端编译器运行中，会不断收集性能监控信息，譬如某个程序点抽象类的实际类型是什么、条件判断会走哪个分支、循环会进行多少次等，这些数据在<strong>静态分析</strong>时是无法得到的，或者是说只能通过启发性条件去进行猜测。但<strong>动态运行</strong>时却可以看出明显的偏好性。这样就可以将热点代码集中放到一起，集中优化和分配更好资源给它。</li>
<li><strong>激进预测优化</strong>。静态优化必须保证优化前后，<strong>程序外部可见影响</strong>是不变的，不然程序出错优化毫无意义。而提前编译不存在这个问题，如果失败，大不了退回到低<strong>级编译器甚至解释器</strong>上去执行。<br>Java虚拟机中，会通过类继承关系等一系列激进的猜测去做虚拟化，保证大部分有内联价值的虚方法都能内联。<strong>内联</strong>是最基础的一项优化措施。</li>
<li><strong>链接时优化（LTO</strong>，Link-Time Optimization）。Java语言天生是动态链接的，一个个Class文件在运行期被加载进虚拟机内存，然后在即时编译器中产生优化后的本地代码。<br>但如果放到C/C++这样使用提前编译的语言上，譬如C/C++程序要调用某个动态链接库的某方法，会<strong>出现明显边界隔阂，而且很难优化</strong>。因为主程序与动态链接库程序在编译时是完全独立的，编译时间、编译器都可能完全不同。当出现跨链接库边界的调用时，理应做的优化——譬如调用方法内联，执行就会十分困难。</li>
</ol>
<h2 id="11-4-编译器的优化技术"><a href="#11-4-编译器的优化技术" class="headerlink" title="11.4 编译器的优化技术"></a>11.4 编译器的优化技术</h2><h3 id="11-4-1-优化技术概览"><a href="#11-4-1-优化技术概览" class="headerlink" title="11.4.1 优化技术概览"></a>11.4.1 优化技术概览</h3><p><img src="https://img-blog.csdnimg.cn/20200803223143499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>即时编译器</strong>对这些代码优化变换是建立在<strong>代码的中间表示</strong>或者是<strong>机器码</strong>之上的，不是直接在<strong>Java源码</strong>上去做的。以下为了方便理解，写成java源码形式。</p>
<p>· 第一步<strong>方法内联</strong>：主要目的一个是<strong>去除方法调用的成本</strong>；一个是为其他优化<strong>建立良好基础</strong>。方法内联膨胀后，可以便于在更大范围上进行后续优化手段。一般用于靠前的优化。<br><img src="https://img-blog.csdnimg.cn/20200803223227541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>·  第二步冗余访问消除：<br><img src="https://img-blog.csdnimg.cn/20200803223244102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>假设其中的“do stuff”所代表的操作没有改变b.value的值，那么可以把“z=b.value”替换为“z=y”。这样就能不再去访问对象b的局部变量了。把b.value看成一个表达式，这项优化就是一种<strong>公共子表达式消除</strong>。</p>
<p>· 第三步<strong>复写传播</strong>：依旧如上个例子，该段逻辑没必要使用额外的z变量，我们可以用y代替z。<br><img src="https://img-blog.csdnimg.cn/20200803223340221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>· 第四步<strong>无用代码消除</strong>：无用代码指永不会执行的代码或者完全没有意义的代码。比如经过第三步，“y=y”是毫无意义的，会将其删除。<br><img src="https://img-blog.csdnimg.cn/20200803223403622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="11-4-2-方法内联"><a href="#11-4-2-方法内联" class="headerlink" title="11.4.2 方法内联"></a>11.4.2 方法内联</h3><pre><code>最重要的优化技术（之一）。</code></pre><p>· <strong>没有内联，多数其他优化都无法有效进行。</strong>譬如下面的例子，两个方法不内联，后续就无法发现“Dead Code”无用代码的存在。分开来看，两个方法中的操作可能都有意义。<br><img src="https://img-blog.csdnimg.cn/20200803223542175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>· 方法内联的优化行为，就是把目标方法的代码原封不动地“复制”到发起调用的方法中，避免发生真实的方法调用而已。</p>
<p><strong>面临问题</strong>：<br>· 如果不是即时编译器做了特殊努力，大部分Java方法都没有办法实现内联。理由：只有使用<strong>invokespecial指令</strong>调用的<code>私有方法</code>、<code>实例构造器</code>、<code>父类方法</code>和使用<strong>invokestatic指令</strong>调用的<code>静态方法</code>，还有被final修饰的方法（虽然使用<strong>invokevirtual指令</strong>调用，但也是非虚方法）才会<font color = #F9000>在编译期</font>进行解析。其他的java方法调用必须在运行时进行方法接收者的多态选择。简而言之，Java语言中<font color = #F9000>默认的实例方法是虚方法</font>。<br>· 对于一个虚方法，编译器<strong>静态做内联</strong>时候很难<strong>确定应该使用的</strong>方法版本。<br>如11-7中b.get()直接内联为b.value为例，如果不依赖上下文，无法确定b的实际类型是什么。<br>再如一个继承了父类ParentB的子类SubB，SubB中重写了父类的get()方法，那么b.get()执行哪个版本，需要根据<font color = #F9000>实际类型动态分派</font>，而实际类型需要实际运行到这行代码才能确定，编译器在编译时很难得到准确结论。<br>· 更糟糕的是，Java提倡面向对象的编程，而java对象默认方法是虚方法。虚方法和内联的矛盾上述可知。C/C++中默认为非虚方法，需要用到<strong>多态</strong>时采用的是用virtual关键字修饰。但Java采用虚拟机来解决问题。</p>
<p><strong>解决问题</strong>：<br>· JVM首先引入了<strong>类型继承关系分析（CHA</strong>，Class Hierarchy Analysis），这是种<strong>全应用程序范围内</strong>的<strong>类型分析</strong>技术，用于确定已加载的类中，某个接口是否有多于1种的实现、某个类是否有子类、某个子类是否覆盖了父类的某个虚方法等信息。<br>· 这样，编译器进行内联时会根据不同情况采取不同的处理：如果是<strong>非虚方法</strong>，直接进行内联；如果是<strong>虚方法</strong>，向CHA查询此方法的当前程序状态下是否有多个版本可供选择。<br>· 如果只有一个，直接假设“应用程序全貌就是现在运行的样子”进行内联，称为<strong>守护内联</strong>。不过因为Java程序是动态连接的，可能之后又加载到新的类型，改变了CHA结论。因此这种内联是<strong>激进优化</strong>。<br>· 如果检测出多版本的目标方法可供选择，那即时编译器会进行最一次努力，使用<font color = green>内联缓存</font>的方式缩减方法调用的开销。这种状态下方法调用是真正发生了的，但比起直接查虚方法表还是快一些。<font color = green>内联缓存</font>是建立在目标方法正常<strong>入口之前</strong>的缓存。<br>· 内联缓存的工作原理大致为：在未发生方法调用前，内联缓存为空。当发生第一次调用后，缓存记录下<strong>方法接收者的版本</strong>信息，并且每次进行方法调用时都比较接受者版本。<br>· 如果以后进来的每次调用的<strong>方法接收者版本</strong>都是一样的，那么这时它就是一种<strong>单态内联缓存</strong>。通过该缓存来调用，比用不内联的非虚方法调用，仅多了<strong>一次类型判断的开销</strong>而已。<br>· 如果真的出现方法接收者不一致情况，说明程序用到了<strong>虚方法的多态特性</strong>，这时候会退化成<strong>超多态内联缓存</strong>。其开销相当于<strong>真正查找虚方法表</strong>来进行方法分派。<br>· 所以说，多数情况下Java虚拟机进行的<strong>方法内联</strong>都是一种<strong>激进优化</strong>。</p>
<h3 id="11-4-3-逃逸分析"><a href="#11-4-3-逃逸分析" class="headerlink" title="11.4.3 逃逸分析"></a>11.4.3 逃逸分析</h3><pre><code>**最前沿**的优化技术之一。</code></pre><p>· 逃逸分析和CHA一样，是为其他的优化措施提供依据的<strong>分析技术</strong>。<br>· 逃逸分析的基本原理：分析<strong>对象动态作用域</strong>，当一个<strong>对象</strong>在方法里被定义后，如果被外部方法调用，例如作为参数传到别的方法中，称为“<strong>方法逃逸</strong>”；被外部线程访问到，譬如赋值给其他线程中访问的实例变量，这种称为“<strong>线程逃逸</strong>”。<br>· 从不逃逸、方法逃逸、线程逃逸，称为“对象由低到高的<strong>不同逃逸程度</strong>”。<br>· 如果能证明一个对象不会逃逸到方法或线程外，或者逃逸程度比较低（不逃逸出线程），则可能为这个<strong>对象实例</strong>采取<strong>不同程度的优化</strong>，如：<br>    -  <font color = #F9000>栈上分配</font>：（复杂度太高，HotSPot还没有使用）JVM中，在Java堆上分配<strong>创建对象的内存空间</strong>。Java堆中的对象对于各个线程都是共享可见的。只要持有这个对象的引用，就能访问到对象数据。<br>    如果确定对象<strong>不会逃出线程</strong>，可以让该对象在栈上分配内存，对象所占空间随栈帧出栈而销毁。这样就能减轻垃圾收集子系统的压力。</p>
<pre><code>- &lt;font color = #F9000&gt;标量替换&lt;/font&gt;：如果一个数据无法再继续分解了，就称为**标量**，反之，称为**聚合量**。JVM中的原始数据类型（int、reference等）都是标量。Java对象就是典型聚合量。把一个对象拆散，将其用到的成员变量恢复为原始类型来访问，就是**标量替换**。
&amp;emsp;如果逃逸分析证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行时可能不会创建这个对象，而是改为直接创建若干被这个方法使用的**成员变量**来代替。
&amp;emsp;对象拆分后，对象的成员变量能在**栈上分配读写**外（栈上存储数据，很大机会被虚拟机分配到物理机的高速寄存器中存储），还可以为后续优化创造条件。
&amp;emsp;标量替换可以视为栈上分配一特例，实现更简单（不用考虑整个对象完整结构的分配），但是不允许对象逃逸出方法范围内。

- &lt;font color = #F9000&gt;同步消除&lt;/font&gt;：线程同步是个耗时工作。如果逃逸分析能确定一个变量不会逃逸出线程，就能把对这个变量实施的同步措施消除掉。</code></pre><p>· 逃逸分析技术不成熟，HotSpot才开始支持初步的逃逸分析。因为计算成本非常高，甚至不能保证分析带来的性能能够大于计算成本消耗。<br>· C/C++中，原生支持栈上分配（只要不使用new），C#支持值类型，很自然可做到标量替换（并不会对引用类型做这种优化）。灵活运用栈内存方面，Java是处于弱项。现在正在设计inline关键字用于定义Java内联类型，与C#支持值类型功能相对标。</p>
<h3 id="11-4-4-公共子表达式消除"><a href="#11-4-4-公共子表达式消除" class="headerlink" title="11.4.4 公共子表达式消除"></a>11.4.4 公共子表达式消除</h3><pre><code>**语言无关**的**经典**优化技术之一。</code></pre><p>· 一个表达式E之前已经被计算过了，并且从计算到现在E中所有值没有变化，那直接用之前结果代替E。<br>· 如果这种优化仅限程序基本块内，便称为<strong>局部公共子表达式消除</strong>；如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除。<br>· 编译器还可能（取决于哪种虚拟机的编译器，以及具体的上下文而定）进行另一种优化——<strong>代数化简</strong>。</p>
<h3 id="11-4-5-数组边界检查消除"><a href="#11-4-5-数组边界检查消除" class="headerlink" title="11.4.5 数组边界检查消除"></a>11.4.5 数组边界检查消除</h3><pre><code>**语言相关**的**经典**优化技术之一。</code></pre><p>· Java语言是一门动态安全语言，不像C/C++对数组指针操作实质是<strong>裸指针操作</strong>，Java操作前会自动进行上下界范围检查，这虽然安全，但是代码量大，也是一种性能负担。<br>· 综合考虑后，只要在<strong>编译期</strong>根据<strong>数据流分析</strong>来确定数组长度的值，并判断要访问的数组下标没越界，那执行的时候就不需要判断了。如果是循环中，只要编译器通过数据流分析，判断了循环变量的取值范围在数组长度内，在循环中就能把整个数组上下界检查消除。</p>
<p>· 虽然大量的安全检查使编写Java程序比编写C和C++程序容易了很多，但也导致Java比C和C++要做更多的事情（导致一些隐式开销）。<br>· 为了消除这些隐式开销，除了如数组边界检查优化这种尽可能<strong>把运行期提前到编译期完成</strong>的思路外，还可以避开它——“<strong>隐式异常处理</strong>”，Java中<strong>空指针检查</strong>和算术运算中<strong>除数为零</strong>的检查都采用了这种方案。抛出异常，进入异常处理器的过程涉及进程从用户态转到内核态中处理的过程，<strong>结束后会再回到用户态</strong>，速度会比一次判断检查慢得多。当抛出异常次数少的情况，优化比较合理。</p>
<p>与<strong>语言相关</strong>的其他<strong>消除操作</strong>还有不少，如自动装箱消除、安全点消除、消除反射等。</p>
<p>· Graal虚拟机以及Graal编译器仍在实验室中尚未商用，但未来有望代替或成为HotSpot下一代技术基础。<br>· Graal编译器最终目标是成为一款高编译效率、高输出质量、支持提前编译和即时编译，同时支持应用于包括HotSpot在内的不同虚拟机的编译器。<br>· JDK 9时发布的<font color = #F9000>Java虚拟机编译器接口（JVMCI</font>，Java-Level JVMCompiler Interface）使Graal可以从HotSpot的代码中分离出来。<br>· <font color = #F9000>JVMCI</font>主要提供如下三种<font color = #F9000>功能</font>：</p>
<ol>
<li><strong>响应</strong>HotSpot的编译请求，并将该<strong>请求分发</strong>给Java实现的<strong>即时编译器</strong>。</li>
<li><strong>允许编译器访问</strong>HotSpot中与即时编译相关的<strong>数据结构</strong>，包括类、字段、方法及其性能监控数据等。并<strong>提供</strong>一组这些数据结构在Java语言层面的<strong>抽象表示</strong>。</li>
<li>提供HotSpot代码缓存的<strong>Java端抽象表示</strong>，允许编译器<strong>部署编译</strong>完成的机器码。</li>
</ol>
<p>· <strong>综合利用</strong>上述三项功能，我们就可以把一个虚拟机外的即时编译器集成到HotSpot中，<strong>响应</strong>HotSpot发出的最顶层的编译请求，并将编译后的二进制码<strong>部署</strong>到HotSpot的代码缓存中。<br>· <strong>单独使用</strong>上述第三项功能，又可以绕开HotSpot的即时编译系统，让该编译器直接为应用的类库编译出机器码，该编译器当作一个<strong>提前编译器</strong>去使用（如Jaotc）。<br>· 即时编译器：输入要编译的方法的字节码；输出与方法对应的二进制机器码。<br>· JVMCI编译器接口的输入除了字节码外，HotSpot还会向编译器提供各种该方法的相关信息，譬如局部变量表中变量槽的个数、操作数栈的最大深度，收集到的统计信息等。</p>
]]></content>
      <categories>
        <category>阅读记录</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>后端编译与优化</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入了解Java虚拟机》第四章</title>
    <url>/2020/07/17/%E3%80%8A%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="第四章-虚拟机工具"><a href="#第四章-虚拟机工具" class="headerlink" title="第四章 虚拟机工具"></a>第四章 虚拟机工具</h1><h2 id="基础故障处理工具"><a href="#基础故障处理工具" class="headerlink" title="基础故障处理工具"></a>基础故障处理工具</h2><p>jps：虚拟机进程状况工具<br>jstat：虚拟机统计信息监视工具<br>jinfo：Java配置信息工具<br>jmap：Java内存映像工具<br>jhat：虚拟机堆转储快照分析工具<br>jstack：Java堆栈跟踪工具</p>
<h2 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h2><p>JHSDB：基于服务性代理的调试工具<br>JConsole：Java监视与管理控制台<br>VisualVM：多合-故障处理工具<br>Java Mission Control：可持续在线的监控工具</p>
<h2 id="HotSpot虚拟机插件及工具"><a href="#HotSpot虚拟机插件及工具" class="headerlink" title="HotSpot虚拟机插件及工具"></a>HotSpot虚拟机插件及工具</h2><p>HSDIS：JIT生成代码反汇编</p>
]]></content>
      <categories>
        <category>阅读记录</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>虚拟机工具</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解Java虚拟机》第三章</title>
    <url>/2020/07/15/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h1><p><img src="https://img-blog.csdnimg.cn/20200715232257761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="如何判断对象已死？"><a href="#如何判断对象已死？" class="headerlink" title="如何判断对象已死？"></a>如何判断对象已死？</h2><p><strong>·</strong>引用计数算法：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器加一；引用失效时，计数器减一；为0的对象不可再被使用。会出现对象间循环调用问题。<br><strong>·</strong>可达性分析方法：</p>
<ol>
<li>Java的内存管理子系统，是通过它来判断对象是否存活的。</li>
<li>基本思路：一系列称为GC Root的根对象作为起始节点集，根据引用关系向下搜索（引用链），如果对象不可达，就判断为不能再用对象。</li>
<li>可作为GC Root的对象：1.栈帧中的本地变量表中引用的对象2.字符串常量池里的引用等<br>主要在全局性引用（常量或类静态属性）和执行上下文（栈帧中的本地变量表）中<br><font color = green>判断对象有没有在使用，而使用只能发生在运行时，运行的基本单位是线程，所以GC Root两个来源：一是线程共享的元数据，在方法区或者堆中的字符串常量池；二是线程启动以来的方法调用栈。</font><br>根据用户选择的垃圾收集器和回收的区域不同，也可以有其他对象临时加入。比如局部回收时候，一个区域可能调用另一个区域的对象引用。</li>
</ol>
<ul>
<li>引用：<br>强引用：赋值，将一个内存地址赋给另一块，关系在，GC就不会收到被引用对象<br>软引用：描述有些用，但非必须对象。在内存溢出发生前，会把这些对象列入范围进行第二次回收，但如果这次回收后依旧没有足够内存，才抛出异常<br>弱引用：非必须对象。被弱引用关联的对象只能活到下一次垃圾回收<br>虚引用：无法通过虚引用获取对象实例，只是为了在这个对象被回收前收到一个通知</li>
</ul>
<ol start="4">
<li>判断不可达也不是非死不可，还可以有缓刑。死亡前会经过至少两次的标记过程：如果判断为不可达，对象被标记一次，之后VM再进行一次筛选，<strong>如果对象覆盖finalize()方法，并且之前没有被调用过finalize()方法</strong>，那么虚拟机判断“有必要执行”，这个对象被放入F-Queue队列中，通过VM自动建立的线程去执行它们的该方法，不承诺等待运行结束，只是给它们一个机会。稍后收集器对队列进行二次标记，如果有的成果自救，那么移除“即将回收”集合，反之，就被真正回收。</li>
</ol>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><ol>
<li>不是所有收集器都能完整实现垃圾收集（ZGC收集器就不支持类卸载）</li>
<li>方法区的回收主要是废弃的常量和对不再使用的类型的卸载。</li>
<li>判断废弃的常量：没有任何对象引用该常量，VM中也没有地方引用它。内存回收时，GC判断确有必要的话就会把它清除</li>
<li>判断类型不再使用，满足以下三点：</li>
<li>java堆中不存在它和它的派生子类的实例</li>
<li>加载该类的类加载器已被回收<br>3。该类对应的java.lang.Class对象没有在任何地方被引用</li>
</ol>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h4 id="分代收集三大假说"><a href="#分代收集三大假说" class="headerlink" title="分代收集三大假说"></a>分代收集三大假说</h4><ol>
<li>弱分代假说：绝大多数对象朝生夕灭</li>
<li>强分代假说：熬过越多次垃圾收集，越难消亡</li>
<li>跨代引用假说：新生代和老年代间的跨代引用占极少数</li>
</ol>
<h4 id="垃圾收集算法-1"><a href="#垃圾收集算法-1" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ol>
<li>标记-清除算法：<br>最基础的GC算法。首先标记出想要回收的对象，接着统一进行清除。也可以标记存后对象，回收未标记对象。</li>
<li>标记-复制算法：<br>“半区复制”：将内存分为两部分（1：1），每次只使用其中一块。用完一块，就将存后的对象复制到另一块上，清理掉这一块内存空间。缺点是如果对象有很多存活，那复制开销很大。所以多用于新生代收集。但是浪费比较多。<br>“Appel式回收”：将新生代分为一块较大的Eden空间和两块较小的Survivor空间（8：1：1），每次只使用Eden和一块Survivor空间，用完后复制到另一块Survivor空间上。再将这两块空间清除。当Survivor不够存放存活对象，就要依赖老年代进行分配担保。</li>
<li>标记-整理算法：<br>针对老年代对象的死· 亡特征。与复制算法相似，区别是先让所有存活的对象都向内存一端移动，再清理掉后面的内存空间。</li>
</ol>
<ul>
<li>从垃圾收集的停顿时间来看，不移动对象停顿时间更短甚至没有。但内存分配时更复杂。内存分配时更复杂。<br>从整个程序的吞吐量来看，移动对象更划算。但内存回收时更复杂。</li>
<li>CMS使用的是标记 -清除算法，直到内存碎片过多，进行一次标记-整理算法。</li>
</ul>
<h4 id="Hotspot算法具体实现"><a href="#Hotspot算法具体实现" class="headerlink" title="Hotspot算法具体实现"></a>Hotspot算法具体实现</h4><ul>
<li>查找引用链已经可以并行，但是根节点枚举依旧需要停顿。</li>
<li>不需要遍历所有根节点的位置，VM就可以得到哪些地方存放着对象引用。HotSpot使用一组OopMap的数据结构来达到这个目的。在类加载动作完成后，Hotspot会把对象内什么偏移量上是什么类型的数据计算出来，即时编译中，也会记录栈和寄存器内哪些位置是引用。当GC扫描时能够直接获得这些信息。</li>
<li>只有当程序进行方法调用、循环跳转、异常跳转等长时间执行的地方<font color = #F9000>（安全点）</font>才能进行垃圾收集，和记录OopMap。</li>
<li>让GC发生时，所有线程（不包括JNI调用的）跑到最近的安全点停顿下来，可采用抢先式中断（GC发生时，系统把线程全部中断，不在安全点的就继续跑）和主动式中断（设置标志位，轮询方式。标志位在安全点和所有创建对象和其他需要在java堆分配内存的地方。避免内存不足）。</li>
<li>由于当程序不执行的时候，不能响应中断，无法走到安全点。所以引入<font color = #F9000>安全区域</font>（引用关系不会发生变化的区域）来解决。离开安全区域前会检查是否完成枚举，没有则等待。</li>
</ul>
<h4 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h4><ul>
<li>记忆集是一种记录<font color = #F9000>跨代指针</font>（从非收集区域指向收集区域）的抽象数据结构</li>
<li>有三种记录精度：<br>  1.字节精度：精确到一个机器字长（处理器寻址位数，如32/64位），该字包含跨代指针<br>  2.对象精度：该对象含有跨代指针<br>  3.卡精度：一块内存区域内有对象含有跨代指针</li>
<li><font color = #F9000>卡精度</font>是用“卡表”形式去实现的记忆集。<font color = #F9000>卡表</font>在HotSpot虚拟机中是一个字节数组。（记录“我指向谁”）每个元素对应着标识内存区域中的特定大小的一块内存块，叫<font color = #F9000>卡页</font>。只要卡页中有一个跨代指针，那数组元素对应值为1，称为“<font color = #F9000>元素变脏</font>”。（HotSpot中使用的卡页是2的9次幂，即512字节）</li>
<li>所以发生GC时，可以从卡表找到含义跨代指针的卡页，加入GC Root一起扫描。</li>
</ul>
<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>如何在有对象产生跨代指针（对象赋值那一刻）导致元素变脏时维护卡表？HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的。<br>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在赋值时候产生环形通知，供程序执行额外动作。赋值前的部分的写屏障叫“写前屏障”，之后叫“写后屏障”。在G1出现前，GC都使用的是写后屏障。<br>写屏障通常用于在运行的时候记录相关指针。在只回收堆中部分区域时，所有从其他区域指向该回收区域的指针都将被写屏障捕获，这些指针会在垃圾回收的时候作为标记开始的根。<br>缺点：</p>
<ol>
<li>在写屏障中增加更新列表的操作，会产生一定开销。</li>
<li>伪共享问题：不同线程更新对象处于一个缓存行，就会彼此影响而导致性能降低（例如一个卡表的元素共享一个缓存行，在对这些元素里的不同对象赋值写屏障时候，就会无效化或者同步）<br>JDK7后可以开启卡表更新的条件判断（检查卡表标记）来避免，但会增大开销。</li>
</ol>
<h4 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h4><p>GC Roots枚举过程在OopMap等一系列优化下，已经可以做到停顿时间短且基本固定，但从根节点向下遍历对象图，这一步的停顿时间与堆容量成正比。<br>为什么必须在一个能保证一致性的快照上才能进行对象图遍历？<br>采用三色标记（黑：安全存活；白：未访问；灰：访问过，但该对象至少存在一个引用没有被扫描过）如果用户线程和收集器并发工作，在扫描过程中用户线程也在改变引用关系，有的甚至会导致原本不该被回收的对象被回收。这显然不可以。</p>
<blockquote>
<p>“对象消失”必须同时满足两个条件：</p>
<ol>
<li>赋值器插入了至少1条从黒对象到白对象的新引用</li>
<li>赋值器删除了全部从灰色对象到该白对象的引用</li>
</ol>
</blockquote>
<p>解决方法：破坏其中一个条件</p>
<ol>
<li><strong>增量更新：</strong> 当插入新引用时，记录下来。并发扫描结束后，再将记录的引用关系中的黑对象为根，重新扫描一次。</li>
<li><span id=SATB><strong>原始快照：</strong></span> 灰色对象要删除指向白色对象的引用关系时，把这删除的引用记录下来。并发扫描结束后，再将记录的引用关系中的灰色对象为根，重新扫描一次。<br>（1，2中的记录的插入和删除，都是通过写屏障实现的）</li>
</ol>
<p>CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现。</p>
<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><p><img src="https://img-blog.csdnimg.cn/20200716105910550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>并行(Parallel)</strong> :多条垃圾收集器线程在同一时间段协同工作，用户线程在等待</p>
<p><strong>并发(Concurrent)</strong> : 垃圾收集器线程和用户线程同一时间都在运行。垃圾收集器线程占用了一部分系统资源，所以程序的处理的吞吐量受到一定影响。</p>
</blockquote>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>特点：</p>
<ol>
<li><strong>单线程</strong>。进行GC时，必须暂停其他所有工作进程，STW（Stop the world）</li>
<li>标记-复制算法。是新生代收集器里额外<font color=#9000 >内存资源</font>里面最小的，目前还是HotSpot运行在客户端模式下默认新生代收集器</li>
</ol>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><ol>
<li>实质上是Serial的<strong>多线程</strong>版本，支持多线程<strong>并行</strong>收集。控制参数、收集算法、回收策略等与Serial完全一致</li>
<li>多运行在服务端模式下。由于CMS目前只能与Serial和ParNew GC配合工作，所以是JDK7之前首选的新生代收集器。JDK9开始，官方希望面向全堆的G1收集器能逐渐取代服务端模式下的ParNew加CMS的之前默认组合。</li>
<li>最后ParNew相当于被合并到CMS中作为处理新生代的部分，PerNew收集器基本退出历史舞台。</li>
</ol>
<h3 id="Parllel-Scavenge收集器"><a href="#Parllel-Scavenge收集器" class="headerlink" title="Parllel Scavenge收集器"></a>Parllel Scavenge收集器</h3><p>多线程并行收集，新生代GC，基于标记-复制算法。看上去与ParNew很相似。不同之处在于：</p>
<ol>
<li>它目标是达成一个可控制的吞吐量。高吞吐量保证高效利用处理器资源。也叫做“吞吐量优先收集器”</li>
<li>Parllel Scavenge收集器有一个自动调优参数，开启后虚拟机可以自动调节参数，把内存管理进行调优。这种方式叫做垃圾收集的自适应调节策略。<br>主要适用于在后台运算而不需要太多交互的工作</li>
</ol>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>特点：</p>
<ol>
<li>是Serial收集器的老年代版本，单线程</li>
<li>标记-整理算法<br>主要是供客户端模式下的HotSpot虚拟机使用<br>在服务端模式下：JDK5及其之前，与Parallel Scavenge收集器搭配使用（Parallel Scavenge架构本身含有PS MarkSweep收集器，与Serial Old实现几乎一样）；作为CMS内存分配失败后的后备方案，在并发收集发生Concurrent Mode Failure时使用</li>
</ol>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>是Paralle Scavenge的老年代版本，多线程并发收集，基于标记-整理算法。在JDK6之前，Paralle Scavenge只能搭配Serial Old，不能发挥出最大的吞吐量最大化效果。<br>在注重吞吐量或者处理器资源比较稀缺的场合适用。</p>
<h3 id="CMS收集器（Concurrent-Mark-Sweep）"><a href="#CMS收集器（Concurrent-Mark-Sweep）" class="headerlink" title="CMS收集器（Concurrent Mark Sweep）"></a>CMS收集器（Concurrent Mark Sweep）</h3><p>· 老年代收集器，基于标记-清除算法。第一款真正并行收集的收集器。<br>· 目标：获取最短回收停顿时间，使用户有良好交互体验。<br>· 主要应用于B/S系统服务端。JDK9开始，沦落为不推荐使用，未来可能会被废弃，由G1取代。但由于CMS与Hotspot有千丝万缕关系，因此，规划GDK10时，提出了“统一垃圾收集器接口”，将内存回收的行为与实现职责分离，而收集器都重构成基于这套接口的实现。这样日后更换收集器风险可控。<br>· 运行过程：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除<br>初始标记只是简单标记与GC Roots 直接关联的对象，速度很快，需要STW。并发标记是开始遍历对象图，这个过程是与用户线程并发运行的，时间较长。重新标记是为了修正并发标记中导致标记产生变动的那部分标记记录（基于增量更新方法），需要STW，时间比初始标记稍长。并发清除阶段，并发清除掉已死亡对象。<br>· 缺点：</li>
<li>对处理器资源很敏感。并发阶段会与用户进程共享处理器资源，占用部分线程，降低吞吐量。CMS默认回收线程是（处理器核心数量+3）/4，所以当处理器核心数量4个或以上时，线程数降低，影响回收效率。但如果小于4个，又会对应用程序受到影响。<br>采用了“增量式并发收集器 i-CMS”方式，即在并发标记和清理时，垃圾收集器线程和用户线程改为交替并发运行。但效果不好，JDK9后废弃。</li>
<li>CMS无法处理“浮动垃圾”，导致出现“Concurrent Model Failure”失败导致完全STW的Full GC产生。<br>浮动垃圾是指：在并行标记和清理时，由于用户进程还在推进，可能会在已经标记完之后产生新的垃圾对象，那么这些对象只能留到下次垃圾收集时回收。<br>也正是由于在并行标记和清理时，由于用户进程还在推进，所以不能等到老年代已经满了再开始收集，垃圾收集必须要预留一些内存空间。JDK6默认启动GC阈值92%。<br>但是阈值设的太高又容易出现内存分配时空间不足。出现“并发失败”（Concurrent Model Failure）。这时候CMS只能冻结用户线程的执行，临时启用Serial Old收集器来重新完成老年代的垃圾收集。</li>
<li>标记-清除算法自带的缺点——收集结束会产生大量空间碎片。当碎片过多导致找不到一个连续大的内存空间来分配当前对象时，又会触发Full GC。<br>解决：1.（JDK9开始废弃）设置了一个参数，用于不得不开启Full GC时，开启内存碎片整合，移动存活对象。该过程无法并发，停顿时间变长。2. （JDK9也开始废弃）又设置了一个参数，要求CMS在执行若干次的不整理空间碎片的Full GC后，下一次进行碎片整理的Full GC（解决1中是每次进入Full GC就先整理一次）</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>· 开创了收集器面向局部收集的设计思路和基于Region的内存布局模式。<br>· 目标是希望能建立起“停顿模型”，支持指定一个长度为M毫秒的片段内，停顿时间不超过n毫秒。并且希望在延迟可控的情况下尽可能提高吞吐量。<br>· 主要面向服务端应用的垃圾收集器。希望成为CMS的“替代者”<br>· G1不分代，只是保留了代的概念，由一系列不必连续的区域组成。堆内分为大小相同的独立区域（Region），每个Region根据需要扮演新生代的Eden、Survivor空间，或者老年代空间。Region中还有一类Humongous区域（G1多数行为把它当作老年代的一部分），专门存储大对象（大小超过Region一半的对象），如果大对象过大，也可以存放在连续的N个Humongous区域中。<br>· G1可在堆内任意部分组成回收集（CSet）。哪块内存存放垃圾多，优先回收，即Mixed GC模式。每次收集Region大小的整数倍，避免Full GC从而实现停顿时间可控。<br>· 实现的困难：</p>
<ol>
<li>跨Region引用对象：我们知道使用记忆集可以避免全堆作为GC Roots扫描，但是G1上更为复杂。因为有许多Region，每个Region都维护一个“双向卡表”(本质为哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号)，（<font color=green >？Key中记录谁指向我，Value记录我指向谁</font>）里面除了记录了原普通卡表的“我指向谁”，还有“谁指向我”。内存负担很大，需要耗费Java堆容量的10%~20%的额外内存来维护工作。</li>
<li>并发标记阶段需要保证不能破坏原本对象图结构。G1采用的是“<a href="#SATB">原始快照（SATB）算法</a>“保证的。G1通过写前屏障，在引用更新之前，把要删除的引用存到一个log buffer中，在最终标记时，扫描SATB，修正SATB的误差。</li>
</ol>
<blockquote>
<p>G1收集器写屏障时采用双重过滤来减轻回收器负担：</p>
<ol>
<li>过滤掉同一个Region内部引用；</li>
<li>过滤掉空引用</li>
</ol>
</blockquote>
<blockquote>
<p>G1的写屏障采用一种两级的log buffer结构：</p>
<ol>
<li>global set of filled buffer：全局的，全部线程共享。存放了满的log buffer</li>
<li>thread log buffer：每个线程把写屏障的记录都存到自己的log buffer中。存满了就放到global set of filled buffer里，然后重新申请一个 log buffer<br>Marking bitmap是一种数据结构，其中每一个bit是代表一个可以分配给对象的起始地址。<br><img src="https://img-blog.csdnimg.cn/20200716170224249.png" alt="在这里插入图片描述"><br>绿色的块代表该地址的对象是存活的，白色代表是垃圾对象。</li>
</ol>
</blockquote>
<blockquote>
<p>在G1并发标记中用到两个Bitmap，一个PrevBitmap记录第n-1轮的并发标记完成之后构造的bitmap；nextBitmap记录第n轮的并发标记中正在构造的bitmap。因为此时正在用户进程仍在运行，还不能使用。在当前的并发标记结束后，当前标记的nextBitmap就变成了PrevBitmap</p>
<p>并发标记阶段，bitmap和TAMS的作用如图<br><img src="https://img-blog.csdnimg.cn/20200716170252976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>[Bottom, PTAMS) 这部分对象的存活信息可以通过PrevBitmap来得知<br>[prevTAMS, nextTAMS) 这部分是第n-1次并发标记时默认存活的<br>[nextTAMS, top) 这部分是第n次并发标记时用户进程新产生的对象分配的内存，默认存活</p>
</blockquote>
<p>在初始标记的最后，G1会分配一个空的next Bitmap将top的地址值赋给NTAMS。PrevBitmap记录上次标记的数据，PTAMS是上次的标记位置。从PTAMS向上分配给新对象内存。并发标记线程将找到PTAMS, NTAMS之间的所有存活对象，将标记数据存储到next Bitmap中。</p>
</blockquote>
<p>此外，由于并行会继续不断产生新对象，需要内存分配，G1设置了两TAMS（Top at Mark Start）指针，在Region中划分出一块空间来用于新对象的分配。新地址在这两个指针之上，G1默认这个地址之上的对象是被隐式标记过的，是默认存活的。</p>
<ol>
<li>怎么建立起可靠的停顿预测模型？<br>基于衰减平均值（更容易受到新数据的影响）理论实现，根据信息预测现在回收，哪些region组成的回收集的收益更大。</li>
</ol>
<p><strong>运行过程：</strong></p>
<ol>
<li>初始标记。仅标记GC Roots能直接关联到的对象，并修改TAMS指针的值，让下一阶段用户线程并发运行时候，能够正确地在可用Region中分配对象。需要短暂停顿线程。而且可以借助进行Minor GC时候完成。</li>
<li>并发标记。从根节点对对象图开始进行可达性分析，标记出不可达节点。耗时较长，与用户线程并发执行。</li>
<li>最终标记。处理SAATB记录中发生改变的对象</li>
<li>筛选回收。选择收益大的组成回收集，把回收集中存活对复制到新的Region上，再清理掉整个空间。必须暂停用户线程，多收集器线程并行完成。</li>
</ol>
<p><strong>CMS和G1的对比：</strong></p>
<ol>
<li>G1可以设置最大停顿时间</li>
<li>G1从整体来看，采用标记-整理算法，局部来看则是标记-复制算法，不会像CMS一样，由于采用标记-清除算法而产生大量空间碎片</li>
<li>CMS只要一个记忆集，而且是单向的。G1为双向卡表，而且每个区域都要有一个记忆集，这导致需要占用堆容量的20%甚至更多的内存空间。</li>
<li>CMS写后屏障维护卡表，G1不仅需要写后屏障维护卡表，为了实现SATB，还需要写前屏障来跟踪并发时候指针的情况。虽然原始快照搜索可以避免像CMS的增量更新算法一样，在初始标记和重新标记中长时间停顿，但是实现算法更繁琐，消耗更多运算资源。</li>
<li>CMS主要用于小内存应用，G1更适合大内存应用。这个优劣势分界点多在6~8GB。</li>
</ol>
<h2 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h2>]]></content>
      <categories>
        <category>阅读记录</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>内存分配策略</tag>
        <tag>《深入理解Java虚拟机》</tag>
      </tags>
  </entry>
  <entry>
    <title>《设计模式之禅》</title>
    <url>/2021/01/22/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/</url>
    <content><![CDATA[<p>代码见<a href="https://github.com/two-fire/Design-Patterns" target="_blank" rel="noopener">Github-Design-Patterns</a></p>
<h3 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式 [Strategy Pattern]"></a>策略模式 [Strategy Pattern]</h3><ol>
<li>定义一个三个锦囊妙计的策略接口</li>
<li>分别实现三个妙计：<br> 1）找乔国老帮忙，让吴国太给孙权施加压力<br> 2）求吴国太开个绿灯,放行！<br> 3）孙夫人断后，挡住追兵</li>
<li>定义一个存放妙计的锦囊</li>
<li>赵云使用三个妙计</li>
</ol>
<p>策略模式的好处就是：</p>
<ol>
<li>高内聚低耦合</li>
<li>扩展性：策略类可以继续增加下去，只需要修改Context.java即可</li>
</ol>
<h3 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式 [Proxy Pattern]"></a>代理模式 [Proxy Pattern]</h3><p>代理模式主要使用了 Java 的多态，干活的是<strong>被代理类</strong>，<strong>代理类</strong>主要是接活。怎么知道被代理类能不能干呢？大家知根知底，你能做啥，我能做啥都清楚的很，<strong>同一个接口呗</strong>。</p>
<ol>
<li>定义一类女人，可以抛媚眼和陪酒。</li>
<li>潘金莲、贾氏均继承这类女人，完成相关的抛媚眼和陪酒活动。</li>
<li>定义王婆，指定完成抛媚眼和陪酒活动的对象。</li>
<li>定义西门庆，叫出王婆，王婆派人出来进行活动。</li>
</ol>
<h3 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式 [Singleton Pattern]"></a>单例模式 [Singleton Pattern]</h3><p>中国历史一般都是一朝代一个皇帝。只要大家提到皇帝，就知道指的是谁，清晰明确。问题是如果一个朝代有两个皇帝怎么办？就会产生错乱情况！所以需要用到<font color = red><strong>单例模式</strong></font>。</p>
<ol>
<li>定义一个皇帝<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Emperor emperor = <span class="keyword">null</span>; <span class="comment">// 定义一个皇帝，然后给他名字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (emperor == <span class="keyword">null</span>) &#123; <span class="comment">// 如果皇帝还没有定义，就定义一个</span></span><br><span class="line">            emperor = <span class="keyword">new</span> Emperor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> emperor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 皇帝叫什么？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">emperorInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我就是皇帝某某某...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义大臣。大臣每天见皇帝，今天、昨天、前天皇帝不可以不一样！<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>) <span class="comment">// 告诉它对被批注的代码元素内部的某些警告保持静默</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minister</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一天</span></span><br><span class="line">        Emperor emperor1 = Emperor.getInstance();</span><br><span class="line">        emperor1.emperorInfo(); <span class="comment">// 第一天的皇帝叫什么名字？</span></span><br><span class="line">        <span class="comment">// 第二天</span></span><br><span class="line">        Emperor emperor2 = Emperor.getInstance();</span><br><span class="line">        emperor2.emperorInfo(); <span class="comment">// 第二天的皇帝叫什么名字？</span></span><br><span class="line">        <span class="comment">// 第三天</span></span><br><span class="line">        Emperor emperor3 = Emperor.getInstance();</span><br><span class="line">        emperor3.emperorInfo(); <span class="comment">// 第三天的皇帝叫什么名字？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><font color = red><strong>单例模式</strong></font>就是在构造函数中多加了<font color = red>一个构造函数，访问权限是private</font>就可以了。<br>简单但有<strong>风险</strong>:</p>
<ul>
<li>例如两个线程A,B，A正在执行new申请内存分配，可能需要0.001微秒，B执行到this.singletonPatton == null，这时候判断条件是true还是false？</li>
<li>如果是true，那么内存中不就存在了两个SingletonPattern的实例?</li>
<li>如果这个单例是创建一个信资源，就会出现业务逻辑混乱！<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPattern</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern singletonPattern = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 限制住不能直接产生一个实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonPattern</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 获取实例     </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingletonPattern <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.singletonPattern == <span class="keyword">null</span>) &#123; <span class="comment">//如果还没有实例，则创建一个</span></span><br><span class="line">            <span class="keyword">this</span>.singletonPattern = <span class="keyword">new</span> SingletonPattern();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.singletonPattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="多例模式-Multition-Pattern"><a href="#多例模式-Multition-Pattern" class="headerlink" title="多例模式 [Multition Pattern]"></a>多例模式 [Multition Pattern]</h3><p>特殊情况下，还是会有两个皇帝的朝代。这种场景放到我们设计模式中就叫有上限的多例模式。</p>
<ol>
<li>先把几个皇帝定义出来。其中获取皇帝的实例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">    Random random = <span class="keyword">new</span> Random(); </span><br><span class="line">    countNumOfEmperor = random.nextInt(maxNumOfEmperor);  <span class="comment">//随机拉出一个皇帝，</span></span><br><span class="line">    只要是个精神领袖就成 </span><br><span class="line">    <span class="keyword">return</span> (Emperor)emperorList.get(countNumOfEmperor);</span><br></pre></td></tr></table></figure></li>
<li>定义大臣。大臣是比较悲惨了，两个皇帝呀，怎么拜呀，不管了，只要是个皇帝就成。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">int</span> ministerNum =<span class="number">10</span>; <span class="comment">//10个大臣 </span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ministerNum;i++)&#123; </span><br><span class="line">   Emperor emperor = Emperor.getInstance(); </span><br><span class="line">   System.out.print(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"个大臣参拜的是："</span>); </span><br><span class="line">   emperor.emperorInfo(); </span><br><span class="line">  &#125;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
如果有的大臣有骨气只拜一个皇帝怎么处理？getInstance(param)就解决了这个问题！</li>
</ol>
<h3 id="工厂方法模式-Factory-Method-Pattern"><a href="#工厂方法模式-Factory-Method-Pattern" class="headerlink" title="工厂方法模式 [Factory Method Pattern]"></a>工厂方法模式 [Factory Method Pattern]</h3><p>女娲造人</p>
<ol>
<li>定义HumanFactory类，里面有<code>createHuman(Class c)</code>产生人类。</li>
<li>定义NvWa类，里面定义主方法，调用createHuman(WhiteHuman.class),createHuman(BlackHuman.class),createHuman(YellowHuman.class),并进行对应的笑、哭、讲话的行为。</li>
</ol>
<p>但是这样创建太累了，那怎么办？神仙就想了：我塞进去一团泥巴，随机出来一群人，管他是黑人、白人、黄人，只要是人就成。</p>
<ol>
<li>修改HumanFactory类，里面增加<code>createHuman()</code>，首先将三种人类放到List<Class>中，利用Random产生随机数，随机获取人种传入<code>createHuman(Class c)</code>产生人类。</li>
<li>修改NvWa类，只要调用<code>createHuman()</code>和相关行为操作即可。</li>
<li>增加一个ClassUtils类，定义<code>List&lt;Class&gt; getAllClassByInterface(Class c)</code>方法实现：给一个接口，返回这个接口的所有实现类。</li>
</ol>
<p>好处：</p>
<ol>
<li>增加了<code>createHuman()</code>后，这个工厂的<strong>扩展性</strong>更好了。以后要再加一个人类，只要你继续集成 Human 接口成了。</li>
<li>工厂模式还有一个非常重要的应用，就是<strong>延迟化</strong>。这个在类初始化很消耗资源的情况比较实用，通过这种方式可以很好的减少项目的复杂程度。<br>在HumanFactory类中定义一个MAP,初始化过的Human对象都放在这里。如果MAP中有，则直接从取出，不用初始化了。</li>
</ol>
<blockquote>
<p><strong>延迟化</strong>：一个对象初始化完毕后就不释放，等到再次用到得就不用再次初始化了，直接从内存过中拿到就可以了。</p>
</blockquote>
<h3 id="抽象工厂模式-Abstract-Factory-Pattern"><a href="#抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式 [Abstract Factory Pattern]"></a>抽象工厂模式 [Abstract Factory Pattern]</h3><p>工厂方法模式中，女娲造人忘记给人类定义性别了，那怎么办？抹掉重来，然后就把人类重新洗牌，准备重新开始制造人类。</p>
<ol>
<li>首先根据Huamn接口，完成抽象工厂模式下的产品等级和产品族，也就是定义人类以及产生出的人类是什么样子的。包括抽象黄种人、抽象白种人、抽象黑种人，以及实现类的黄种女人、黄种男人……</li>
<li>枚举出世界上有哪些类型的人。</li>
<li>创建工厂类。创建enum类型把世界上所有人类型都定义出来。定义一个HumanFactory接口，底下定义两个抽象类，分别创建男人和女人的”八卦炉”。</li>
<li>女娲开始造人。</li>
</ol>
<p><strong>好处</strong>：</p>
<ol>
<li>高内聚，低耦合。</li>
<li>工厂模式<strong>符合 OCP 原则</strong>，也就是开闭原则。比如就性别的问题，这个世界上还存在双性人，那这个就是要在我们的产品族中增加一类产品，同时再增加一个工厂就可以解决这个问题。</li>
</ol>
]]></content>
      <categories>
        <category>阅读记录</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【多线程】MESI--CPU缓存一致问题</title>
    <url>/2020/09/19/%E3%80%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%91MESI--CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>MESI</strong>（Modified Exclusive Shared Or Invalid）也称伊利诺斯协议（伊利诺斯州立大学提出），是一种广泛使用的支持写回策略的<strong>缓存一致性协议</strong>。Intel使用的协议。还有MSI，MOSI，FireFly等协议。</p>
<h3 id="MESI协议中的状态"><a href="#MESI协议中的状态" class="headerlink" title="MESI协议中的状态"></a>MESI协议中的状态</h3><p>CPU中每个缓存行使用四种状态标记（2bit）<br>M: 被修改（Modified)。内容已不同于主存并且为此cache专有；<br>E: 独享的（Exclusive)。此cache行内容同于主存，但不出现于其它cache中；<br>S：共享的（Shared）。此cache行内容同于主存，但也出现于其它cache中；<br>I：无效的（Invalid）。此cache行内容无效。</p>
<p>当前状态为M：</p>
<ul>
<li><p>Local Read 从cache中取数据，<code>状态不变</code></p>
</li>
<li><p>Local Write 修改cache中数据，<code>状态不变</code><br>注：本身就是M，不论是否对数据修改，这个cache line 始终处于被改变状态。</p>
</li>
<li><p>Remote Read 先将数据写入内存，由于需要让其他核能拿到最新数据，<code>状态--&gt;S</code></p>
</li>
<li><p>Remote Write 先将这条数据写入内存，由于之后其他Core会修改这条数据，<code>状态--&gt;I</code></p>
</li>
</ul>
<p>当前状态为E：</p>
<ul>
<li>Local Read 从cache中取数据，<code>状态不变</code></li>
<li>Local Write 修改cache中数据，<code>状态--&gt;M</code></li>
<li>Remote Read 由于需要让其他核能拿到数据，<code>状态--&gt;S</code></li>
<li>Remote Write 数据被修改，本缓存行不能再使用，<code>状态--&gt;I</code></li>
</ul>
<p>当前状态为S：</p>
<ul>
<li><p>Local Read 从cache中取数据，<code>状态不变</code></p>
</li>
<li><p>Local Write 修改cache中数据，在本CPU中<code>状态--&gt;M</code>，在其他核共享的Cache line<code>状态--&gt;I</code><br>注：Local Write后，其他共享核在使用这个cache line前需要重新从内存中读取。</p>
</li>
<li><p>Remote Read 已经处于共享态了，所以<code>状态不变</code></p>
</li>
<li><p>Remote Write 数据被修改，本cache line不能再使用，<code>状态--&gt;I</code></p>
</li>
</ul>
<p>当前状态为I：</p>
<ul>
<li>Local Read<br>如果其他Cache没有这份数据，本cache从该内存中读出数据，<code>状态--&gt;E</code><br>如果其他Cache有这份数据，状态为M，则将数据更新到内存，本Cache再从内存中读取数据，两个cache的cache line<code>状态--&gt;S</code>；<br>如果其他Cache有这份数据，状态为S或E，本cache从内存中取出数据，这些cache的cache line<code>状态--&gt;S</code></li>
<li>Local Write 从内存中取数据，在Cache中修改，<code>状态--&gt;M</code>。如果其他Cache有这份数据，它们的cache line<code>状态--&gt;I</code>；如果其他Cache有这份数据，切状态为M，要先将数据更新到内存。    </li>
<li>Remote Read 因为是Invalid，别的核操作与它无关</li>
<li>Remote Write 因为是Invalid，别的核操作与它无关</li>
</ul>
]]></content>
      <categories>
        <category>硬件基础知识</category>
        <category>CPU</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>MESI</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>【抽象工厂模式】报错ClassCastException</title>
    <url>/2021/01/31/%E3%80%90%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%91%E6%8A%A5%E9%94%99ClassCastException/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接产生一个实例（人类）</span></span><br><span class="line">human = (Human)Class.forName(humanEnum.getValue()).newInstance();</span><br></pre></td></tr></table></figure>
<p>上面一句报错：<br><font color=red>Exception in thread “main” java.lang.ClassCastException: abstractfactory.yellowHuman.YellowMaleHuman cannot be cast to abstractfactory.Human</font></p>
<p>原因：<br>在AbstractYellowHuman类中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> factorymethod.Human</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractYellowHuman</span> <span class="keyword">implements</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>应该是</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> abstractfactory.Human;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>阅读记录</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>关联查询</title>
    <url>/2021/02/06/%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>要想进行关联意味着两张表中必须包含相关联的字段。<br>多于两张表的连接：<br>为了连接n个表，至少需要n-1个连接。</p>
<h2 id="sql-1992语法的连接"><a href="#sql-1992语法的连接" class="headerlink" title="sql:1992语法的连接"></a>sql:1992语法的连接</h2><p><strong>语法规则</strong><br>SELECT table1.column, table2.column<br>FROM table1, table2<br>WHERE table1.column1 = table2.column2;<br>▪ 在 WHERE 子句中写入连接条件<br>▪ 当多个表中有重名列时，必须在列的名字前加上表名作为前缀<br>▪ <strong>连接的类型</strong>：</p>
<ol>
<li>等值连接 – Equijoin</li>
<li>非等值连接 – Non-equijoin</li>
<li>外连接 – Outer join</li>
<li>自连接 – Self join</li>
</ol>
<h3 id="92语法"><a href="#92语法" class="headerlink" title="92语法"></a>92语法</h3><p>数据来自于多张表 ,92表连接<br>▪ 注意: 明确引用<strong>同名的列</strong>，必须使用表名 或者别名区分</p>
<h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><p>等值连接，两个表中包含相同的列名。</p>
<p>例如，雇员表（emp）中的部门编号和部门表（dept）中的部门编号是一样的。<br><code>select * from emp,dept where emp.deptno = dept.deptno;</code><br><img src="https://img-blog.csdnimg.cn/20210206224950842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以可以查询雇员的名称和所属部门的名称：<br><code>select ename,dname from emp,dept where emp.deptno = dept.deptno;</code><br><img src="https://img-blog.csdnimg.cn/20210206225550124.png" width=30% height=30% align=center></p>
<h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><p>非等值连接，两个表中没有相同的列名，但是某一列在另一张表的列的范围之中【!= &gt; &lt; &gt;= &lt;= between and】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询雇员名称以及自己的薪水等级</span></span><br><span class="line"><span class="keyword">select</span> e.ename, e.sal, sg.grade</span><br><span class="line">  <span class="keyword">from</span> emp e, salgrade sg</span><br><span class="line"> <span class="keyword">where</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br></pre></td></tr></table></figure>

<p>▪ select 字段列表 from 表1,表2,表3….<br>▪ where 表1.列!=表2.列 and 表1.列!=表3.列</p>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>在等值基础上，确保一张表(主表)的记录都存在。从表满足则匹配，不满足补充null<br><em>分类*</em>：<br>▪ 1、左外连接: 主表在左边（把左表的全部数据显示）<br>▪ 2、右外连接: 主表在右边（把右表的全部数据显示）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--需要将雇员表中的所有数据都进行显示，利用等值连接只会把关联到的数据显示，</span></span><br><span class="line"><span class="comment">--没有关联到的数据不会显示，此时需要外连接。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno = d.deptno; <span class="comment">--等值连接</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno = d.deptno(+); <span class="comment">--左外连接</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno(+) = d.deptno; <span class="comment">--右外连接</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno(+) = d.deptno(+); <span class="comment">--不能同时存在</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210207085526772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210207085721892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接:"></a>自连接:</h4><p>自连接,特殊的等值连接。将一张表当成不同的表来看待，自己关联自己</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--将雇员和他经理的名称查出来</span></span><br><span class="line"><span class="keyword">select</span> e.ename || <span class="string">' work for '</span>||m.ename <span class="keyword">from</span> emp e,emp m <span class="keyword">where</span> e.mgr = m.empno;</span><br></pre></td></tr></table></figure>

<h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p>当关联多张表，但不指定连接条件的时候，会进行笛卡尔积。<br>关联后的总记录为m * n，一般不要使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e, dept d; <span class="comment">-- 16 * 4 = 64条</span></span><br></pre></td></tr></table></figure>
<p>▪ <strong>92的连接语法有什么问题</strong>？？？<br>&emsp;92语法中，多张表的连接条件会放到方法where子句中，同时where需要对表进行条件过滤，因此，相当于将过滤条件和连接条件揉到一起，太乱了，所以出现了99语法。</p>
<h2 id="sql-1999语法的连接"><a href="#sql-1999语法的连接" class="headerlink" title="sql:1999语法的连接"></a>sql:1999语法的连接</h2><p>▪ sql1992的语法规则暴露了这样的缺点：语句过滤条件和表连接的条件都放到了where子句中 。当条件过多时，联结条件多，过滤条件多时，就容易造成混淆。<br>▪ SQL1999修正了整个缺点，<font color='red'>把联结条件，过滤条件分开来</font>，包括以下新的TABLE JOIN的句法结构：<br>– CROSS JOIN<br>– NATURAL JOIN<br>– USING子句<br>– ON子句<br>&emsp;– LEFT OUTER JOIN<br>&emsp;– RIGHT OUTER JOIN<br>&emsp;– FULL OUTER JOIN<br>&emsp;– Inner outer join<br>▪ 两种语法的SQL语句没有任何限制，再公司中可以随意使用，但是建议使用99语法，不要使用92语法，SQL显得清楚明了。</p>
<h4 id="CROSS-JOIN-交叉连接"><a href="#CROSS-JOIN-交叉连接" class="headerlink" title="CROSS JOIN(交叉连接)"></a>CROSS JOIN(交叉连接)</h4><p>等同于92语法中的笛卡尔积。少用它</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">cross</span> <span class="keyword">join</span> dept;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp ,dept;</span><br></pre></td></tr></table></figure>
<h4 id="NATURAL-JOIN-自然连接"><a href="#NATURAL-JOIN-自然连接" class="headerlink" title="NATURAL JOIN(自然连接)"></a>NATURAL JOIN(自然连接)</h4><p>相当于是等值连接，但是注意：<font color='red'>不需要写连接条件</font>，会从两张表中找到<strong>相同的列</strong>做连接。<br>▪ 当两张表中不具有相同的列名的时候，会进行笛卡尔积操作。所以规定上禁止在不具有相同的列名的时候使用NATURAL JOIN。<br>▪ <em>自然连接*</em>跟92语法的<strong>自连接</strong>没有任何关系<br>▪ 自然连接的结果不保留重复的属性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">natural</span> <span class="keyword">join</span> dept d ;<span class="comment">--自然连接的结果不保留重复的属性</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno=d.deptno;<span class="comment">--保留</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">natural</span> <span class="keyword">join</span> salgrade sg;</span><br></pre></td></tr></table></figure>

<h4 id="ON子句"><a href="#ON子句" class="headerlink" title="ON子句"></a>ON子句</h4><p>为了设置任意的连接条件或者指定连接的列，需要使用ON子句。<br>▪ 使用ON 子句可以将<strong>连接条件</strong>（on）与其它的<strong>查询条件</strong>（where）分开书写。<br>▪ on子句，可以添加<strong>任意的</strong>连接条件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--添加连接条件 相当于92语法中的等值连接</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno;</span><br><span class="line"><span class="comment">--相当于92语法中的非等值连接</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br></pre></td></tr></table></figure>
<p><strong>使用on创建连接三表连接</strong><br>检索雇员名字、所在单位、薪水等级：这三个信息在三个表里面，<br>所以只能用多表联结</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename, dname, grade</span><br><span class="line">  <span class="keyword">from</span> emp</span><br><span class="line">  <span class="keyword">join</span> dept</span><br><span class="line">    <span class="keyword">on</span> emp.deptno = dept.deptno</span><br><span class="line">  <span class="keyword">join</span> salgrade</span><br><span class="line">    <span class="keyword">on</span> emp.sal <span class="keyword">between</span> salgrade.losal <span class="keyword">and</span> salgrade.hisal;</span><br></pre></td></tr></table></figure>

<h5 id="外连接-1"><a href="#外连接-1" class="headerlink" title="外连接"></a>外连接</h5><p><strong>left (outer) join</strong>（左外连接），会把左表中全部数据正常显示，右表没有对应的数据直接显示空即可。outer可省略<br><strong>right (outer) join</strong>（右外连接），会把右表中全部数据正常显示，左表没有对应的数据直接显示空即可。outer可省略<br><strong>full (outer) join</strong>，相当于左外连接和右外连接的合集</p>
<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p><strong>inner join</strong>（内连接），两张表的连接查询，只会查询出<strong>有匹配记录</strong>的数据。也就是说，必须要有对应才能查出来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--left (outer) join</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno = d.deptno(+);</span><br><span class="line"><span class="comment">--right (outer) join</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno(+) = d.deptno;</span><br><span class="line"><span class="comment">--full (outer) join</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno=d.deptno;</span><br><span class="line"><span class="comment">--inner join 底下效果相同 不会合并相同的列</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">inner</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno=d.deptno;</span><br><span class="line"><span class="comment">--默认内连接</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno=d.deptno;</span><br></pre></td></tr></table></figure>
<h4 id="USING子句"><a href="#USING子句" class="headerlink" title="USING子句"></a>USING子句</h4><p>using，除了可以使用on表示连接条件之外，也可以使用<strong>using</strong>作为连接条件,但是此时连接条件的列<font color='red'>不再归属于任意一张表</font>。<br>▪ using子句引用的列在sql任何地方不能使用表名或者别名做前缀，基本不使用它。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">using</span>(deptno); <span class="comment">--deptno只显示一列，不保留重复的属性</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno=d.deptno;<span class="comment">--deptno显示两列</span></span><br><span class="line"><span class="keyword">select</span> deptno <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">using</span>(deptno); <span class="comment">--没问题</span></span><br><span class="line"><span class="keyword">select</span> e.deptno <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">using</span>(deptno); <span class="comment">--报错</span></span><br><span class="line"><span class="keyword">select</span> e.deptno <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno=d.deptno；<span class="comment">--没问题</span></span><br></pre></td></tr></table></figure>

<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>SQL允许多层嵌套。子查询，即嵌套在其他查询中的查询<br>▪ 把子查询当作一张表来看待。外层的语句可以把内嵌的子查询返回的结果当成一张表使用。<br>&emsp;– 子查询要用括号括起来<br>&emsp;– 将子查询放在比较运算符的右边(增强可读性)<br>▪ <strong>子查询分类</strong>：<br>&emsp;1.<strong>单行子查询</strong><br>&emsp;&emsp;返回一行记录<br>&emsp;&emsp;使用单行记录比较运算符<br><img src="https://img-blog.csdnimg.cn/20210207161102508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=30% height=30% align=center><br>复杂的sql语句可以拆开来做。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询有哪些人的薪水是在整个雇员的平均薪水之上的？</span></span><br><span class="line"><span class="comment">--1.首先求所有雇员的平均薪水</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(e.sal) <span class="keyword">from</span> emp e;</span><br><span class="line"><span class="comment">--2.把所有人的薪水与平均薪水做比较</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.sal &gt; (<span class="keyword">select</span> <span class="keyword">avg</span>(e.sal) <span class="keyword">from</span> emp e);</span><br></pre></td></tr></table></figure>
<p>&emsp;2.<strong>多行子查询</strong><br>&emsp;&emsp;返回多行记录<br>&emsp;&emsp;使用集合比较运算符<br><img src="https://img-blog.csdnimg.cn/20210207161039578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=40% height=40% align=center><br><strong>在多行子查询中使用in</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--我们要查在雇员中有哪些人是经理人？</span></span><br><span class="line"><span class="comment">--1.查询所有经理人编号(去重操作)</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> e.mgr <span class="keyword">from</span> emp e;</span><br><span class="line"><span class="comment">--2.在雇员表中过滤这些编号即可</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.empno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> e.mgr <span class="keyword">from</span> emp e);</span><br></pre></td></tr></table></figure>
<p><strong>在多行子查询中使用some all</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--找出部门编号为20的所有员工中收入最高的职员?</span></span><br><span class="line"><span class="comment">--1.找出部门编号为20的所有员工的收入</span></span><br><span class="line"><span class="keyword">select</span> e.sal <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno = <span class="number">20</span>;</span><br><span class="line"><span class="comment">--2.求不小于1中求出收入的雇员，且部门编号是20</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> emp e</span><br><span class="line"> <span class="keyword">where</span> sal &gt;= <span class="keyword">all</span> (<span class="keyword">select</span> e.sal <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno = <span class="number">20</span>)</span><br><span class="line">   <span class="keyword">and</span> e.deptno = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><strong>在From子句中使用子查询</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--求每个部门平均薪水的等级</span></span><br><span class="line"><span class="comment">--1.首先将每个部门的平均薪水求出来结果可以当成一张虚拟表</span></span><br><span class="line"><span class="keyword">select</span> e.deptno,<span class="keyword">avg</span>(e.sal) <span class="keyword">from</span> emp e <span class="keyword">group</span> <span class="keyword">by</span> e.deptno;</span><br><span class="line"><span class="comment">--2.上面的表跟薪水等级表做关联，求得薪水等级</span></span><br><span class="line"><span class="keyword">select</span> t.deptno, sg.grade</span><br><span class="line">  <span class="keyword">from</span> salgrade sg</span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> e.deptno, <span class="keyword">avg</span>(e.sal) vsal <span class="keyword">from</span> emp e <span class="keyword">group</span> <span class="keyword">by</span> e.deptno) t</span><br><span class="line">    <span class="keyword">on</span> t.vsal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br></pre></td></tr></table></figure>

<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>限制输出，limit，mysql中用来做限制输出的，但是Oracle中不是。<br>在Oracle中，如果需要使用限制输出和分页的功能，必须使用rownum，但是<font color="red">rownum不能直接使用，需要嵌套使用</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--求薪水最高的前5名雇员</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">order</span> <span class="keyword">by</span> e.sal <span class="keyword">desc</span>) t1</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>理解：<code>select * from emp e order by e.sal desc</code>排好序后形成一张虚拟表，rownum相当于系统默认赋予的一个列名，放着排序的序号，但是不显。也不能直接：<code>select * from emp e where rownum &lt;= 5 order by e.sal desc;</code>，这样只是将前五条进行了一个排序。<br>如果求薪水最高的第6到10名雇员，<font color="purple">不能直接在where中用<code>rownum &gt; 5 and rownum &lt;= 10</code>来限制输出。</font><br><strong>原因</strong>：因为rownum的值不是固定死的，而是随着变化而变化的。比如这道例子中，<code>rownum&gt;5</code>会先进行一个截取，截取后前五条的编号就不存在了，然后把后面的往前递进（原来第六条变成了第一条…），然后再<code>rownum&lt;=10</code>截取，就会出现问题。<br>可以进行如下操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--可以多打印出rownum这一列，必须写t1.,不然查不出来</span></span><br><span class="line"><span class="keyword">select</span> t1.*,<span class="keyword">rownum</span></span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">order</span> <span class="keyword">by</span> e.sal <span class="keyword">desc</span>) t1</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">10</span>;</span><br><span class="line"><span class="comment">--求薪水最高的第6到10名雇员</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> t1.*, <span class="keyword">rownum</span> rn</span><br><span class="line">          <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">order</span> <span class="keyword">by</span> e.sal <span class="keyword">desc</span>) t1</span><br><span class="line">         <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">10</span>) t</span><br><span class="line"> <span class="keyword">where</span> t.rn &gt; <span class="number">5</span></span><br><span class="line">   <span class="keyword">and</span> t.rn &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><font color="red">使用rownum的时候必须要在外层添加嵌套，此时才能将rownum作为其中的一个列，然后再进行限制输出。</font></p>
<h3 id="易错例子"><a href="#易错例子" class="headerlink" title="易错例子"></a>易错例子</h3><p>1、找出部门编号为20的所有员工中收入最高的职员</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--1.找出部门编号为20的所有员工的收入</span></span><br><span class="line"><span class="keyword">select</span> e.sal <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno = <span class="number">20</span>;</span><br><span class="line"><span class="comment">--2.求不小于1中求出收入的雇员，且部门编号是20</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> emp e</span><br><span class="line"> <span class="keyword">where</span> sal &gt;= <span class="keyword">all</span> (<span class="keyword">select</span> e.sal <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno = <span class="number">20</span>)</span><br><span class="line">   <span class="keyword">and</span> e.deptno = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><font color="purple">第二步不要忘了约束条件<code>e.deptno = 20</code></font></p>
<p>2、求平均薪水最高的部门的部门编号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--1.部门平均薪水(t1)</span></span><br><span class="line"><span class="keyword">select</span> e.deptno, <span class="keyword">avg</span>(e.sal) vsal <span class="keyword">from</span> emp e <span class="keyword">group</span> <span class="keyword">by</span> e.deptno;</span><br><span class="line"><span class="comment">--2.求表1中平均薪水最高的部门薪水</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(t1.vsal)</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> deptno, <span class="keyword">avg</span>(e.sal) vsal <span class="keyword">from</span> emp e <span class="keyword">group</span> <span class="keyword">by</span> e.deptno) t1;</span><br><span class="line"><span class="comment">--3.求平均薪水最高的部门编号</span></span><br><span class="line"><span class="keyword">select</span> t1.deptno, t1.vsal</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> e.deptno, <span class="keyword">avg</span>(e.sal) vsal <span class="keyword">from</span> emp e <span class="keyword">group</span> <span class="keyword">by</span> e.deptno) t1</span><br><span class="line"> <span class="keyword">where</span> t1.vsal =</span><br><span class="line">       (<span class="keyword">select</span> <span class="keyword">max</span>(t1.vsal)</span><br><span class="line">          <span class="keyword">from</span> (<span class="keyword">select</span> deptno, <span class="keyword">avg</span>(e.sal) vsal <span class="keyword">from</span> emp e <span class="keyword">group</span> <span class="keyword">by</span> e.deptno) t1);</span><br></pre></td></tr></table></figure>
<p><font color="purple">复杂的sql语句可以拆开来做。</font></p>
<p>3、求出部门编号为20的雇员名、部门名、薪水等级</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--方法一</span></span><br><span class="line"><span class="comment">--1.求出部门编号为20的雇员名、部门编号、薪水</span></span><br><span class="line"><span class="keyword">select</span> e.ename, e.deptno, e.sal <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno = <span class="number">20</span>;</span><br><span class="line"><span class="comment">--2.t1表与salgrade表进行关联,求得薪水等级</span></span><br><span class="line"><span class="keyword">select</span> t1.ename, t1.deptno, sg.grade</span><br><span class="line">  <span class="keyword">from</span> salgrade sg</span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> e.ename, e.deptno, e.sal <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno = <span class="number">20</span>) t1</span><br><span class="line">    <span class="keyword">on</span> t1.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br><span class="line"><span class="comment">--3.t2表与dept表进行关联，求得部门名</span></span><br><span class="line"><span class="keyword">select</span> t2.ename, d.dname, t2.grade</span><br><span class="line">  <span class="keyword">from</span> dept d <span class="keyword">natural</span></span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> t1.ename, t1.deptno, sg.grade</span><br><span class="line">          <span class="keyword">from</span> salgrade sg</span><br><span class="line">          <span class="keyword">join</span> (<span class="keyword">select</span> e.ename, e.deptno, e.sal</span><br><span class="line">                 <span class="keyword">from</span> emp e</span><br><span class="line">                <span class="keyword">where</span> e.deptno = <span class="number">20</span>) t1</span><br><span class="line">            <span class="keyword">on</span> t1.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal) t2;</span><br><span class="line"><span class="comment">--方法二</span></span><br><span class="line"><span class="keyword">select</span> ename, dname, grade</span><br><span class="line">  <span class="keyword">from</span> emp e</span><br><span class="line">  <span class="keyword">join</span> dept d</span><br><span class="line">    <span class="keyword">on</span> d.deptno = e.deptno</span><br><span class="line">  <span class="keyword">join</span> salgrade sg</span><br><span class="line">    <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal</span><br><span class="line"> <span class="keyword">where</span> e.deptno = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><font color="purple">可以使用on创建三表连接，不需要将3个变成2个，再进行关联，比较麻烦</font></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>关联查询</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2020/09/22/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="内存管理发展历程"><a href="#内存管理发展历程" class="headerlink" title="内存管理发展历程"></a>内存管理发展历程</h3><p>一、 <strong>DOS时代</strong>：（单进程）同一时间只有一个进程运行 （也有一些特殊算法可以支持多进程）<br>二、 <strong>windows9x</strong> - 多个进程装入内存<br>   问题：<br>   1）内存不够用<br>   2）互相打扰<br>三、为了解决这两个问题，诞生了<strong>现在的内存管理系统</strong>：虚拟地址 分页装入 软硬件结合寻址</p>
<ol>
<li>内存分页:分成固定大小的页框（page frame）最基本的分页大<br>是4k。把程序（硬盘上）分成4k大小的块，用到哪一块加载哪一块。<br>加载中，内存满就交换分区。<br>流程举例：把进程分页后，记录到页表。之后告诉进程调度器有个进程要进入内存。假如程序入口在第三页，那么进程调度器会通知进程，先将第3页内容装入内存执行。在执行中，如果用到第4块，就把第四块装入。要是满了，进行<font color = red>交换分区</font>（LRU算法，把最近最久没用的拿到<code>SWAP分区</code>【硬盘实现，速度慢】）</li>
</ol>
<font color = orenge>
注：
- LRU leetCode 146题
  **哈希表（保证 查找操作O(1)） + 链表（保证 排序操作和新增操作O(1)）**
  最终 链表--> 双向链表（保证 左边指针 指向右边块）
- 所有涉及到缓存的，基本都是LRU（least recently used，最不常用算法），LFU
</font>

<ol start="2">
<li><p>虚拟内存（解决相互打扰问题）<br>1）DOS Win31 … 可以互相干掉对方的内存<br>2）为了保证互不影响 - 让进程工作在虚拟空间，程序中用到的空间地址不再是直接的物理地址，而是虚拟的地址，这样，A进程永远不可能访问到B进程的空间<br>3）虚拟空间多大呢？寻址空间 - 64位系统 2 ^ 64，比物理空间大很多 ，单位是byte<br>4）站在虚拟的角度，进程是独享整个系统 + CPU<br>5）内存映射：偏移量 + 段的基地址 = 线性地址 （虚拟空间）<br>6）线性地址通过 OS + MMU（硬件 Memory Management Unit）转换成物理地址<br>【所以操作系统非常安全】<br><img src="https://img-blog.csdnimg.cn/2020092623324753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>缺页中断<br>需要用到页面内存中没有，产生缺页异常（一种特殊中断），由内核处理并加载【慢】</p>
</li>
</ol>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>算法叫做 <code>Colored Pointer</code><br>GC信息记录在指针上，不是记录在头部， immediate memory use<br>不支持32位，不支持指针压缩</p>
<p>42位指针 寻址空间4T JDK13 -&gt; 16T 目前为止最大16T 2^44</p>
<p>CPU如何区分一个立即数 和 一条指令?<br>总线内部分为：数据总线 地址总线 控制总线</p>
<p>地址总线目前：48位 四位为颜色指针</p>
<p>颜色指针本质上包含了地址映射的概念</p>
]]></content>
      <categories>
        <category>硬件基础知识</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>中断</title>
    <url>/2020/09/22/%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200922200649835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>中断</strong><br>外部条件（硬件中断）：</p>
<ul>
<li>I/O设备（键盘打印机显示器）</li>
<li>磁带、磁盘</li>
<li>时钟<br>内部中断：</li>
<li>软件中断：执行有定义的INT n指令引发的中断。软件给的中断，做任何系统调用<br>软中断是一些对I/O的请求。0x80中断信号都是软中断（<font color = green>软中断就是80中断</font>）而80号对应的又有一堆函数，将近200多个</li>
<li>异常：CPU本身故障、程序故障</li>
</ul>
<p>过程：<br>系统调用：int 0x80（软件调用）或者sysenter原语<br>通过ax寄存器填入调用号</p>
<p>参数通过bx cx dx si di传入内核<br>返回值通过ax返回</p>
<p>java读网络–&gt; jvm read() –&gt; 库read() –&gt; 内核空间 –&gt; system_call() （系统调用处理函数）–&gt; sys_read()</p>
<h3 id="从汇编角度"><a href="#从汇编角度" class="headerlink" title="从汇编角度"></a>从汇编角度</h3><p>Linux中，一切皆文件。用<strong>文件描述符</strong>fd来区分不同的介质。用int 类型的数据来区分键盘、屏幕、磁盘等。</p>
<p>将参数装入ebx，ecx，edx，在ezx中装入函数系统调用号（比如iwrite是4）。然后<code>int 0x80</code>，操作系统收到后，调用80子程序，拿出那些参数，展开变成一段内嵌的汇编代码。</p>
]]></content>
      <categories>
        <category>硬件基础知识</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>内存与IO</title>
    <url>/2020/11/12/%E5%86%85%E5%AD%98%E4%B8%8EIO/</url>
    <content><![CDATA[<h2 id="虚拟目录树"><a href="#虚拟目录树" class="headerlink" title="虚拟目录树"></a>虚拟目录树</h2><p><strong>VFS：虚拟文件系统</strong><br>树上不同节点可以映射到不同的物理位置</p>
<p>程序和硬件（磁盘、网卡…）之间隔了一个内核，里面有pagecache维护想读的数据，如果修改了会标记为<code>dirty</code><br>标记为<code>dirty</code>的有一个<code>flush</code>过程来书写到磁盘中去。</p>
<p>如果系统中有两个程序，想打开同一个文件。并不是两个独立加载的过 程，而是访问VFS，如果发现加载过这个文件，想读的文件pagecache已经命中了，这时候已经可以返回所要的pagecache的数据了。<br>注：页缓存（pagecache）默认4k</p>
<p><strong>FD：文件描述符</strong><br>不同程序对内核中文件的inode各自有各自的fd【它的seek（指针）偏移量不同】<br>所以他们通过偏移找到自己该读写的pagecache。如果大家修改的同一文件，需要加锁。</p>
<h2 id="文件内存"><a href="#文件内存" class="headerlink" title="文件内存"></a>文件内存</h2><p><strong>硬链接</strong><br>磁盘中有这么一个文件。这个文件在虚拟文件系统中、在目录中有各自唯一的path（从开始的根目录一直映射到这个文件名，这个描述路径是唯一的），但指向的是同一个物理文件（inode相同）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vi msb.txt</span><br><span class="line">$ ln &#x2F;root&#x2F;msb.txt &#x2F;root&#x2F;xxoo.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020101721105823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>硬链接后，计数值升为2</li>
<li>改动msb.txt，进入xxoo.txt会发现内容也发生了改变</li>
<li>删除其中一个，另一个仍存在但计数值降为1<br><font color=red>计数值其实就是硬链接被引用的数量</font></li>
</ul>
<p><strong>软链接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ln -s &#x2F;root&#x2F;msb.txt &#x2F;root&#x2F;ooxx.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201017212119184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>改动msb.txt，进入ooxx.txt会发现内容也发生了改变</li>
<li>删除msb.txt <code>ls -l</code>会发现 -&gt; /root/ooxx.txt红 报错</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201017233002419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li><p>磁盘上得到一个被空填充的100M的文件<br>if=inputfile； of=outputfile； bs=blocksize<br>（104876为1M）</p>
</li>
<li><p>把镜像文件映射到虚拟的设备（loop0）上</p>
</li>
<li><p>把loop0格式化为ext2类型<br><img src="https://img-blog.csdnimg.cn/20201017224021292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>这时候<code>loop0</code>是一个设备，只不过这个设备是一个虚拟的映射关系，不是一个物理设备。<code>df</code>中没有它</p>
<ol start="4">
<li><p>进入<code>/mnt</code>，建立并进入一个空目录<code>/ooxx</code>，将<code>loop0</code>挂到<code>/ooxx</code>这个虚拟目录上。所以访问目录的时候，其实就是在访问<code>mydisk.img</code>虚拟硬盘<br><img src="https://img-blog.csdnimg.cn/2020101723013745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p><code>ldd bash</code> 分析<code>bash</code>程序动态链接库有哪些。<br>返回上一级，创建一个<code>/lib</code>目录，模仿我们根目录里面的目录结构里面程序的摆放位置。拷贝动态链接库中的链接文件。<br><img src="https://img-blog.csdnimg.cn/20201017230838975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>echo是bash自带的打印程序，打印“hello” 到abc.txt<br><img src="https://img-blog.csdnimg.cn/20201017232331483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>切回<code>\ooxx</code>目录<br><img src="https://img-blog.csdnimg.cn/20201017232654242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>卸载/ooxx, 再去访问/ooxx，就是空了。不过/root/mashibing下mydisk.img还存在</p>
<p><img src="https://img-blog.csdnimg.cn/20201017233504741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p><code>lsof</code>命令：  查看一个进程打开了哪些文件<br>任何程序都有0、1、2这种输入输出流的文件描述符<br><img src="https://img-blog.csdnimg.cn/20201018214304340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ exec 8&lt; xxoo.txt</span><br><span class="line">$ cd &#x2F;proc&#x2F;$$&#x2F;fd</span><br><span class="line">$ ls -l</span><br></pre></td></tr></table></figure>
<p>利用8去读取xxoo.txt<br>到根目录的/proc/$$/fd</p>
</li>
<li><p>read标准输入0来自于8，把8指向的文件内容赋给a<br>不过read只读到换行符就不读了。所以read通过8只读取到xxoo.txt里面的第一行<br><code>$ read a 0&lt;&amp; 8</code></p>
</li>
<li><p>打开新的程序，进入/proc/$$/fd<br>随便用比如一个 6 也去读取xxoo.txt<br>用<code>lsof -op $$</code> 查看bash进程（id号为$$），6为文件描述符，偏移量为0。<br>这时候用<code>read a &lt;&amp; 6</code>读的时候来自6 也是读ooxx.txt第一行。如果再读一次，读了第二行。这时候偏移量已经移动到10。返回第一个程序，它的偏移量依旧是5。<br>内核为每一个进程各自维护一套数据，这个数据里包含了fd。fd里面维护了一些指向的文件的偏移、inode号等信息。不过缓存pagecache是公用的</p>
</li>
</ol>
<p>任何程序都有0：标准输入，1：标准输出，2：报错删除<br>cd /proc/$$/fd<br>/proc：内核映射目录，开机后内核的变量属性和对象等都会在里面挂载。进程被内核管理，进程或网络的一些属性在/proc里面被映射成文件。<br>$$：当前bash的pid(当前交互进程的id号)   $BASHPID<br>/proc/$$/fd  命令lsof -op $$ 可以看到文件描述符的细节。</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>重定向不是命令，是一种机制。可以选择让你的io指向别的地方去。<br>流的方向就是输入/输出。输入输出重定向操作符的基本符<code>&lt;</code>，<code>&gt;</code><br>e.g</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls .&#x2F;  </span><br><span class="line">$ ls .&#x2F; 1&gt; ~&#x2F;ls.out</span><br><span class="line">$ cat 0&lt; ooxx.txt 1&gt; cat.out</span><br></pre></td></tr></table></figure>
<p>第一个命令直接在交互界面输出（显示当前目录），而第二个命令不会在交互界面输出，因为指定让ls的标准输出1不要再指向屏幕了，而是换了一下映射，输出到了ls.out中。<br>第三条命令从ooxx.txt中标准读入，再标准输出到cat.txt中。<br>其实我们就把原来程序中硬编码的东西改变掉了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ read a</span><br><span class="line">$ echo $a</span><br><span class="line">$ read a 0&lt; cat.txt</span><br></pre></td></tr></table></figure>

<p>执行上面<strong>第一个命令</strong>后，阻塞等待用户。实际上read的0是键盘输入，直到遇到回车换行结束。并把内容输出到a中。用<strong>第二个命令</strong>进行查看输入的内容。<strong>第三个命令</strong>不会阻塞等待用户，因为直接从cat.out读取。不过因为读到换行符就结束了，所以只有第一行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls .&#x2F; &#x2F;ooxx</span><br><span class="line">$ ls .&#x2F; &#x2F;ooxx 1&gt; ls01.out 2&gt;ls02.out</span><br><span class="line">$ ls .&#x2F; &#x2F;ooxx 1&gt; ls03.out 2&gt;ls03.out</span><br></pre></td></tr></table></figure>
<p>执行上面<strong>第一个命令</strong>后，会显示当前目录，同时报错找不到ooxx。<br>执行上面<strong>第二个命令</strong>后，意味着将当前目录输入到ls01.out，/ooxx的报错输入到ls02.out<br>执行<strong>第三个命令</strong>，默认覆盖输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls .&#x2F; &#x2F;ooxx 1&gt; ls04.out 2&gt;&amp; 1</span><br></pre></td></tr></table></figure>
<p>执行上面命令后，可以将俩个输出都放到一个文件中（不被覆盖）<br>如果重定向描述符在右边，需要在前面加一个<code>&amp;</code>。<br>且重定向符的绑定是有顺序的。</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道的目的是，前面的输出作为后面的输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ head -n text.txt</span><br><span class="line">$ tail -n text.txt</span><br></pre></td></tr></table></figure>
<p>上面<strong>第一个命令</strong>，可以连续读出text.txt文件的前n行；上面<strong>第二个命令</strong>，可以连续读出text.txt文件的后n行，如果要读出确定的第n行，需要用到管道。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ head -8 text.txt | tail -1</span><br></pre></td></tr></table></figure>
<p>先把前8行拿出来，然后交给<code>tail -1</code>，即可显示第8行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ x &#x3D; 100</span><br><span class="line">$ echo $x</span><br><span class="line">100</span><br><span class="line">$ &#x2F;bin&#x2F;bash</span><br><span class="line">$ echo $x</span><br><span class="line">$ export x</span><br></pre></td></tr></table></figure>
<p>正常来说，父子进程是会变量隔离的，所以在一个bash里面启动子bash，再读x是读不出来的。<br>export x 让x具备环境变量导出能力，它的任何子进程再执行echo $x，就可以读取变量x。</p>
<p>所以配置有时候需要环境变量（加上export），否则这些变量只在当前进程中有用。</p>
<h4 id="指令块"><a href="#指令块" class="headerlink" title="指令块"></a>指令块</h4><p><code>{</code>、<code>}</code>相当于一个指令，括号需要与其他字符分开，括号内可以放很多东西。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ &#123; echo &quot;sdfsdf&quot;; echo &quot;123&quot;; &#125;</span><br><span class="line">sdfsdf</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>易错问题</strong></font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ a&#x3D;1</span><br><span class="line">$ echo $a</span><br><span class="line">1 </span><br><span class="line">$ &#123; a&#x3D;9; echo &quot;sdfsdf&quot; &#125; | cat</span><br><span class="line">sdfsdf</span><br><span class="line">$ echo $a</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>bash是个解释执行的程序体系，不会先看到管道的。当看到管道的时候，会先在左边启动一个子进程，右边再启动一个子进程， 并让两个子进程输入输出通过管道pipipeline对接。<br>等到第三个命令结束后，又回到父进程，所以<code>a=9</code>已经没了，还是<code>a=1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $$</span><br><span class="line">4398</span><br><span class="line">$ echo $$ | cat</span><br><span class="line">4398 </span><br><span class="line">$ echo $BASHPID | cat</span><br><span class="line">4496</span><br></pre></td></tr></table></figure>
<p>之前说，<code>$$</code>和<code>$BASHPID</code>都可以取出id号。区别：<br>先看到<code>$$</code>，扩展成父进程id 4398，然后才看到管道。然后左边起一个进程，右边起一个进程。左边的<code>$$</code>已经是4398字符串了，直接输出。<br>而<code>$BASHPID</code>，先看到管道。再看到前面的，所以扩展为了4496被输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $$</span><br><span class="line">4398</span><br><span class="line">$ &#123; echo $BASHPID ; read x; &#125;  | &#123; cat; echo $BASHPID ; read y; &#125;</span><br><span class="line">4512</span><br></pre></td></tr></table></figure>
<p>另开一页去访问这台服务器，确定4512是管道左边的子进程，是4398的子进程。<code>$ ps -fe | grep 4398</code><br><code>$ cd /proc/4512/fd</code> ，<code>$ cd /proc/4513/fd</code>，<code>$ lsof -op 4512</code> <font color=red>可以看到4512的1是管道，4513的0是管道。</font></p>
<p><strong>为什么使用buffer的IO要比不使用的快？</strong></p>
<p> <img src="https://img-blog.csdnimg.cn/20201112190029419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>系统IO原理</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>内核分类</title>
    <url>/2020/09/21/%E5%86%85%E6%A0%B8%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>BIOS芯片–&gt;UEFI(unified extensible fireware interface)<br>bootloader放在硬盘第一个扇区(Master Boot Record)<br>CMOS芯片:<br>存一些可以配置的信息，比如开机密码。<br>必须要一直通电。（电脑里有一块内置电池）</p>
<p>工作过程：通电-&gt;bios/uefi工作-&gt;自检-&gt;到固定位置加载boot-&gt; 读取可配置信息 -&gt; CMOS</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><blockquote>
<p>harmony：</p>
</blockquote>
<ul>
<li>微内核（核心）<br>半成品 混合内核 Linux + LiteOS + …</li>
</ul>
<p>操作系统：承上启下，管理硬件，管理应用</p>
<p><strong>内核(kernel)</strong>：管理硬件<br>微内核：主要一件事：应用程序的调度。<br>万物互联IOT：不同部件内存大小不同，执行速度不同。而微内核部署起来非常灵活（弹性部署）<br><img src="https://img-blog.csdnimg.cn/20200921191156502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>宏内核：访问硬件上的东西效率很高，因为都在一起。但物联网行业，如果都装到一块内存，消耗太大。<br><img src="https://img-blog.csdnimg.cn/20200921191338727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>外核</strong><br>存在于实验室中<br>为不同的应用<strong>定制</strong>自己的操作系统</p>
<p>补充：<br><strong>VMM</strong>（virtual machine monitor）<br>解决硬件资源过剩<br><img src="https://img-blog.csdnimg.cn/20200921193229144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p>linux 内核跑在ring 0级，用户程序跑在ring 3。<br>内核执行操作–&gt;200多个系统调用 直接执行不了。<br>注：JVM -&gt; 站在OS老大的角度，就是个普通程序</p>
]]></content>
      <categories>
        <category>硬件基础知识</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>内核同步机制</title>
    <url>/2020/10/05/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="同步理论的基本概念"><a href="#同步理论的基本概念" class="headerlink" title="同步理论的基本概念"></a>同步理论的基本概念</h2><p>•临界区（critical area）: 访问或操作共享数据的代码段<br> 简单理解：synchronized大括号中部分（原子性）</p>
<p>•竞争条件（race conditions）两个线程同时拥有临界区的执行权</p>
<p>•数据不一致：data unconsistency 由竞争条件引起的数据破坏</p>
<p>•同步（synchronization）避免race conditions</p>
<p>•锁：完成同步的手段（门锁，门后是临界区，只允许一个线程存在）<br> 上锁解锁必须具备原子性</p>
<p>•原子性（Atomicity像原子一样不可分割的操作）</p>
<p>•有序性（Ordering禁止指令重排）</p>
<p>•可见性（Visibility一个线程内的修改，另一个线程可见）</p>
<p>互斥锁 排他锁 共享锁 分段锁</p>
<h2 id="内核同步常用方法"><a href="#内核同步常用方法" class="headerlink" title="内核同步常用方法"></a>内核同步常用方法</h2><ol>
<li><p>原子操作 – 内核中类似于AtomicXXX，位于&lt;linux/types.h&gt;</p>
</li>
<li><p>自旋锁 – 内核中通过汇编支持的cas，位于&lt;asm/spinlock.h&gt;<br>Java中的Atomic是由自旋锁来实现的，内核中不需要。<br>自旋锁需要自旋，是占用CPU空间的</p>
</li>
<li><p>读-写自旋 – 类似于ReadWriteLock，可同时读，只能一个写<br>读的时候是共享锁，写的时候是排他锁</p>
</li>
<li><p>信号量 – 类似于Semaphore(PV操作 up down操作 占有和释放）<br>重量级锁，线程会进入wait，适合长时间持有的锁情况<br>Java中的Semaphore也用的是自旋</p>
</li>
<li><p>读-写信号量 – downread upread downwrite upwrite<br>（多个写，可以分段写，比较少用）(分段锁）</p>
</li>
<li><p><strong>互斥体(mutex)</strong> – 特殊的信号量（二值信号量）</p>
</li>
<li><p><strong>完成变量</strong> – 特殊的信号量（A发出信号给B，B等待在完成变量上）<br>vfork() 在子进程结束时通过完成变量<strong>叫醒</strong>（线程已经在等着了）父进程 类似于(Latch 门栓)<br>内核底层支持，效率很高<br>Java AIO实现，依然用的是epoll，并不是完成变量的模式</p>
</li>
<li><p>BKL：大内核锁（早期，现在已经不用）</p>
</li>
<li><p><strong>顺序锁</strong>（2.6）： – 线程可以挂起的读写自旋锁<br>序列计数器（从0开始，写时增加(+1)，写完释放(+1)，读前发现奇数，说明有写线程，这个值是一个中间状态。可以选择直接用，也可以选择自旋等待，读前读后序列一样，说明没有写线程打断）<br>相对于读的时候是一个自旋锁，可以不停。只有写的时候必须是独占的，可以认为不是互斥的，允许读不允许写。</p>
</li>
<li><p>禁止抢占 – preempt_disable() 确认这个值只有一个CPU使用<br>多处理中断时使用，可以直接用禁止抢占，不用上锁。（单核CPU多线程优化）<br>java中没有对应操作</p>
</li>
<li><p>内存屏障 – 见volatile</p>
</li>
</ol>
]]></content>
      <categories>
        <category>硬件基础知识</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>内核同步</tag>
      </tags>
  </entry>
  <entry>
    <title>创建Netty服务器</title>
    <url>/2021/03/06/%E5%88%9B%E5%BB%BANetty%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h3><p><strong>长连接</strong>：<br>■ 游戏服务器<br>■ 可以主动推送数据；<br>■ 传输二进制数据；<br>■ 占用资源相对较多；</p>
<p><strong>短连接</strong>：<br>■ Web服务器<br>■ 被迫营业（只有客户端请求来了之后，服务器才会推送数据）；<br>■ 传输文本数据；<br>■ 占用资源相对较少；</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>游戏开发入门</category>
      </categories>
      <tags>
        <tag>长短连接</tag>
      </tags>
  </entry>
  <entry>
    <title>centos6.5中利用rpm安装wget报错libc.so.6(GLIBC_2.14)(64bit) is needed by wget-1.14-18.el7_6.1.x86_64</title>
    <url>/2021/02/28/%E5%88%A9%E7%94%A8rpm%E5%AE%89%E8%A3%85wget%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p><strong>报错</strong><br>[root@node01 ~]# rpm -ivh wget-1.14-18.el7_6.1.x86_64.rpm<br>warning: wget-1.14-18.el7_6.1.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY<br>error: Failed dependencies:<br>    libc.so.6(GLIBC_2.14)(64bit) is needed by wget-1.14-18.el7_6.1.x86_64<br>    libc.so.6(GLIBC_2.15)(64bit) is needed by wget-1.14-18.el7_6.1.x86_64<br>    libc.so.6(GLIBC_2.17)(64bit) is needed by wget-1.14-18.el7_6.1.x86_64<br>    libpcre.so.1()(64bit) is needed by wget-1.14-18.el7_6.1.x86_64</p>
<p><strong>原因</strong><br>wget-1.14-18.el7_6.1.x86_64.rpm 版本太高了。</p>
<p><strong>解决</strong><br>到<a href="http://rpm.pbone.net/resultsb_dist_79_size_492960_name_wget-1.12-1.4.el6.x86_64.rpm.html" target="_blank" rel="noopener">http://rpm.pbone.net/resultsb_dist_79_size_492960_name_wget-1.12-1.4.el6.x86_64.rpm.html</a> ，在这里下载<code>wget-1.12-1.4.el6.x86_64.rpm</code>，成功。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>rpm</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2021/02/14/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h2><pre><code>反射是Java中最强大的技术之一</code></pre><blockquote>
<p><strong>JAVA反射机制</strong>是在<strong>运行状态</strong>中，对于任意一个<strong>类</strong>，都能够<strong>知道</strong>这个类的所有属性和方法；对于任意一个<strong>对象</strong>，都能够<strong>调用</strong>它的任意一个方法和属性；这种<font color='red'><strong>动态获取的信息以及动态调用对象的方法的功能</strong></font>称为java语言的反射机制。</p>
</blockquote>
<p>举例，扎小人。B扎的是对象A的稻草人，但是反射的是A这个人，A会疼痛。B就是<strong>调用者</strong>。一个东西能够映射到A对象，那个东西就叫做<strong>反射对象</strong>（稻草人）。而这个反射对象在Java中有一个对应的类叫做<code>Class</code>。我们首先要捏小人，捏小人这个过程，就是我们创建Class对象的过程。</p>
<p><img src="https://img-blog.csdnimg.cn/2021021416330518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>反射就是说，我们已经能拿到Class对象了，拿到后我们可以指定操作某一个类里面的成员变量、成员方法、构造方法等。<font color='orange'><strong>前提就是我们必须先获得Class对象。</strong></font></p>
<h2 id="获取Class类的三种方式"><a href="#获取Class类的三种方式" class="headerlink" title="获取Class类的三种方式"></a>获取Class类的三种方式</h2><p>▪ 当用户想要获取任何一个Class类有三种方式：<br>1、通过<code>Class.forName</code>方法来获取对象<br>2、通过<code>类名.class</code>来获取<br>3、通过<code>对象的getClass()</code>来获取<br>4、如果是一个基本数据类型，那么可以通过Type的方式来获取Class对象</p>
<p>▪ 前三种方式的<strong>对比</strong>：<br>– 第一种常用，只需要传入一个类的完全限定名即可<br>– 第二种需要导入对应的包，依赖太强<br>– 第三种已经创建对象，就意味着已经产生了Class类</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//1、通过Class.forName方法来获取对象</span><br><span class="line">//        Class clazz = Class.forName("entity.Emp");</span><br><span class="line">//2、通过类名.class来获取</span><br><span class="line">//        Class&lt;Emp&gt; clazz = Emp.class;</span><br><span class="line">//3、通过对象的getClass()来获取</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 每次在加载我们对象的时候，只要类加载器一旦加载我们class文件了，自然而然就会创建好一个Class对象。</span></span><br><span class="line"><span class="comment">    *  面new了一个新对象，而我已经有了一个Class对象了，相当于充分利用过程。所以不太推荐。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Class clazz = new Emp().getClass();</span><br><span class="line">System.out.println(clazz.getPackage());</span><br><span class="line">System.out.println(clazz.getName());//获取完整名称包名+类名entity.Emp</span><br><span class="line">System.out.println(clazz.getSimpleName()); //Emp</span><br><span class="line">System.out.println(clazz.getCanonicalName());//entity.Emp</span><br><span class="line">// 4、如果是一个基本数据类型</span><br><span class="line">Class&lt;Integer&gt; type1 = Integer.TYPE; </span><br><span class="line">System.out.println(clazz.getName());// int</span><br><span class="line">System.out.println(clazz.getCanonicalName());//int</span><br></pre></td></tr></table></figure>

<p>对于大部分来说，<code>getName()</code>和<code>getCanonicalName()</code>相同。前者返回由类对象表示的实体，后者返回由Java语言规范定义的基础类的规范名称。少部分时候不同，如果是数组就不同。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class type = args.getClass();</span><br><span class="line">System.out.println(type.getName()); <span class="comment">// [Ljava.lang.String;</span></span><br><span class="line">System.out.println(type.getCanonicalName()); <span class="comment">// java.lang.String[]</span></span><br><span class="line"></span><br><span class="line">Class type1 = Integer[]<span class="class">.<span class="keyword">class</span></span>; </span><br><span class="line">System.out.println(type1.getName());<span class="comment">// [Ljava.lang.Integer;</span></span><br><span class="line">System.out.println(type1.getCanonicalName());<span class="comment">// java.lang.Integer[]</span></span><br></pre></td></tr></table></figure>

<h2 id="反射基本用途"><a href="#反射基本用途" class="headerlink" title="反射基本用途"></a>反射基本用途</h2><h3 id="反射的常用api"><a href="#反射的常用api" class="headerlink" title="反射的常用api"></a>反射的常用api</h3><p>▪ <font color='orange'><strong>获取类的成员变量</strong></font><br>获取成员变量，包括子类及父类，同时只能包含公共的类型 <font color='orange'><strong>getField</strong></font><br>此方法返回的是当前类（不包括父类）的所有属性，不仅仅是局限于公共访问修饰符，所有的访问修饰符都可以拿到  <font color='orange'><strong>getDeclaredFields</strong></font> </p>
<p>▪ <font color='orange'><strong>获取类的成员方法</strong></font><br>获取该对象的普通方法,包含的方法范围是当前对象及父类对象的所有公共方法 <font color='orange'><strong>getMethods</strong></font><br>获取当前类中所有的方法，无论什么访问修饰符 <font color='orange'><strong>getDeclaredMethods</strong></font> </p>
<p>▪ <font color='orange'><strong>获取类的构造方法</strong></font><br>构造方法比较特殊，它不能进行一个继承。<br>&emsp;只能获取公有的构造方法 <font color='orange'><strong>getConstructors</strong></font><br>&emsp;获取所有构造方法，无论是私有还是公有 <font color='orange'><strong>getDeclaredConstructors</strong></font> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"reflect.Student"</span>);</span><br><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">System.out.println(field);</span><br><span class="line">System.out.println(field.getName());</span><br><span class="line">System.out.println(field.getType());</span><br><span class="line">System.out.println(field.getModifiers()); <span class="comment">// 访问修饰符  public在常量表中对应public</span></span><br><span class="line">System.out.println(<span class="string">"--------"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">System.out.println(declaredField.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    System.out.println(method.getName());</span><br><span class="line">&#125;</span><br><span class="line">Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">    System.out.println(declaredMethod.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">    System.out.println(constructor.getName());</span><br><span class="line">&#125;</span><br><span class="line">Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">    System.out.println(declaredConstructor.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射-私有获取和调用"><a href="#反射-私有获取和调用" class="headerlink" title="反射 私有获取和调用"></a>反射 私有获取和调用</h3><p><strong>注意</strong>：</p>
<ol>
<li>反射在一定程度上破坏了封装性，需要合理使用</li>
<li>如果把Student中无参构造方法省略掉，会报错。因为new instance会调用无参构造方法</li>
</ol>
<p><strong>Field</strong><br>1.获取到属性<br>2.创建一个对象<br>3.把属性放到对象中<br>4.强转后直接打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field address = clazz.getDeclaredField(<span class="string">"address"</span>);</span><br><span class="line"><span class="comment">//设置该属性是否能被访问，true能。破坏了封装性</span></span><br><span class="line">address.setAccessible(<span class="keyword">true</span>); <span class="comment">//如果设置允许访问，就可以进行下面操作，不会报错</span></span><br><span class="line">System.out.println(address.getName());</span><br><span class="line">Object o = clazz.newInstance();</span><br><span class="line">address.set(o,<span class="string">"北京市"</span>);</span><br><span class="line">System.out.println(((Student)o).getAddress());</span><br><span class="line"></span><br><span class="line"><span class="comment">//address</span></span><br><span class="line"><span class="comment">//北京市</span></span><br></pre></td></tr></table></figure>
<p><strong>Method</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method add = clazz.getDeclaredMethod(<span class="string">"add"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">add.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object o1 = clazz.newInstance();</span><br><span class="line">add.invoke(o1,<span class="number">123</span>,<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//246</span></span><br></pre></td></tr></table></figure>
<p><strong>constructor</strong><br>如何调用私有的构造方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt; declaredConstructor = clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Student o2 = (Student)declaredConstructor.newInstance(<span class="string">"msb"</span>,<span class="number">23</span>,<span class="string">"java"</span>);</span><br><span class="line">System.out.println(o2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student&#123;className='java', address='null', name='msb', age=23&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程——生产者消费者问题、线程池</title>
    <url>/2021/01/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day07</a></p>
<h3 id="线程的生产者和消费者"><a href="#线程的生产者和消费者" class="headerlink" title="线程的生产者和消费者"></a>线程的生产者和消费者</h3><ol>
<li><p>生产产品，将产品放置到共享空间中</p>
</li>
<li><p>消费者从共享空间中取走产品</p>
</li>
<li><p>如果不加同步，多线程访问的时候，出现了数据安全的问题：<br> 1) 生产者没有生产产品，消费者就可以获取<br> <font color=red>解决：</font><br> 在Goods类中设置一个<strong>flag标志</strong>，代表共享空间中有无商品<br> 当生产者抢占到cpu资源，会判断当前对象是否有值:<br> &emsp;如果有意味着有商品，需要提醒消费者消费，同时当前线程进入阻塞状态，等待消费者取走商品之后再次生产；如果没有，不用进入阻塞状态，直接生产即可.<br> &emsp;如果flag等于false，意味着生产者没有生产商品，此时消费者无法消费，需要让消费者线程进入阻塞状态，等待生产者生产。当有商品之后再开始消费.<br> 【<strong>用wait()和notify()实现</strong>】<br> 2) “旺仔—矿泉水”出现品牌名称不匹配情况（因为不是原子操作）<br> <font color=red>解决：</font>将Consumer类和Producer类中的生产、取走产品操作包装成同步方法放到Goods中，而在Consumer类和Producer类中直接调用Goods中的<code>get()</code>和<code>set()</code>，这样保证了<strong>原子性</strong>。</p>
<p> 现在多使用<font color=red>JUC（Java Util Concurrent）</font>来完成</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Goods&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        ProducerQueue producerQueue = <span class="keyword">new</span> ProducerQueue(blockingQueue);</span><br><span class="line">        ConsumerQueue consumerQueue = <span class="keyword">new</span> ConsumerQueue(blockingQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producerQueue).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumerQueue).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h3><p><strong>为什么需要线程池？</strong><br>线程很占系统资源，如果对线程管理不善，很容易导致系统问题。在大多时并发框架中都会使用线程池来管理线程。<br><strong>好处</strong>：</p>
<ol>
<li>可以<strong>重复利用</strong>已有的线程继续执行任务，避免线程创建和销毁时造成的损耗，可以提高系统响应速度</li>
<li>可以对线程合理管理，根据系统的承受能力调整可运行线程的数量、大小等<img src="https://img-blog.csdnimg.cn/2021012422502739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=80% height=80% align=center></li>
</ol>
<p><strong>注：</strong></p>
<ol>
<li>需要一个阻塞队列来存放我们的对应任务列表。</li>
<li><strong>线程池</strong>是否已满和<strong>核心线程池</strong>是否已满的区别：后者是指我允许创建的最大线程个数是否满了。</li>
<li>如果线程池已满，后面进来的线程怎么处理？那就按照<font color=red><a href="#饱和策略">饱和策略（拒绝策略）</a></font>处理。<br>1）放到队列里<br>2）指定哪些执行哪些不执行<img src="https://img-blog.csdnimg.cn/20210124225558835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=80% height=80% align=center>

</li>
</ol>
<h4 id="线程池分类"><a href="#线程池分类" class="headerlink" title="线程池分类"></a>线程池分类</h4><p><img src="https://img-blog.csdnimg.cn/20210125140511454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>不论是<code>public static ExecutorService newSingleThreadExecutor()</code>，还是<code>public static ExecutorService newFixedThreadExecutor()</code>、<code>public static ExecutorService newCacheThreadExecutor()</code>，里面核心都是 <a href="#线程池的创建"><font color=red><strong>new ThreadPoolExecutor</strong></font></a></p>
<h6 id="newCacheThreadPool"><a href="#newCacheThreadPool" class="headerlink" title="newCacheThreadPool"></a>newCacheThreadPool</h6><p>创建一个<strong>可根据需要创建新线程</strong>的线程池，以前构造的线程可用时会重用它们，并在需要时使用提供的<code>ThreadFactory</code>创建新线程。<br><strong>特征</strong>：</p>
<ol>
<li>线程池中数量不固定，可达到最大值（Integer.MAX_VALUE）</li>
<li>线程池中的线程可进行缓存重复利用回收</li>
<li>当线程池中无可用线程，会创建一个新的</li>
</ol>
<p><strong>例子</strong>：</p>
<details><summary> Task.java</summary>
<pre><code>public class Task implements Runnable {
    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " running");
    }
}</code></pre>
</details>
<details><summary> CacheThreadPoolDemo.java</summary>
<pre><code>/**
 * Executor是所有要执行线程的一个父类，是一个接口
 * ExecutorService是继承于Executor的子接口
 */
public class CacheThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        // ExecutorService从Executor 继承来的方法
        // Task.java是一个继承了Runnable接口的类
        for (int i = 0; i < 20; i++) {
            executorService.execute(new Task());
        }
        // 启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务
        executorService.shutdown();
    }
}</code></pre>
</details>
<details><summary> 运行结果</summary>
<pre><code>pool-1-thread-3 running
pool-1-thread-4 running
pool-1-thread-2 running
pool-1-thread-5 running
pool-1-thread-15 running
pool-1-thread-1 running
pool-1-thread-16 running
pool-1-thread-14 running
pool-1-thread-9 running
pool-1-thread-12 running
pool-1-thread-10 running
pool-1-thread-13 running
pool-1-thread-11 running
pool-1-thread-8 running
pool-1-thread-6 running
pool-1-thread-7 running
pool-1-thread-20 running
pool-1-thread-19 running
pool-1-thread-18 running
pool-1-thread-17 running</code></pre>
</details>

<p><strong>结果</strong>：如果Task.java中加了<code>sleep()</code>,那么运行结果中就就不会出现线程的复用。</p>
<h6 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h6><p><strong>特征</strong>：</p>
<ol>
<li>线程池中线程数量可以指定</li>
<li>线程可以重复被利用，在显示关闭之前，都将一直存在</li>
<li>超出一定量的线程被提交时需要在队列中等待</li>
</ol>
<p><strong>例子</strong>：</p>
<details><summary> FixedThreadPoolDemo.java</summary>
<pre><code>public class FixedThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 20; i++) {
            executorService.execute(new Task());
        }
        executorService.shutdown();
    }
}</code></pre>
</details>
<details><summary> 运行结果</summary>
<pre><code>pool-1-thread-4 running
pool-1-thread-5 running
pool-1-thread-1 running
pool-1-thread-3 running
pool-1-thread-2 running
pool-1-thread-3 running
pool-1-thread-2 running
pool-1-thread-5 running
pool-1-thread-1 running
pool-1-thread-4 running
pool-1-thread-4 running
pool-1-thread-3 running
pool-1-thread-1 running
pool-1-thread-2 running
pool-1-thread-5 running
pool-1-thread-1 running
pool-1-thread-3 running
pool-1-thread-2 running
pool-1-thread-4 running
pool-1-thread-5 running</code></pre>
</details>

<p><strong>结果</strong>：如果Task.java中加了<code>sleep()</code>,可以明显看出，运行时是每五个为一组显示的。因为线程池中只有5个线程。</p>
<h6 id="newSingleThreadPool"><a href="#newSingleThreadPool" class="headerlink" title="newSingleThreadPool"></a>newSingleThreadPool</h6><p><strong>特征</strong>：</p>
<ol>
<li>线程池中数量为1，之后提交的线程将排在队列中依次执行</li>
</ol>
<p><strong>例子</strong>：</p>
<details><summary> SingleThreadPoolDemo.java</summary>
<pre><code>public class FixedThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadPool(5);
        for (int i = 0; i < 20; i++) {
            executorService.execute(new Task());
        }
        executorService.shutdown();
    }
}</code></pre>
</details>
<details><summary> 运行结果</summary>
<pre><code>pool-1-thread-1 running
pool-1-thread-1 running
……
</code></pre>
</details>

<h5 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h5><h6 id="newsingleThreadScheduledExecutor"><a href="#newsingleThreadScheduledExecutor" class="headerlink" title="newsingleThreadScheduledExecutor"></a>newsingleThreadScheduledExecutor</h6><p>创建一个<font color=red>单线程池</font>执行程序，它可以安排在给定延迟后运行命令或者定期执行。<br><strong>特征</strong>：</p>
<ol>
<li>线程池中最多执行1个线程，之后提交的线程活动将会排在队列中依次执行</li>
<li>可以延迟执行，也可以定期执行 </li>
</ol>
<h6 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h6><p>创建一个线程池，它可以安排在给定延迟后运行命令或者定期执行。<br><strong>特征</strong>：</p>
<ol>
<li>线程池中线程数量可指定</li>
<li>可以延迟执行，也可以定期执行 </li>
</ol>
<p><strong>例子</strong>：</p>
<details><summary> ScheduledThreadPoolDemo.java</summary>
<pre><code>public static void main(String[] args) {
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(3);
        System.out.println(System.currentTimeMillis());
        scheduledExecutorService.schedule(new Runnable() {
            @Override
            public void run() {
                System.out.println("延迟3s执行");
                System.out.println(System.currentTimeMillis());
            }
        }, 3, TimeUnit.SECONDS);
        scheduledExecutorService.shutdown();
    }
</code></pre>
</details>
<details><summary> ScheduledThreadPoolDemo.java</summary>
<pre><code>public static void main(String[] args) {
    ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(3);
    System.out.println(System.currentTimeMillis());
    scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
        @Override
        public void run() {
            System.out.println("1----延迟1s执行,每3s执行一次");
            System.out.println(System.currentTimeMillis());
        }
    }, 1, 3,TimeUnit.SECONDS);
}</code></pre>
</details>

<h5 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h5><p><strong>分而治之</strong>：把一个任务差分成n多个任务，最终再汇总到一起。</p>
<h6 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h6><p>创建一个带并行级别的线程池，并行级别决定同一时刻有多少个线程在执行。不传参默认为当前系统的CPU个数<br><strong>特征</strong>：</p>
<ol>
<li>可以设置并行级别parallelism，即默认每时刻只有parallelism个线程同时执行</li>
<li>多CPU充分利用每个CPU的资源，多线程同时并行来进行执行，所以比较耗费电脑中的CPU</li>
</ol>
<h4 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h4><p><mark>注意与线程的生命周期区分！！！</mark><br><img src="https://img-blog.csdnimg.cn/20210125132512638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>运行状态：<font color=red>RUNNING</font> 能接受新任务，也能处理阻塞队列中的任务。</li>
<li>终止状态：<font color=red>TERMINATED</font> 在terminated()执行完后进入该状态，默认terminated()中什么也没做。</li>
</ol>
<p>从运行到终止状态会有三种状态的过渡：</p>
<ol>
<li><font color=red>SHUTDOWN</font>：调用<code>shutdown()</code>切换到SHUTDOWN状态。不能再接受新任务，但能继续处理阻塞队列中保存的任务。</li>
<li><font color=red>STOP</font>：调用<code>shutdownnow()</code>切换到STOP状态。不能再接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</li>
<li><font color=red>TIDYING</font>：最终会进行一个回收工作。<br>SHUTDOWN状态会将当前执行的任务执行完，阻塞队列为空，线程池中工作线程为0，进入TIDYING状态；STOP状态直接将任务都干掉，线程池中工作线程数量为0，进入TIDYING。<br>如果所有任务都已终止，workerCount（有效线程数）为0，线程池进入该状态后会调用<code>terminated()</code>进入TERMINATED状态。</li>
</ol>
<blockquote>
<p><code>shutdown()</code>比<code>shutdownnow()</code>好。<code>shutdownnow()</code>比较暴力。</p>
</blockquote>
<h4 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h4><p>不论是<code>public static ExecutorService newSingleThreadExecutor()</code>，还是<code>public static ExecutorService newFixedThreadExecutor()</code>、<code>public static ExecutorService newCacheThreadExecutor()</code>，里面核心都是 <font color=red><strong>new ThreadPoolExecutor</strong></font><br><img src="https://img-blog.csdnimg.cn/20210126120943473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>ThreadPoolExecutor</strong>中有多个构造方法，但无论是哪个，最终都是调用了7个参数的构造方法。<br><mark>掌握各个参数的含义！</mark></p>
<ol>
<li><strong>int corePoolSize</strong>: 核心线程池数 当前线程池可以容纳的一个标准值。</li>
<li><strong>int maximumPoolSize</strong>：最大线程池数 如果大于核心线程数，小于最大线程池数，就可以接着new Thread来处理我们的任务。</li>
<li><strong>long keepAliveTime</strong>：存活时间 表示对应的存活时间，多长时间把没用的线程销毁</li>
<li><strong>TimeUnit unit</strong> ：存活时间单位 </li>
<li><strong>BlockingQueue<Runnable> workQueue</strong>：阻塞队列  任务处理不过来，暂时把任务放到阻塞队列中，等线程有空闲再来处理</li>
<li><strong>ThreadFactory threadFactory</strong>：工厂模式 里面是创建我们对应的一个线程的  这个代码一般我们不会自己写</li>
<li><strong>RejectedExecutionHandler handler</strong>：<a href="#饱和策略">拒绝策略</a> 超过了最大线程池数，采取的策略</li>
</ol>
<blockquote>
<p>公交车座位<strong>17个</strong>（<font color=red>corePoolSize</font>），但是包括站位最多可以有<strong>37</strong>个（<font color=red>maximumPoolSize</font>）。<br>上班高峰期，所以在车上额外临时加了10个座位，那么此时公交车里面可以坐27人了。而过了高峰期之后，甚至17个都坐不满了。这时候可以撤掉这10个座位，而到撤掉的这段<strong>时间限制</strong>就是<font color=red>keepAliveTime</font>，时间单位是<font color=red>TimeUnit unit</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p><strong>ArrayBlockingQueue</strong></p>
<ol>
<li>基于<strong>数组</strong>实现的阻塞队列。ArrayBlockingQueu内部维护了一个数据缓冲定长数组</li>
<li>如果应用在生产者和消费者这样的应用场景中，它<strong>并不能实现</strong>两者真正意义上的<strong>并行执行</strong>。因为<font color=red>两者共用一个锁对象</font>。</li>
</ol>
<p><strong>LinkedBlockingQueue</strong></p>
<ol>
<li>基于<strong>链表</strong>实现的阻塞队列。内部维护了一个数据缓冲队列(链表实现)。</li>
<li>只有当队列缓冲区达到最大缓存容量时候，才会阻塞生产者队列，直到消费者消费掉一份数据，生产者线程才会被唤醒。</li>
<li>LinkedBlockingQueue之所以能高效处理并发数据，也是因为<font color=red>其对生产者端和消费者端分别采用了独立的锁来控制数据同步</font>,这意味着在高并发情况下，两者<strong>可以并行操作数据</strong>，以此提高整个队列的并发性能。</li>
</ol>
<p><strong>DelayBlockingQueue</strong></p>
<ol>
<li>DelayBlockingQueue中的元素只有当其指定的延迟时间到了，才能获取该元素。</li>
<li><strong>没有大小限制</strong>的队列，因此生产过程永远不会被阻塞，而只有消费才会被阻塞。</li>
<li>使用场景较少，但都很精妙。常见如使用它来管理一个超时未响应的连接队列。</li>
</ol>
<p><strong>PriorityBlockingQueue</strong></p>
<ol>
<li>基于<strong>优先级</strong>的阻塞队列。</li>
<li>PriorityBlockingQueue不会阻塞生产者，只会阻塞消费者。所以要注意生产速度不能快于消费者，否则时间一长，会最终耗尽所有可用的堆内存空间。</li>
<li>内部控制线程同步的锁采用的是公平锁。</li>
</ol>
<p><strong>SynchronousQueue</strong></p>
<ol>
<li>一种无缓冲的等待队列，不可以暂存数据。类似于集市上无中介的直接交易。相对于有缓冲的<strong>BlockingQueue</strong>，少了一个中间商环节。</li>
<li>声明一个SynchronousQueue有两者方式。<br>· <strong>公平模式</strong>：采用公平锁，并配合一FIFO队列来阻塞多余的生产者消费者，从而体现整体的公平策略。<br>· <strong>非公平模式</strong>：采用非公平锁，并配合一LIFO队列来管理多余的生产者消费者，同时来进行一个抢占执行。</li>
</ol>
<blockquote>
<p><mark>ArrayBlockingQueue和LinkedBlockingQueue的区别？</fmark></p>
<ol>
<li>队列中锁的实现不同<br>ArrayBlockingQueue实现的队列中锁没有分离，即生产消费共用一个锁；<br>LinkedBlockingQueue实现的队列中锁是分离的，即生产用的是<code>putLock</code>，消费用的是<code>takeLock</code></li>
<li>队列大小初始化方式不同<br>ArrayBlockingQueue实现的队列中必须指定队列大小；<br>LinkedBlockingQueue实现的队列中可以不指定，但默认是Integer.MAX_VALUE</li>
</ol>
</blockquote>
<h4 id="饱和策略（也称拒绝策略）"><a href="#饱和策略（也称拒绝策略）" class="headerlink" title="饱和策略（也称拒绝策略）"></a>饱和策略（也称拒绝策略）</h4><ol>
<li>AbortPolicy （默认策略）<br>ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出RejectedExcutionException异常</li>
<li>DiscardPolicy<br>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但不抛出异常</li>
<li>DiscardOdestPolicy<br>ThreadPoolExecutor.DiscardOdestPolicy：丢弃队列最前面的任务，然后重新尝试一个新的任务（重复此过程）</li>
<li>CallerRunsPolicy<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务，队列中的任务继续阻塞</li>
</ol>
<p>第一种比较好，通过异常检测机制，检测到满了之后可以相应增加容量进行对应调整。</p>
<h4 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h4><p>在<code>Executor</code>接口中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Executor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c = ctl.get(); <span class="comment">// ct1是一个原子操作</span></span><br><span class="line">    <span class="comment">// 1. 如果工作线程数小于核心线程数(核心线程池没满)</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 创建新线程执行command任务，成功返回</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 创建失败</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 判断缓冲队列是否满了，未满将command存储到阻塞队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * rejectedExecution：当没有更多的线程或队列插槽时，可能会发生调用</span></span><br><span class="line"><span class="comment">         * 如果一个任务是能被加入到队列的，但是我们还需要再次检查是否应该添加线程。因为：</span></span><br><span class="line"><span class="comment">         * 1) 自上次检查以来已有的线程死亡或者自从进入这个方法以来线程池就关闭了。</span></span><br><span class="line"><span class="comment">         * 如果是SHUTDOWN状态，不能再接受新任务，但能继续处理阻塞队列中保存的任务；如果是STOP状态，会中断正在处理任务的线程。</span></span><br><span class="line"><span class="comment">         * 所以我们需要再次检查的状态，如果终止了要回退队列，如果没有增加线程。</span></span><br><span class="line"><span class="comment">         * remove()从队列中移除command后会尝试terminated()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当前运行线程数量为0，移除command</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command); <span class="comment">//为command调用rejectedExecution拒绝任务</span></span><br><span class="line">        <span class="comment">// 工作线程数为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">//使用maximumPoolSize作为约束创建新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 如果一个任务不能被加入到队列(阻塞队列已满)，创建新线程来执行任务</span></span><br><span class="line"><span class="comment">     * 如果不能再增加新的线程（线程池已满），调用拒绝策略RejectedExcutionHandler来处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>workcount是允许启动而不允许停止的线程（核心线程池没满时候创建的线程）</li>
<li>isRunning的是正在运行的线程</li>
</ol>
<p><strong>execute方法执行逻辑</strong>：<br><img src="https://img-blog.csdnimg.cn/20210127140304757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=80% height=80% align=center><br><img src="https://img-blog.csdnimg.cn/20210127140638788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=80% height=80% align=center></p>
<blockquote>
<p>corePoolSize的线程不会被回收吗？<br>如果最大线程数是100，核心线程数为40，意味着这40个线程是不会被回收的，而超出的60个在一定时间后会被回收</p>
</blockquote>
<h4 id="Executor和Submit"><a href="#Executor和Submit" class="headerlink" title="Executor和Submit"></a>Executor和Submit</h4><p>在<code>Executor</code>接口某个对应的子类实现（<code>ExecutorService</code>接口）中，多了几个方法。其中一个就是submit方法。<br>submit是基于方法Executor.execute(Runnable)的延伸，通过创建并返回一个<strong>Future类对象</strong>可用于取消执行和/或等待完成<br>对于Future<V>接口，其方法有：<br><img src="https://img-blog.csdnimg.cn/20210127151503728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>execute方法和submit方法提交的区别：</p>
<ol>
<li>如果execute()提交并不会有<strong>返回值</strong>，而用submit()提交会有Future类返回值。</li>
<li>execute()里面不支持传入Callable接口，而submit()既支持<strong>Callable接口</strong>又支持<strong>Runnable接口</strong>。</li>
</ol>
<blockquote>
<p>用execute方法还是submit方法提交？<br>如果想要返回值，就用execute()，如果不需要返回值，不需要逻辑判断，此时就直接execute()即可。</p>
</blockquote>
<h4 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h4><img src="https://img-blog.csdnimg.cn/20210127151651751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=80% height=80% align=center>

<h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>));</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Math.random());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程——线程与进程，线程的实现方式</title>
    <url>/2021/01/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day07</a></p>
<h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p><strong>程序</strong>：Program，是一个指令的集合</p>
<p><strong>进程</strong>：Process，正在执行中的程序。</p>
<ul>
<li>进程是程序的一次静态执行过程，占用特定地址空间</li>
<li>每个进程是独立的，包括三部分：cpu，data，code</li>
</ul>
<p><strong>线程</strong>：是进程中一个执行路径。</p>
<ul>
<li>又称为<strong>轻量级线程</strong></li>
<li>一个进程可拥有多个<strong>并行</strong>的线程</li>
<li>一个进程中的线程共享相同的内存单元–&gt;可访问相同变量和对象，而且它们从同一个堆中分配对象–&gt;通信、数据交换、同步操作</li>
<li>由于共享资源，所以不需要额外通信机制，线程间切换时候不需要保护、恢复现场，效率就比较高</li>
</ul>
<blockquote>
<p>web服务器：nginx http<br>它们最大的区别在于底层用的I/O模型不同。nginx用的<code>NIO</code>，http用的是<code>BIO</code><br>e.g 四核电脑，同时间只能有四个进程运行。此时同时刻进来了1000个请求。全进来后，四个进程进行抢占。<br>如果是BIO模型：第1个CPU拿第1个请求，第2个拿第2个……第5个只能等待<br>如果是NIO模型：第1个CPU拿第1个请求，第2个拿第2个……第5个进来后会直接进入第1个CPU中，切换成n多个线程来进行一个并行交替执行<br>因此NIO效率是比BIO效率高</p>
</blockquote>
<ul>
<li>程序是进程的一部分，而线程包含于进程。</li>
<li>进程是申请资源的最小单位</li>
<li>程是进程的执行单元，是调度和执行的单位</li>
</ul>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>一个进程至少有一个线程。<br>各个应用程序之间会去抢占cpu资源（一个时间片上一个cpu只能处理一个程序），进程抢占到资源后，每个线程再去抢占cpu资源（所以每次执行顺序不同）<br>自己设置当前线程的优先级，可以提高抢到资源的概率。</p>
<blockquote>
<p>JVM启动的时候会有一个进程java.exe，在该进程中至少有一个线程负责java程序的执行，而且这个线程运行的代码存在于main方法中，该线程称为<strong>主线程</strong>。</p>
</blockquote>
<ul>
<li>进程有独立代码和数据空间（进程上下文），切换开销大</li>
<li>线程间共享代码和数据空间，但有独立的运行栈和程序计数器（PC），切换开销小</li>
</ul>
<h3 id="Java中实现多线程"><a href="#Java中实现多线程" class="headerlink" title="Java中实现多线程"></a>Java中实现多线程</h3><h5 id="创建线程方式一"><a href="#创建线程方式一" class="headerlink" title="创建线程方式一"></a>创建线程方式一</h5><p>在JAVA中负责线程的是<code>Java.lang.Thread</code>这个类</p>
<ul>
<li>可以通过创建Thread的实例来<strong>创建</strong>新线程。</li>
<li>线程代码都要写到<code>run()</code>里面，run()方法称为线程体。</li>
<li>可以通过调用Thread类中<code>start()</code><strong>启动</strong>一个线程。</li>
</ul>
<p>实现多线程的时候：</p>
<ol>
<li>必须继承Thread类</li>
<li>必须重写run方法，指核心执行逻辑</li>
<li>线程启动时，不要直接调用run方法，而是用<strong>start()调用</strong></li>
<li>每次运行相同代码，出来结果可能不一样</li>
</ol>
<h5 id="创建线程方式二"><a href="#创建线程方式二" class="headerlink" title="创建线程方式二"></a>创建线程方式二</h5><p>第二种实现方式：使用了代理设计模式</p>
<ol>
<li>实现Runnable接口</li>
<li>重写run方法</li>
<li>创建Thread对象，将刚刚创建好的runnable的子类实现作为Thread的构造参数</li>
<li>通过thread.start()启动</li>
</ol>
<p><strong>备注</strong>：</p>
<ul>
<li>Thread类是实现了Runnable接口的。由于Runnable接口中没有start方法，所以只能通过Thread来进行启动了。</li>
<li><font color=red>推荐使用第二种方式</font>:<br>1.java是<strong>单继承</strong>，将继承关系留给最需要的类。<br>2.使用Runnable接口不需要给共享变量添加<code>static</code>每次创建一个对象作为共享对象即可。</li>
</ul>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>卖票</p>
<p><strong>方式一创建线程：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>; <span class="comment">// 一共5张票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第"</span> + (ticket--) + <span class="string">"张票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TicketThread t1 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">        TicketThread t2 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">        TicketThread t3 = <span class="keyword">new</span> TicketThread();</span><br><span class="line">        TicketThread t4 = <span class="keyword">new</span> TicketThread();</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-1正在出售第5张票</span><br><span class="line">Thread-0正在出售第5张票</span><br><span class="line">Thread-2正在出售第5张票</span><br><span class="line">Thread-3正在出售第5张票</span><br></pre></td></tr></table></figure>
<p>原因：每次调用run方法时候进行判断，判断完整个程序就结束了<br></p>
<p>如果将if语句包含在一个不小于5次的循环中<details><summary>结果：</summary></p>
<pre><code>Thread-1正在出售第5张票
Thread-3正在出售第5张票
Thread-3正在出售第4张票
Thread-3正在出售第3张票
Thread-3正在出售第2张票
Thread-3正在出售第1张票
Thread-2正在出售第5张票
Thread-2正在出售第4张票
Thread-2正在出售第3张票
Thread-2正在出售第2张票
Thread-2正在出售第1张票
Thread-0正在出售第5张票
Thread-1正在出售第4张票
Thread-0正在出售第4张票
Thread-1正在出售第3张票
Thread-1正在出售第2张票
Thread-0正在出售第3张票
Thread-0正在出售第2张票
Thread-0正在出售第1张票
Thread-1正在出售第1张票
</code></pre>
</details>

<p><strong>原因</strong>（同时也是我们不推荐使用Thread的第二个原因）：<br><strong>创建多对象并不是共享值5。</strong><br>每次进行<code>new TicketThread();</code>时候，都是创建了一个TicketThread对象。这意味着每个对象在进行创建的时候，都要实例化（拥有ticket = 5这样的属性值），即意味着每个堆空间中都有一个5。<br>这意味着，每个对象只是操作我当前堆空间中的值。所以打印结果都是54321这种情况。</p>
<p><strong>尝试解决以上问题</strong>：</p>
<ol>
<li><strong>共享数据，把ticket用static修饰</strong>，static修饰的变量归属于类而不归属于对象，所以不管main中创建多少个对象都无所谓。<br>但是<strong>仍会出问题</strong>。因为<details><summary>可能会出现的情况</summary>
<pre><code>Thread-1正在出售第5张票
Thread-1正在出售第2张票
Thread-3正在出售第3张票
Thread-0正在出售第5张票
Thread-2正在出售第4张票
Thread-1正在出售第1张票</code></pre></details>

</li>
</ol>
<p><strong>方式二创建线程：</strong><br> <details><summary>代码：</summary></p>
<pre><code>public class TicketRunnable implements Runnable{
    private static int ticket = 5; // 一共5张票
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (ticket > 0) {
                System.out.println(Thread.currentThread().getName() + "正在出售第" + (ticket--) + "张票");
            }
        }
    }
    public static void main(String[] args) {
        TicketRunnable ticket = new TicketRunnable();

        Thread t1 = new Thread(ticket);
        Thread t2 = new Thread(ticket);
        Thread t3 = new Thread(ticket);
        Thread t4 = new Thread(ticket);

        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}</code></pre></details>

<p>ticket不加static修饰，也不会出现方式一中那种情况（因为在创建主函数的时候，每次只new了一个对象，所以只有一个5）。虽然还是错误的。</p>
<details><summary>可能会出现的结果</summary>
<pre><code>Thread-0正在出售第3张票
Thread-3正在出售第4张票
Thread-3正在出售第1张票
Thread-1正在出售第3张票
Thread-2正在出售第5张票
Thread-0正在出售第2张票</code></pre></details>

<h5 id="真正解决方法–数据同步"><a href="#真正解决方法–数据同步" class="headerlink" title="真正解决方法–数据同步"></a>真正解决方法–数据同步</h5><p>见 <strong>多线程——线程同步与死锁</strong></p>
<h3 id="线程的代理设计模式"><a href="#线程的代理设计模式" class="headerlink" title="线程的代理设计模式"></a>线程的代理设计模式</h3><p>例如上面<code>Thread t1 = new Thread(ticket);</code>，代理是t1，被代理（实际干活的）是传入的<code>TicketRunnable</code>对象——ticket。<code>t1.start();</code>看上去是执行t1的方法，实际上是在执行ticket中的东西。这就是一个代理模式的实现。<br>具体可参考Day07中proxy（王婆潘金莲西门庆案例）。</p>
<blockquote>
<p>代理模式主要使用了 Java 的多态，干活的是被代理类，代理类主要是<br>接活，你让我干活，好，我交给幕后的类去干，你满意就成，那怎么知道被代理类能不能干呢？同根就成，<br>大家知根知底，你能做啥，我能做啥都清楚的很，同一个接口呗<br>————《设计模式之禅》</p>
</blockquote>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p><strong>五个状态</strong>: 创建 就绪 运行 终止 阻塞<br>线程的<strong>生命周期</strong>：</p>
<ol>
<li><strong>新生状态</strong>：当创建好线程对象后，没有启动之前（调用start方法之前）<br> ThreadDemo = new ThreadDemo();<br> RunnableDemo = new RunnableDemo();<pre><code>有自己的内存空间，但是没有资源</code></pre></li>
<li><strong>就绪状态</strong>：准备开始执行，并没有执行。表示调用start方法之后<br> 当对应的线程创建完成，且调用start方法后，所有的线程会添加到一个就绪队列中，所有线程同时去抢占cpu资源</li>
<li><strong>运行状态</strong>：当前进程获取到cpu资源后，就绪队列中所有的线程会去抢占cpu资源，谁先抢占到谁先执行。在执行的过程就称为运行状态<br> 抢占cpu资源，执行代码逻辑（run中代码）开始，直到等待某资源而阻塞，或完成而死亡。<br> 如果给定时间片内未完成，系统换下回到<strong>等待状态</strong>。</li>
<li><strong>死亡状态</strong>：当运行的进程正常执行完所有的代码逻辑或者因为异常终止程序叫做死亡状态<br>进入方式：<ul>
<li>正常运行完成且结束</li>
<li>人为中断执行，如使用<code>stop()</code></li>
<li>程序抛出未捕获的异常</li>
</ul>
</li>
<li><strong>阻塞状态</strong>：在程序运行过程中，发生某些异常情况导致当前线程无法再顺利进行下去，此时会进入阻塞状态。进入阻塞状态的原因消除之后，所有的阻塞队列会再次进入到<strong>就绪状态</strong>中，随机抢占cpu资源，等待执行<br> 进入方式：<ul>
<li>执行了<code>sleep()</code></li>
<li>等待I/O设备等资源</li>
<li>join方法（代码中执行的逻辑）<br><img src="https://img-blog.csdnimg.cn/20210122151644658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
</ol>
<h3 id="Thread的API方法"><a href="#Thread的API方法" class="headerlink" title="Thread的API方法"></a><code>Thread</code>的API方法</h3><pre><code>见Day07_thread中api包</code></pre><p><img src="https://img-blog.csdnimg.cn/20210123094913437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 获取当前线程对象 静态方法</span></span><br><span class="line">Thread thread = Thread.currentThread();</span><br><span class="line"><span class="comment">// 获取当前线程的名称</span></span><br><span class="line">System.out.println(thread.getName());</span><br><span class="line"><span class="comment">// 获取线程的ID</span></span><br><span class="line">System.out.println(thread.getId());</span><br><span class="line"><span class="comment">// 获取线程的优先级,在一般系统中，范围是0~10的值，默认值5.有些系统是0~100</span></span><br><span class="line">System.out.println(thread.getPriority());</span><br><span class="line"><span class="comment">// 设置线程池的优先级</span></span><br><span class="line">thread.setPriority(<span class="number">1</span>);</span><br><span class="line">System.out.println(thread.getPriority());</span><br><span class="line"><span class="comment">// 判断线程是否存活</span></span><br><span class="line">System.out.println(thread.isAlive());</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p><strong>优先级越高，一定越先执行吗？</strong><br>不。优先级只能反映线程执行紧急程度 , 不能决定是否一定先执行</p>
<p><font color = red>运行态 –&gt; 阻塞态：</font></p>
<ol>
<li><p><code>public final void join()</code><br>描述：调用join方法的线程被强制执行，其他线程处于<strong>阻塞态</strong>，该线程执行完后其他线程再执行</p>
</li>
<li><p><code>public static void sleep(long millis)</code><br>描述：使用该方法的当前线程<strong>被阻塞</strong>，睡眠millis秒</p>
</li>
</ol>
<p><font color = red>运行态 –&gt; 就绪态：</font><br><code>public static void yield()</code><br>描述：当前执行的线程暂停一次，允许其他线程执行，不阻塞，线程进入<strong>就绪态</strong>。如果没有其他等待线程，这时当前线程会<strong>马上恢复执行</strong>。<br>&emsp;只是这次不执行，也可能出现暂停一次后下一次依旧是该线程执行。因为暂停一次后又到了就绪队列抢占资源。</p>
<blockquote>
<p><strong>对象的等待唤醒过程</strong>和<strong>线程的等待唤醒过程</strong>的区别<br><code>Object</code>类包括了等待唤醒方法（<code>notified()</code>和<code>wait()</code>），这是对象的等待唤醒。<br>虽然线程也属于对象，但一般情况下，线程这个类或者线程这个对象，不会被当作一个共享空间。<br>在多线程的时候，可以实现唤醒和等待的过程，但是唤醒和等待操作的对应不是Thread类，而是我们设置的共享对象或者共享变量。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程——线程同步与死锁</title>
    <url>/2021/01/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h3 id="多线程的安全性问题"><a href="#多线程的安全性问题" class="headerlink" title="多线程的安全性问题"></a>多线程的安全性问题</h3><p>多线程的安全性问题其实就是<strong>数据不一致的问题</strong>。类似取钱过程。银行卡中有100块，A正在用卡取出50块（取钱过程比较慢，还没有取完，账户上的余额显示还没有修改）。此时B也正好在用存折想取出100块。A,B如果都成功了，银行不就亏本了？这种数据不一致的问题银行<font color=orange>不允许出现</font>！<br>怎么解决呢？</p>
<ol>
<li><p>可以规定在取钱过程中只允许一个人操作（<strong>加锁</strong>）。但是会存在问题：如果这个人待了1h，其他人都不能操作，效率低。<br>（见<strong>上机练习</strong>）</p>
</li>
<li><p>无锁机制–比较交换 <strong>CAS</strong>（Compare and Swap）。里面设置了三个值，VEN。</p>
<blockquote>
<p>V表示准备要被更新的变量  实际值<br>E表示我们提供的 期望的值   期望值<br>N表示新值 ，准备更新V的值   改变值</p>
</blockquote>
<p> 每次当E == V时，才能发生改变操作，将N写入V中。<br> 如果 E != V，我们要准备一个新的E去跟V比较，成功后才能更新V。</p>
</li>
</ol>
<h4 id="使用同步解决多线程的安全问题"><a href="#使用同步解决多线程的安全问题" class="headerlink" title="使用同步解决多线程的安全问题"></a>使用同步解决多线程的安全问题</h4><p><strong>同步的前提</strong>：</p>
<ol>
<li>必须是两个及以上的线程使用同一资源</li>
<li>必须保证同步中只能有一个线程在运行</li>
</ol>
<p>卖票案例中，无论是，都存在<strong>数据不一致的问题</strong>。解决方法都是<strong>线程同步（加锁）</strong>。</p>
<blockquote>
<p>例子在<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">GitHub-Day07-thread</a>的<strong>ticket包</strong>中。<strong>多线程——线程与进程，线程的实现方式</strong>文中也有相关描述。</p>
</blockquote>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><ol>
<li><p><font color=red>同步代码块</font><br>Synchronized(共享资源，共享对象，需要是object的子类) {具体执行的代码块}<br><font color=orange>()中的obj称为<strong>同步监视器</strong></font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">200</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// this 表示当前对象</span></span><br><span class="line">               <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第"</span> + (ticket--) + <span class="string">"张票"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color=red>同步方法</font><br>将核心代码逻辑定义成一个方法，使用synchronized关键字修饰<br>不需要自己指定<strong>锁对象</strong>(同步监视器)，因为同步方法的监视器是this，也就是该对象本身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>; <span class="comment">// 一共5张票</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">200</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/** this的意思是sale()已经属于TicketRunnable3这个对象了，而不归于整个类了</span></span><br><span class="line"><span class="comment">            *  this代表的就是synchronized的锁的对象</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">          <span class="keyword">this</span>.sale();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第"</span> + (ticket--) + <span class="string">"张票"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210124090654510.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul>
<li>同步可以保证资源共享操作的正确性，但过多同步可能产生死锁</li>
<li>死锁一般情况下表示互相等待</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>常用类</title>
    <url>/2021/02/03/%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day04</a></p>
<h3 id="基本数据类型的包装类"><a href="#基本数据类型的包装类" class="headerlink" title="基本数据类型的包装类"></a>基本数据类型的包装类</h3><p>基本数据类型四类八种：<br><img src = "https://img-blog.csdnimg.cn/2021020311361947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=70% height=70% align=center></p>
<p>包装类位于“java.lang”包中，将基本类型封装成一个类，里面包含对应属性和方法。<br><img src="https://img-blog.csdnimg.cn/20210203144046165.png" alt="在这里插入图片描述"><br>注意：</p>
<ol>
<li><p>使用中会涉及自动装箱和拆箱。<br>装箱：基本数据类型–&gt;包装类，本质上调用了valueOf()<br>拆箱相反。本质上调用了intValue()</p>
</li>
<li><p>常量池在1.7之后，放置在了堆空间之中</p>
</li>
</ol>
<h3 id="String的使用详解"><a href="#String的使用详解" class="headerlink" title="String的使用详解"></a>String的使用详解</h3><p>常量池在1.7之后，放置在了堆空间之中。</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>String str = “abc”;<br>String str2 = new String(“abc”);<br>第一种使用比较多。</p>
<p>String类中对象两种实例化的区别：<br>1.直接赋值只会开辟一块堆内存空间，且字符串对象可以保存在对象池中以供下次使用；<br>2.采用构造方法会开辟两块堆内存空间，使用intern()方法后可以手工入池。</p>
<h5 id="字符串的本质"><a href="#字符串的本质" class="headerlink" title="字符串的本质"></a>字符串的本质</h5><ol>
<li>字符串本质是字符数组或者叫字符序列</li>
<li>String类是一个final类。所以不可以被继承</li>
<li>使用equals方法比较的是字符数组的每一个位置的值</li>
<li>hashCode方法<br>源码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
31 = (11111)B，首先要选择一个质数，每次进行乘积的时候，相当于进行一个移位操作。移位运算是比较快的，保证计算哈希值的时候最快的方式。</li>
<li>String是个不可变对象。<br>String类中，有<code>private final char value[]</code>。所谓的不可变对象指的是里面的数组的<strong>引用</strong>不可变，而并不是指数组内容不可变。</li>
</ol>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ol>
<li>char charAt(int index)<br>返回字符串中第index个字符。</li>
<li>boolean equals(String other)<br>如果字符串与other相等，返回true</li>
<li>boolean equalsIgnoreCase(String other)<br>如果字符串与other相等（忽略大小写），则返回true</li>
<li>int indexOf(String str)<br>返回str第一个字符的下标</li>
<li>lastIndexOf(String str,int fromIndex)<br>返回指定子字符串的最后一次出现的字符串中的索引，从指定的索引开始<strong>反向搜索</strong>。</li>
<li>int length()<br>返回字符串的长度。</li>
<li>String replace(char oldChar,char newChar)<br>返回一个新串，它是通过用 newChar 替换此字符串中出现的所有oldChar而生成的</li>
<li>boolean startsWith(String prefix)<br>如果字符串以prefix开始，则返回true</li>
<li>boolean endsWith(String prefix)<br>如果字符串以prefix结尾，则返回true</li>
<li>String substring(int beginIndex)<br>String substring(int beginIndex,int endIndex)<br>返回一个新字符串，该串包含从原始字符串beginIndex到串尾或endIndex-1的所有字符（<strong>左闭右开</strong>）</li>
<li>String toLowerCase()<br>返回一个新字符串，该串将原始字符串中的所有大写字母改成小写字母</li>
<li>String toUpperCase()<br>返回一个新字符串，该串将原始字符串中的所有小写字母改成大写字母</li>
<li>String trim()<br>返回一个<strong>新字符串</strong>，该串删除了原始字符串头部和尾部的空格</li>
</ol>
<h3 id="StringUtils工具类"><a href="#StringUtils工具类" class="headerlink" title="StringUtils工具类"></a>StringUtils工具类</h3><p>字符串工具类，提供一些字符串相关的便捷方法<br>具体见《StringUtils工具类的使用》</p>
<h3 id="DateUtils工具类"><a href="#DateUtils工具类" class="headerlink" title="DateUtils工具类"></a>DateUtils工具类</h3><p>日期操作工具类<br>具体见《DateUtils工具类的使用》</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>异常+常用类</category>
      </categories>
      <tags>
        <tag>常用类</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2021/01/19/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day04</a></p>
<h3 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h3><p>程序运行过程中出现的不正常情况<br><strong>注意</strong>：</p>
<ol>
<li>相同代码在运行的时候，根据输入参数或者操作不同，可能会也可能不会发生异常，应该在写代码过程中尽量保证代码的正确性，不要到处是bug。</li>
<li>如果要解决代码中的异常，需要添加非常复杂的代码逻辑判断，代码会臃肿且要花大精力处理bug还不一定能解决。因此推荐使用<strong>异常机制</strong>来处理。</li>
<li>程序在运行过程中如果出现问题，会导致后面的代码无法正常执行，而使用异常机制后，可以对异常进行处理，同时后续的代码会继续执行，不会中断整个程序。</li>
<li>在异常处理过程中，不要只是简单地输出错误，要尽可能将详细异常进行输出<br><code>void printStackTrace()</code>:打印异常的堆栈信息，可以从异常信息的最后一行开始追踪，寻找自己编写的Java类<br><code>String printMessage()</code>:返回异常信息描述字符串，是printStackTrace()输出信息的一部分<br><font color="red">printStackTrace()更常用，因为更详细，会提供错误提示。</font></li>
</ol>
<p><strong>调用方法输出异常信息</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210203112120702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>使用异常机制为程序提供了错误处理的能力。</p>
<ol>
<li>预先设置好对付异常的处理方法</li>
<li>程序运行</li>
<li>遇到异常</li>
<li>对异常进行处理</li>
<li>处理完毕，程序<strong>继续运行</strong></li>
</ol>
<h5 id="Java中如何进行异常处理"><a href="#Java中如何进行异常处理" class="headerlink" title="Java中如何进行异常处理"></a>Java中如何进行异常处理</h5><p>Java的异常处理是通过<font color="red"><strong>5个关键字</strong></font>来实现的：try、catch、finally、throw、throws</p>
<p>异常处理的<font color="red"><strong>三种方式</strong></font>：</p>
<ol>
<li><p><strong>捕获异常</strong> try-catch-finally<br>try{代码逻辑}catch(Exception){异常处理逻辑}<br>· try中一旦遇到异常，之后的代码不会再执行<br>· 尽量包含少的代码进行捕获<br>执行过程中，可能存在的情况：<br>1）正常执行，只执行try中代码<br>2）遇到异常情况，会处理try中异常代码之前的逻辑，后面不会执行，最后会执行catch<br>3）使用多重catch的时候，会遇到异常子类不匹配的情况，此时依然会报错，因此建议在catch最后将<strong>所有异常的父类</strong>写上</p>
<p>finally:在程序运行过程中，如果处理异常的部分包含finally的处理，那么无论代码是否发生异常，finally内<strong>内容总会执行</strong>。<br>finally包含的处理逻辑？<br>1）IO流的关闭操作<br>2）数据库的连接关闭操作<br><strong>注意</strong>：当使用多重catch时一定要注意相关异常的程序，将子类放在最前面的catch，父类放在后面的catch</p>
</li>
<li><p><strong>声明异常</strong> throws Exception<br>1）多个异常用逗号隔开<br>2）在异常情况出现的时候，可以使用try-catch-finally的方法处理异常，也可以将异常向外抛出，由外部进行处理。<br>3）在方法调用过程中，可能存在n多个方法之间的调用。此时假如每个方法中都包含了异常情况，那么就需要在每个方法中都进行try-catch。另外一种比较简单的方式，就是在方法最外层调用处理一次即可。使用throws方法，对所有执行过程中的所有方法出现的异常进行统一集中处理。</p>
<blockquote>
<p><strong>如何判断使用try catch还是throws？</strong><br>最稳妥方式是在每个方法中都进行异常的处理。<br>偷懒的方式是判断在整个调用的过程中，外层的调用方法是否有对异常的处理。如果有直接使用throws，如果没有，就要使用try catch。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      test4(); <span class="comment">// 如果只是throws，会直接抛给JVM，不会继续打印hehe</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">"hehe"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   System.out.println(<span class="number">1</span>/<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   test1();</span><br><span class="line">   System.out.println(<span class="number">100</span>/<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   test2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   test3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<blockquote>
<p>java.lang.ArithmeticException: / by zero<br>at demo.Exception2.test1(Exception2.java:43)<br>at demo.Exception2.test2(Exception2.java:46)<br>at demo.Exception2.test3(Exception2.java:50)<br>at demo.Exception2.test4(Exception2.java:53)<br>at demo.Exception2.main(Exception2.java:24)<br>hehe</p>
<p>Process finished with exit code 0</p>
</blockquote>
<p>如果main中不使用try catch，而是声明异常，结果和对代码块不进行任何处理结果一样：</p>
<blockquote>
<p>java.lang.ArithmeticException: / by zero<br>at demo.Exception2.test1(Exception2.java:43)<br>at demo.Exception2.test2(Exception2.java:46)<br>at demo.Exception2.test3(Exception2.java:50)<br>at demo.Exception2.test4(Exception2.java:53)<br>at demo.Exception2.main(Exception2.java:24)</p>
<p>Process finished with exit code 1</p>
</blockquote>
</li>
<li><p><strong>抛出异常</strong> throw</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Exception2.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      show();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">"hehe"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">   String gender=<span class="string">"1234"</span>;</span><br><span class="line">   <span class="keyword">if</span> (gender.equals(<span class="string">"man"</span>)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"man"</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gender.equals(<span class="string">"woman"</span>)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果错误向外抛，main中会对异常进行捕获，捕获的异常信息就是下面这句话</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"性别出现错误"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<blockquote>
<p>java.lang.Exception: 性别出现错误<br> at demo.Exception2.show(Exception2.java:38)<br> at demo.Exception2.main(Exception2.java:24)<br>hehe</p>
</blockquote>
<p><strong>自定义异常</strong><br>在Java的API中提供了丰富异常类，但有时候不满足需求，就需要自定义。</p>
<p><strong>步骤</strong>：<br> 1.继承Exception类<br> 2.自定义实现构造方法<br> 3.需要使用的时候，使用throw new自定义异常的名称</p>
<blockquote>
<p>什么时候需要自定义异常？<br>一般情况下不需要，但在公司要求明确，或者要求异常格式规范统一的时候是要自己实现的</p>
</blockquote>
<p><strong>案例</strong>：<br>自定义一个异常类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenderException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">GenderException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"性别异常"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">GenderException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">     System.out.println(msg);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Exception2.java中，修改else块内容为<code>throw new GenderException(&quot;Gender is wrong&quot;);</code><br>结果：</p>
<blockquote>
<p>Gender is wrong<br>hehe<br>demo.GenderException<br> at demo.Exception2.show(Exception2.java:40)<br> at demo.Exception2.main(Exception2.java:24)</p>
</blockquote>
</li>
</ol>
<h4 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h4><p>所有异常的父类是<code>Throwable</code>，子类分为<code>Error</code>和<code>Exception</code>。<br><strong>Error</strong>：系统级的错误。代码层面无法解决的问题称为“Error”。<br><strong>Exception</strong>：代码层面解决的错误。</p>
<ol>
<li>CheckedException 编译时异常<br>当编写的时候，IDE帮你进行自动编译的时候，划波浪线，自动提示出错，属于<strong>编译时异常</strong>。<br>必须捕获或者声明抛出</li>
<li>RuntimeException 运行时异常<br>运行时可能出错可能不出错（例如参数的输入不同导致结果正确与否）<br>不要求捕获或者声明抛出，但尽可能做到减少运行时异常<img src="https://img-blog.csdnimg.cn/2021020311220445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=50% height=50% align=center>

</li>
</ol>
<h4 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h4><ol>
<li><p>try-catch块中存在return语句，是否还执行finally块，如果执行，说出执行顺序<br>return关键字：1.返回对应的结果值 2.中断/关闭当前的程序<br>1）try中有return，finally中没有return<br> <img src="https://img-blog.csdnimg.cn/2021020223224277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> “return num+=80”被拆分成“num+=80”和“return num”，先执行try中的“num+=80”，将结果保存起来，在try中“return num”执行前，先将finally中语句执行完，再将90返回。</p>
<p> 2）try和finally中均有return<br> <img src="https://img-blog.csdnimg.cn/20210202233132227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> try中语句同样被拆分了，finally中的“return num”语句先于try中的“return num”语句执行，因此try中的“return num”被“覆盖”了，不再执行。</p>
<p> 3）try里面和finally外面均有return，return的数据是<strong>基本数据类型或文本字符串</strong><br> <img src="https://img-blog.csdnimg.cn/20210202233844872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 虽然在finally中改变了返回值num，但因为finally中没有return该num值，所以在执行完finally中的语句后，test()会得到try中返回的num值，而try中的num依然是程序进入finally代码块前保留下来的值。<br> <font color="red">如果try中改成“return num+=80;”，最后结果10变成了90。</font></p>
<p> 4）try里面和finally外面均有return，return的数据是<strong>引用数据类型</strong><br> <img src="https://img-blog.csdnimg.cn/20210203001513994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  <font color="red"><strong>总结</strong>：</font><br> &emsp;try语句在返回前，将其他所有的操作执行完，保留好要返回的值，而后转入执行finally中的语句，而后分为<strong>3种情况</strong>：</p>
<ol>
<li>如果finally中有return语句，则会将try中return语句“覆盖”掉，直接执行finally中的return语句，得到返回值，这样便无法得到try之前保留好的返回值。</li>
<li>如果finally中没有return语句，也没有改变要返回的值，则执行完finally中的return语句后，会接着执行try中的return语句，返回之前保留的值。</li>
<li>如果finally中没有return语句，但是改变了要返回的值，这里有的类似于引用传递和值传递的区别，分为以下<strong>两种情况</strong>：<br>&emsp;① 如果return的数据是<strong>基本数据类型或文本字符串</strong>，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前的值。<br>&emsp;② 如果return的数据是<strong>引用数据类型</strong>，则在finally中对引用该数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中<strong>改变后的</strong>该属性的值。</li>
</ol>
</li>
<li><p>try-catch-finally块中，finally唯一不执行的情况是什么？<br>1）try之前异常，系统报错,当然不会执行finally<br>2）try 或 catch块中，如果调用了退出虚拟机的方法（即System.exit(1);）会使程序提前退出</p>
</li>
<li><p>说出五个常见的运行时异常<br>空指针异常，算数异常，数组下标越界异常，字符串下标越界异常，数字格式转换异常</p>
</li>
<li><p>throw和throws的比较<br>异：<br>1）throws用来声明异常；throw用来抛出异常。<br>2）throw位于函数体内，当程序出现某种逻辑错误时由程序员主动<strong>抛出了</strong>某种特定类型的异常；throws必须跟在方法参数列表的后面，表示该方法<strong>可能</strong>要抛出异常。<br>3）throw抛出一个异常对象，且只能是一个；throws后面跟异常类，而且可以有多个。<br>同：<br>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>异常+常用类</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库连接池（druid，hikariCP）</title>
    <url>/2021/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%88druid%EF%BC%8ChikariCP%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Druid-德鲁伊"><a href="#Druid-德鲁伊" class="headerlink" title="Druid 德鲁伊"></a>Druid 德鲁伊</h2><p><a href="https://github.com/alibaba/druid" target="_blank" rel="noopener">https://github.com/alibaba/druid</a></p>
<p>Druid是Java语言中最好的数据库连接池。Druid能提供强大的监控和扩展功能。</p>
<p>DruidDataSource配置<br><a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE</a></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#驱动名称</span></span><br><span class="line"><span class="comment">#driverClassName=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#url</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/demo</span></span><br><span class="line"><span class="comment">#用户名</span></span><br><span class="line"><span class="meta">username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#密码</span></span><br><span class="line"><span class="meta">password</span>=<span class="string">512</span></span><br><span class="line"><span class="comment">#配置初始化大小、最小、最大</span></span><br><span class="line"><span class="meta">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">minIdle</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置监控系统拦截的filters：监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</span></span><br><span class="line"><span class="meta">filters</span>=<span class="string">stat</span></span><br><span class="line"><span class="comment">#配置获取连接等待超时的时间</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment">#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line"><span class="meta">timeBetweenEvictionRunsMillis</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment">#配置一个连接在池中最小的生存的时间，单位是毫秒</span></span><br><span class="line"><span class="meta">minEvictableIdleTimeMillis</span>=<span class="string">600000</span></span><br><span class="line"><span class="meta">maxEvictableIdleTimeMillis</span>=<span class="string">900000</span></span><br><span class="line"><span class="comment">#建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</span></span><br><span class="line"><span class="meta">testWhileIdle</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</span></span><br><span class="line"><span class="meta">testOnBorrow</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</span></span><br><span class="line"><span class="meta">testOnReturn</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</span></span><br><span class="line"><span class="meta">poolPreparedStatements</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</span></span><br><span class="line"><span class="meta">maxOpenPreparedStatements</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#asyncInit是1.1.4中新增加的配置，如果有initialSize数量较多时，打开会加快应用启动时间</span></span><br><span class="line"><span class="meta">asyncInit</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h2 id="HikariCP"><a href="#HikariCP" class="headerlink" title="HikariCP"></a>HikariCP</h2><p><a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">https://github.com/brettwooldridge/HikariCP</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计三范式</title>
    <url>/2021/02/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>◼ 数据库的设计主要包含了设计表结构和表之间的联系，在设计的<br>过程中，有一些规则应该遵守，这些规则就叫范式。<br>◼ 三范式是为了<font color='red'><strong>减少数据冗余</strong></font>而存在的。</p>
<h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>▪ 第一范式(确保每列保持<font color='red'><strong>原子性</strong></font>)<br>▪ 如果数据库表中的所有字段值都是<strong>不可分解的原子值</strong>，就说明该数据库表满足了第一范式。<br>▪ <font color='purple'><strong>列不可分</strong></font><br><strong>例1</strong>：<br>如果这些人都住在一个小区，那么address就出现冗余。而改为第二种，占的空间就会小。满足第一范式。<br><img src="https://img-blog.csdnimg.cn/20210213120119960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>例2</strong>：<br>地址：省 市 区 街道<br>如果系统经常会访问“地址”属性中的“城市”部分，<br>那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。</p>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>◼ 满足第二范式（2NF）必须先满足第一范式（1NF）<br>◼ 确保表中的每列都和主键相关，而不能只与主键的某一部分相<br>关（主要针对联合主键而言）。<br>◼ <font color='purple'><strong>不能部分依赖,列必须直接依赖主键</strong></font>。<br><img src="https://img-blog.csdnimg.cn/20210213163717843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>进行一个表分解：<br><img src="https://img-blog.csdnimg.cn/20210213163802451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果在进行表设计的时候，那些列如果可以单独地构成一张新的实体，或新的一张表的时候，就把那一部分拿出来，成一张新的表，再建立一些关系在里面，这就是<strong>第二范式</strong>。</p>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>▪ 满足第三范式（3NF）必须先满足第二范式（2NF）<br>▪ 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关<br>▪ <font color='purple'><strong>不能存在传递依赖</strong></font>。<br>比如下面就满足第三范式。客户名称和客户编号是强依赖关系，但和订单编号不是。如果客户名称跟在订单信息表后面，那么就出现了传递依赖，<br><img src="https://img-blog.csdnimg.cn/20210213164453257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>三范式呈现到数据库中就是表依赖关系。 </p>
<blockquote>
<p>表依赖关系<br>一对一： 身份证<br>一对多： 老师对学生<br>多对多： 一个学生有多门课，课有多个学生</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库设计</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和List互转</title>
    <url>/2020/11/18/%E6%95%B0%E7%BB%84%E5%92%8CList%E4%BA%92%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="数组转List"><a href="#数组转List" class="headerlink" title="数组转List"></a>数组转List</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把当前整体的对象转成一个集合</span></span><br><span class="line"><span class="comment">// int[] array = new int[] &#123;1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment">// List&lt;int[]&gt; ints =  Arrays.asList(array);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把多个元素转成对应的List</span></span><br><span class="line">List&lt;Integer&gt; ins = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="List转数组"><a href="#List转数组" class="headerlink" title="List转数组"></a>List转数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] obj = ins.toArray();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>Java集合框架</category>
      </categories>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>斜杠在git bash中的使用</title>
    <url>/2020/06/22/%E6%96%9C%E6%9D%A0%E5%9C%A8git%20bash%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="进入目录"><a href="#进入目录" class="headerlink" title="进入目录"></a>进入目录</h3><p>假设进入D:\Sublime Text3\py<br><strong>方法一：相对地址</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cd d：   <span class="comment">//进入d盘</span></span><br><span class="line">$ cd Sublime\ Text3/py   <span class="comment">//正斜杠+空格是空格转义符</span></span><br></pre></td></tr></table></figure>
<p> <strong>方法二:绝对地址</strong><br> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cd d：\\Sublime\ Text3\\py <span class="comment">//正斜杠转义符</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>GitBash</category>
      </categories>
      <tags>
        <tag>GitBash</tag>
        <tag>命令</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言执行过程</title>
    <url>/2020/09/20/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>汇编语言的本质：机器语言的助记符</p>
<p><strong>过程</strong>：<br>计算机通电 -&gt; CPU读取内存中程序（电信号输入）-&gt;时钟发生器不断震荡通断电 -&gt;推动CPU内部一步一步执行（执行多少步取决于指令需要的时钟周期）-&gt;计算完成-&gt;写回（电信号）-&gt;写给显卡输出</p>
<p>时钟发生器：目前每秒几十亿次推进过程<br>显卡：里面是缓冲区，对应的是屏幕上一个个小像素。不停刷新。</p>
]]></content>
      <categories>
        <category>硬件基础知识</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>浮动及轮播图演示</title>
    <url>/2021/03/09/%E6%B5%AE%E5%8A%A8%E5%8F%8A%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%BC%94%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>我们可以利用定位打破文档流，除此以外也可以利用浮动。其实浮动就是让元素进行“靠左、靠右”进行水平排列。</p>
<details><summary>靠左侧浮动</summary>
<pre><code>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>浮动基本使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">		*&#123;</span><br><span class="line">			margin: 0;</span><br><span class="line">			padding: 0;</span><br><span class="line">		&#125;</span><br><span class="line">		div&#123;</span><br><span class="line">			float: left;</span><br><span class="line">			width: 150px;</span><br><span class="line">			height: 50px;</span><br><span class="line">			background: red;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>最近在下雨<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>最近在下雨<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>最近在下雨<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>最近在下雨<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>最近在下雨<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>最近在下雨<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>最近在下雨<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>最近在下雨<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>最近在下雨<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre></details>

<p><img src="https://img-blog.csdnimg.cn/20210309150158468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><code>float: left;</code>靠右侧浮动<br><img src="https://img-blog.csdnimg.cn/20210309150453188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注</strong>：一行放不下自动换行</p>
<h3 id="案例——导航条"><a href="#案例——导航条" class="headerlink" title="案例——导航条"></a>案例——导航条</h3><details><summary>百度新闻导航条</summary>
<pre><code>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>百度导航条<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">		*&#123;</span><br><span class="line">			margin: 0;</span><br><span class="line">			padding: 0;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.box</span>&#123;</span></span><br><span class="line">			position: relative;</span><br><span class="line"><span class="css">			<span class="comment">/*当前这个div的宽度是按照父元素宽度进行百分比*/</span></span></span><br><span class="line">			width: 100%;</span><br><span class="line">			height: 50px;</span><br><span class="line"><span class="css">			<span class="selector-tag">background</span>: <span class="selector-id">#01204f</span>;</span></span><br><span class="line">		&#125;</span><br><span class="line">		ul&#123;</span><br><span class="line">			position: absolute;</span><br><span class="line">			left: 20%;	</span><br><span class="line">			width: 80%;</span><br><span class="line">			height: 50px;</span><br><span class="line">			list-style: none;</span><br><span class="line">		&#125;</span><br><span class="line">		li&#123;</span><br><span class="line">			float: left;</span><br><span class="line">			width: 60px;</span><br><span class="line">			height: 50px;</span><br><span class="line">			color: white;</span><br><span class="line">			font-size: 16px;</span><br><span class="line">			</span><br><span class="line"><span class="css">			<span class="comment">/*行高 让文字在垂直方向*/</span></span></span><br><span class="line">			line-height: 50px;</span><br><span class="line"><span class="css">			<span class="comment">/*文字居中*/</span></span></span><br><span class="line">			text-align: center;</span><br><span class="line">			cursor: pointer;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-tag">li</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line">			background: red;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>国内<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>国际<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>军事<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>娱乐<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>互联网<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>科技<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>游戏<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>女人<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>汽车<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span>房产<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre></details>
<img src="https://img-blog.csdnimg.cn/20210309162017921.png" width=50% height=50% align=center>
+ 子元素宽度可以是百分比单位，是按照父元素的宽度进行划分的
+ line-height（行高）：可以让文本在垂直方向居中（最好属性值和当前元素高度一样高）

<h3 id="案例——轮播图的小圆球"><a href="#案例——轮播图的小圆球" class="headerlink" title="案例——轮播图的小圆球"></a>案例——轮播图的小圆球</h3><details><summary>轮播图的小圆球</summary>
<pre><code>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>轮播图小圆球<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">		*&#123;</span><br><span class="line">			margin: 0;</span><br><span class="line">			padding: 0;</span><br><span class="line">		&#125;</span><br><span class="line">		ul&#123;</span><br><span class="line">			position: relative;</span><br><span class="line">			width: 300px;</span><br><span class="line">			height: 50px;</span><br><span class="line">			list-style: none;</span><br><span class="line">			border: 1px solid black;</span><br><span class="line">			left: 50px;</span><br><span class="line">		&#125;</span><br><span class="line">		li&#123;</span><br><span class="line">			float: left;</span><br><span class="line"><span class="css">			<span class="comment">/*左侧外边距*/</span></span></span><br><span class="line">			margin-right: 10px;</span><br><span class="line">			width: 50px;</span><br><span class="line">			height: 50px;</span><br><span class="line"><span class="css">			<span class="comment">/*圆角设置*/</span></span></span><br><span class="line">			border-radius: 50%;</span><br><span class="line">			background: green;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.cur</span>&#123;</span></span><br><span class="line">			background: yellow;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"cur"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre></details>
<img src="https://img-blog.csdnimg.cn/20210309162259123.png" width=50% height=50% align=center>

<h3 id="案例——四叶草"><a href="#案例——四叶草" class="headerlink" title="案例——四叶草"></a>案例——四叶草</h3><p>CSS中给元素<strong>添加动画</strong>：<strong>animation</strong><br>web前端开发浏览器厂商常见：Google、IE、火狐、欧朋<br>浏览器厂商的私有前缀（带有私有前缀样式只能在当前浏览器中使用）<br>谷歌：webkit<br>IE：ms<br>火狐：moz<br>欧朋：o</p>
<details><summary>四叶草</summary>
<pre><code>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>四叶草<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">		*&#123;</span><br><span class="line">			margin: 0;</span><br><span class="line">			padding: 0;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="comment">/*相对定位：相对的是自己的起始位置*/</span></span></span><br><span class="line">			position: relative;</span><br><span class="line">			width: 200px;</span><br><span class="line">			height: 200px;</span><br><span class="line">			border: 1px solid black;</span><br><span class="line">			left: 40%;</span><br><span class="line"><span class="css">			<span class="comment">/*调用动画 动画执行时间一次5s，动画速率匀速 延迟时间0s 执行次数无限次*/</span></span></span><br><span class="line">			animation: donghua 5s linear 0s infinite;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.ye1</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="comment">/*绝对定位：子绝父相*/</span></span></span><br><span class="line">			position: absolute;</span><br><span class="line">			width: 100px;</span><br><span class="line">			height: 100px;</span><br><span class="line">			background: green;</span><br><span class="line">			left: 0px;</span><br><span class="line">			top: 0px;</span><br><span class="line"><span class="css">			<span class="comment">/*设置圆角：左上、右上、右下、左下*/</span></span></span><br><span class="line">			border-radius: 0px 90px 0px 90px; </span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.ye2</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="comment">/*绝对定位：子绝父相*/</span></span></span><br><span class="line">			position: absolute;</span><br><span class="line">			width: 100px;</span><br><span class="line">			height: 100px;</span><br><span class="line">			background: green;</span><br><span class="line">			left: 100px;</span><br><span class="line">			top: 0px;</span><br><span class="line"><span class="css">			<span class="comment">/*设置圆角：左上、右上、右下、左下*/</span></span></span><br><span class="line">			border-radius: 90px 0px 90px 0px; </span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.ye3</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="comment">/*绝对定位：子绝父相*/</span></span></span><br><span class="line">			position: absolute;</span><br><span class="line">			width: 100px;</span><br><span class="line">			height: 100px;</span><br><span class="line">			background: green;</span><br><span class="line">			left: 0px;</span><br><span class="line">			top: 100px;</span><br><span class="line"><span class="css">			<span class="comment">/*设置圆角：左上、右上、右下、左下*/</span></span></span><br><span class="line">			border-radius: 90px 0px 90px 0px; </span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.ye4</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="comment">/*绝对定位：子绝父相*/</span></span></span><br><span class="line">			position: absolute;</span><br><span class="line">			width: 100px;</span><br><span class="line">			height: 100px;</span><br><span class="line">			background: green;</span><br><span class="line">			left: 100px;</span><br><span class="line">			top: 100px;</span><br><span class="line"><span class="css">			<span class="comment">/*设置圆角：左上、右上、右下、左下*/</span></span></span><br><span class="line">			border-radius: 0px 90px 0px 90px; </span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="comment">/*声明一个animation动画*/</span></span></span><br><span class="line"><span class="css">		<span class="keyword">@-webkit-keyframes</span> donghua&#123;</span></span><br><span class="line">			from&#123;</span><br><span class="line"><span class="css">				<span class="comment">/*让父元素旋转360°*/</span></span></span><br><span class="line">				transform: rotate(0deg);</span><br><span class="line">			&#125;</span><br><span class="line">			to&#123;</span><br><span class="line">				transform: rotate(360deg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ye1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ye2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ye3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ye4"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre></details>
效果就是下面的图片会一直旋转
<img src="https://img-blog.csdnimg.cn/20210309164828997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=30% height=30% align=center>

<h2 id="轮播图布局"><a href="#轮播图布局" class="headerlink" title="轮播图布局"></a>轮播图布局</h2><p>很多网站受应都带有轮播图功能（）</p>
<details><summary>四叶草</summary>
<pre><code>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>轮播图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    *&#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="comment">/*相对定位*/</span></span></span><br><span class="line">      position: relative;</span><br><span class="line">      width: 520px;</span><br><span class="line">      height: 280px;</span><br><span class="line">      border: 1 px solid black;</span><br><span class="line">      left: 400px;v</span><br><span class="line">      top: 100px;</span><br><span class="line"><span class="css">      <span class="comment">/*子元素超出了父元素，则隐藏*/</span></span></span><br><span class="line">      overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    ul&#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      list-style: none;</span><br><span class="line">      width: 520px;</span><br><span class="line">      height: 280px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.leftbtn</span>&#123;</span></span><br><span class="line">      position: absolute;</span><br><span class="line">      background: green;</span><br><span class="line">      left: 10px;</span><br><span class="line">      top: 100px;</span><br><span class="line">      width: 60px;</span><br><span class="line">      height: 30px;</span><br><span class="line">      color: white;</span><br><span class="line">      text-align: center;</span><br><span class="line">      line-height: 30px;</span><br><span class="line"><span class="css">      <span class="selector-tag">opacity</span>: 0<span class="selector-class">.8</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.rightbtn</span>&#123;</span></span><br><span class="line">      position: absolute;</span><br><span class="line">      background: green;</span><br><span class="line">      left: 450px;</span><br><span class="line">      top: 100px;</span><br><span class="line">      width: 60px;</span><br><span class="line">      height: 30px;</span><br><span class="line">      color: white;</span><br><span class="line">      text-align: center;</span><br><span class="line">      line-height: 30px;</span><br><span class="line"><span class="css">      <span class="selector-tag">opacity</span>: 0<span class="selector-class">.8</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ol&#123;</span><br><span class="line">       position: absolute;</span><br><span class="line">       width: 200px;</span><br><span class="line">       height: 25px;</span><br><span class="line"><span class="css">       <span class="comment">/*background: red;*/</span></span></span><br><span class="line">       left: 33%;</span><br><span class="line">       bottom: 5px;</span><br><span class="line">       list-style: none;</span><br><span class="line"><span class="css">       <span class="selector-tag">opacity</span>: 0<span class="selector-class">.8</span>;</span></span><br><span class="line">       cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/*后代选择器*/</span></span></span><br><span class="line">    ol li&#123;</span><br><span class="line">      float: left;</span><br><span class="line">      width: 25px;</span><br><span class="line">      height: 25px;</span><br><span class="line">      background: green;</span><br><span class="line">      color: white;</span><br><span class="line">      left: 38%;</span><br><span class="line"><span class="css">      <span class="comment">/*变为圆球*/</span></span></span><br><span class="line">      border-radius: 50%;</span><br><span class="line">      text-align: center;</span><br><span class="line">      line-height: 25px;</span><br><span class="line">      margin-right: 5px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.cur</span>&#123;</span></span><br><span class="line">      background: skyblue;</span><br><span class="line"><span class="css">      <span class="comment">/*进行缩放*/</span></span></span><br><span class="line"><span class="css">      <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(1<span class="selector-class">.2</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 做左右按钮 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"leftbtn"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rightbtn"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 分页器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"cur"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre></details>

<p><strong>注意</strong>：transform可以让元素实现变化：旋转、平移、缩放</p>
<ol>
<li><strong>旋转</strong>（单位：度数deg）：让元素按照图像几何中心旋转<br><code>transform:rotate(30deg)</code></li>
<li><strong>缩放</strong>：等比让元素宽度和高度缩放<br><code>transform:scale(1.2)</code> </li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Web前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>浮动</tag>
        <tag>轮播图</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 --Youtube 3Blue1Brown</title>
    <url>/2020/07/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Youtube-3Blue1Brown/</url>
    <content><![CDATA[<h1 id="第一章-什么是神经网络？"><a href="#第一章-什么是神经网络？" class="headerlink" title="第一章 什么是神经网络？"></a>第一章 什么是神经网络？</h1><p>以最经典的识别神经网络为例，假设用来识别数字0~9<br>输入的一维向量其实是将一张图片降维（如下图）后得到的结果。<br><img src="https://img-blog.csdnimg.cn/20200712214627712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>神经元装着的像素值代表着对应像素的灰度值。我们把这个数叫做“激活值”，0为黑色，1为白色。越大代表着这个神经元点着越亮。我们对每一个连接设置权重参数，下一层每个神经元设置偏置，并使用激活函数。在隐藏层，我们希望所有位于图像中激活位置的图案都能点亮这个神经元。然后在最后，我们只需要学习哪些部件能够组合出什么数字即可。神经网络的本质是一个函数。<br><img src="https://img-blog.csdnimg.cn/2020071221464820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="第二章-梯度下降，神经网络如何学习？"><a href="#第二章-梯度下降，神经网络如何学习？" class="headerlink" title="第二章 梯度下降，神经网络如何学习？"></a>第二章 梯度下降，神经网络如何学习？</h1>]]></content>
      <categories>
        <category>大创</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>DNN</tag>
        <tag>3Blue1Brown</tag>
      </tags>
  </entry>
  <entry>
    <title>清华OS实验环境搭建</title>
    <url>/2020/09/12/%E6%B8%85%E5%8D%8EOS%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>清华OS实验<br><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab0/lab0_2_2_1_lab_steps.html" target="_blank" rel="noopener">实验指导书</a><br><a href="https://github.com/chyyuu/ucore_os_docs/blob/master/lab0/lab0_ref_ucore-resource.md" target="_blank" rel="noopener">参考书下载</a></p>
<p>Vmvare中本身就有Ubuntu16.04。所以打算直接在里面配置实验环境。</p>
<h3 id="相关软件安装"><a href="#相关软件安装" class="headerlink" title="相关软件安装"></a>相关软件安装</h3><p>参考：<br><a href="https://www.cnblogs.com/gatsby123/p/9746193.html" target="_blank" rel="noopener">MIT-6.828-JOS-环境搭建</a><br><a href="https://blog.csdn.net/eye_water/article/details/80638463?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-4-80638463.nonecase&utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" target="_blank" rel="noopener">MIT6.828 操作系统课程实验环境搭建</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% objdump -i</span><br><span class="line">% gcc -m32 -print-libgcc-file-name</span><br></pre></td></tr></table></figure>

<p>QEMU模拟器安装</p>
<ol>
<li><p>clone源码：git clone <a href="https://github.com/mit-pdos/6.828-qemu.git" target="_blank" rel="noopener">https://github.com/mit-pdos/6.828-qemu.git</a> qemu。这里最好还是老老实实从官方文档提供的地址下载，虽然有点慢。但是这门课程每年都可能修改qemu。</p>
</li>
<li><p>在进行安装之前，还需要安装一些包，这样才能安装qemu成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% sudo apt-get install libsdl1.2-dev</span><br><span class="line">% sudo apt-get install libglib2.0-dev</span><br><span class="line">% sudo apt-get install libz-dev</span><br><span class="line">% sudo apt-get install libpixman-1-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载完后，要进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% cd qemu</span><br><span class="line">% .&#x2F;configure --disable-kvm --target-list&#x3D;&quot;i386-softmmu x86_64-softmmu&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行make &amp;&amp; make install。至此QEMU安装完毕.</p>
</li>
</ol>
<p>测试:<br>拉取mit 6.828代码，在这里我没有使用官方代码，而是从github上拉取了一份（主要是因为拉取官方代码一直出现错误）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% mkdir ~&#x2F;6.828</span><br><span class="line">% cd ~&#x2F;6.828</span><br><span class="line">% git clone https:&#x2F;&#x2F;github.com&#x2F;fatsheep9146&#x2F;6.828mit lab</span><br></pre></td></tr></table></figure>

<p>最后，切换到lab文件夹，进行make操作<br>输出如下则成功<br><img src="https://img-blog.csdnimg.cn/20200912124111563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p>拷贝实验源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git:&#x2F;&#x2F;github.com&#x2F;chyyuu&#x2F;ucore_os_lab.git</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>盒模型及定位</title>
    <url>/2021/03/09/%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="一、盒模型"><a href="#一、盒模型" class="headerlink" title="一、盒模型"></a>一、盒模型</h2><p><strong>概述</strong><br>盒模型，其实任意标签都有这个概念，可以让标签向外扩展。【padding、border、margin】</p>
<p><font color='red'>盒模型中，<strong>padding</strong>【内边距】和<strong>border</strong>可【外边框】以让元素向外扩展。</font></p>
<p>margin是用来设置元素与元素之间距离的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>盒模型<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="selector-class">.box</span>&#123;</span></span><br><span class="line">			width: 200px;</span><br><span class="line">			height: 200px;</span><br><span class="line"><span class="css">			<span class="comment">/*外边框：可以让元素向外拓展*/</span></span></span><br><span class="line"><span class="css">			<span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;<span class="comment">/*实线向外拓展2px*/</span></span></span><br><span class="line"><span class="css">			<span class="comment">/*文字到边框的距离*/</span></span></span><br><span class="line">			padding: 100px;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.box1</span>&#123;</span></span><br><span class="line">			width: 200px;</span><br><span class="line">			height: 200px;</span><br><span class="line">			background: red;</span><br><span class="line"><span class="css">			<span class="comment">/*设置标签与标签的距离*/</span></span></span><br><span class="line">			margin: 10px;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>文字文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210309102404882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>注：前端所谓的盒模型，是下面这些属性：<br><font color='purple'>margin、padding、border、width、height</font></p>
<h2 id="二、定位"><a href="#二、定位" class="headerlink" title="二、定位"></a>二、定位</h2><pre><code>在前端web开发中，所谓文档流【页面中标签排列方式】：如果想打破文档流让标签可以在任意地方显示，需要定位</code></pre><p>块元素：从上到下排列【独占一行】<br>行内元素：从左到右排列【不独占一行】</p>
<h3 id="2-1-固定定位"><a href="#2-1-固定定位" class="headerlink" title="2.1 固定定位"></a>2.1 固定定位</h3><pre><code>fixed</code></pre><p>如果你想给某一个标签<strong>固定在网页中某一个位置</strong>，可以利用固定定位，哪怕页面上下滑动也不影响。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>固定定位<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="comment">/*页面默认样式【上、左带有空格】*/</span></span></span><br><span class="line"><span class="css">		<span class="comment">/*清除全部默认样式*/</span></span></span><br><span class="line">		*&#123;</span><br><span class="line">			margin: 0;</span><br><span class="line">			padding: 0;</span><br><span class="line">		&#125;</span><br><span class="line">		div&#123;</span><br><span class="line">			width: 400px;</span><br><span class="line">			height: 200px;</span><br><span class="line">		&#125;</span><br><span class="line">		body&#123;</span><br><span class="line">			height: 10000px;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="comment">/*固定定位：固定定位的元素不占起始的位置*/</span></span></span><br><span class="line">			position: fixed;</span><br><span class="line">			left: 500px;</span><br><span class="line">			top: 200px;</span><br><span class="line">			background: red;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.box2</span>&#123;</span></span><br><span class="line">			background: green;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.box3</span>&#123;</span></span><br><span class="line">			background: purple;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ol>
<li>只有<strong>定位元素</strong>才有这四个属性：left、top、right、bottom</li>
<li>固定定位是以网页为参照物，固定在某一个位置不动</li>
<li>固定定位元素不占起始位置，比如上面例子中，如果只设置<code>position: fixed;</code>，那么下面的元素块会顶上来，把红色块覆盖住</li>
</ol>
<h3 id="2-2-相对定位"><a href="#2-2-相对定位" class="headerlink" title="2.2 相对定位"></a>2.2 相对定位</h3><pre><code>relative</code></pre><p>相对定位也可以让元素脱离文档流，元素在进行相对定位的时候，其实<strong>相对的是起始的位置</strong>进行偏离。<br>而且要注意：</p>
<ol>
<li>相对定位的元素起始位置是占用的，别的元素用不了。也就是起始位置处留空。</li>
<li><strong>相对定位</strong>的left和top等属性是结束位置相对于<strong>自己的起始位置的距离</strong>，而<strong>绝对定位</strong>则是相对于整个网页的绝对距离。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>相对定位<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="comment">/*清除默认样式：默认情况下有缝隙*/</span></span></span><br><span class="line">		*&#123;</span><br><span class="line">			margin: 0;</span><br><span class="line">			padding: 0;</span><br><span class="line">		&#125;</span><br><span class="line">		div&#123;</span><br><span class="line">			width: 400px;</span><br><span class="line">			height: 200px;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.box1</span>&#123;</span></span><br><span class="line">			position: relative;</span><br><span class="line">			left: 500px;</span><br><span class="line">			top: 200px;</span><br><span class="line">			background: red;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.box2</span>&#123;</span></span><br><span class="line">			background: green;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.box3</span>&#123;</span></span><br><span class="line">			background: purple;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-3绝对定位"><a href="#2-3绝对定位" class="headerlink" title="2.3绝对定位"></a>2.3绝对定位</h3><pre><code>absolute </code></pre><p>绝对定位也可以让元素脱离文档流</p>
<ol>
<li>绝对定位元素，如果<font color='red'>没有定位父元素</font>，绝对定位<font color='red'>参照页面进行偏移</font></li>
<li>绝对定位元素，如果<font color='red'>有定位父元素</font>，绝对定位<font color='red'>参照定位父元素进行偏移</font></li>
</ol>
<p><strong>子绝父相</strong>：儿子是<strong>绝对定位</strong>，参照父亲的<strong>相对定位</strong>进行偏移<br>注：绝对定位元素<font color='purple'><strong>不占起始位置</strong></font>（别的元素可以占起始位置）</p>
<p><strong>没有定位父元素</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;绝对定位(没有定位父元素)&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">		&#x2F;*清除默认样式*&#x2F;</span><br><span class="line">		*&#123;</span><br><span class="line">			margin: 0;</span><br><span class="line">			padding: 0;</span><br><span class="line">		&#125;</span><br><span class="line">		body&#123;</span><br><span class="line">			height: 1000px;</span><br><span class="line">		&#125;</span><br><span class="line">		div&#123;</span><br><span class="line">			width: 400px;</span><br><span class="line">			height: 200px;</span><br><span class="line">		&#125;</span><br><span class="line">		.box1&#123;</span><br><span class="line">			position: absolute;</span><br><span class="line">			left: 100px;</span><br><span class="line">			top: 100px;</span><br><span class="line">			background: red;</span><br><span class="line">		&#125;</span><br><span class="line">		.box2&#123;</span><br><span class="line">			background: green;</span><br><span class="line">		&#125;</span><br><span class="line">		.box3&#123;</span><br><span class="line">			background: purple;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;box1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;box2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;box3&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有定位父元素，参照页面，不占原来位置。和固定定位有区别。上下滑动的时候，绝对定位元素会跟着一起滑动。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210309112839888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>有定位父元素</strong><br>        逐层找定位元素，父元素没有就找爷爷……最后参照网页</p>
<details><summary>如果没有写任何定位，就只是有父子嵌套</summary>
<pre><code>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>绝对定位(有定位父元素)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="comment">/*清除默认样式*/</span></span></span><br><span class="line">		*&#123;</span><br><span class="line">			margin: 0;</span><br><span class="line">			padding: 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="comment">/*父元素*/</span></span></span><br><span class="line">			width: 400px;</span><br><span class="line">			height: 400px;</span><br><span class="line">			margin: 200px;</span><br><span class="line">			background: red;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.inner</span>&#123;</span></span><br><span class="line">			width: 200px;</span><br><span class="line">			height: 200px;</span><br><span class="line">			background: green;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre></details>
<details><summary>如果子进行绝对定位，父进行了定位（固定、绝对、相对）</summary>
<pre><code>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>绝对定位(有定位父元素)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="comment">/*清除默认样式*/</span></span></span><br><span class="line">		*&#123;</span><br><span class="line">			margin: 0;</span><br><span class="line">			padding: 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="comment">/*父元素*/</span></span></span><br><span class="line">			position: relative;</span><br><span class="line">			width: 400px;</span><br><span class="line">			height: 400px;</span><br><span class="line">			margin: 200px;</span><br><span class="line">			background: red;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.inner</span>&#123;</span></span><br><span class="line">			width: 200px;</span><br><span class="line">			height: 200px;</span><br><span class="line">			background: green;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre></details>
<img src="https://img-blog.csdnimg.cn/20210309133039502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=50% height=50% align=center>

<p></code></pre></details></p>
<details><summary>如果父元素没有进行定位，子元素进行绝对定位，那么inner的参照物还是**网页**</summary>
<pre><code>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>绝对定位(有定位父元素)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="comment">/*清除默认样式*/</span></span></span><br><span class="line">		*&#123;</span><br><span class="line">			margin: 0;</span><br><span class="line">			padding: 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="comment">/*父元素*/</span></span></span><br><span class="line">			width: 400px;</span><br><span class="line">			height: 400px;</span><br><span class="line">			margin: 200px;</span><br><span class="line">			background: red;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.inner</span>&#123;</span></span><br><span class="line">			position: absolute;</span><br><span class="line">			left: 0px;</span><br><span class="line">			top: 0px;</span><br><span class="line">			width: 200px;</span><br><span class="line">			height: 200px;</span><br><span class="line">			background: green;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre></details>
<img src="https://img-blog.csdnimg.cn/20210309132400151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=50% height=50% align=center>

]]></content>
      <categories>
        <category>Java</category>
        <category>Web前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>盒模型</tag>
        <tag>定位</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解</title>
    <url>/2021/02/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>例子见<a href="https://github.com/two-fire/JavaSE" target="_blank" rel="noopener">Github-JavaSE-Day08</a></p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li>Annontation是JAVA5开始引入的新特征，称为<strong>注解</strong>。</li>
<li>它提供了一种安全的类似注释的机制，用来将任何信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。</li>
<li>Java注解是附加在代码中的一些元信息</li>
</ul>
<h4 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h4><ol>
<li><p>生成文档<br>@param @return等</p>
</li>
<li><p>跟踪代码依赖性，实现替代配置文件功能</p>
</li>
<li><p>在编程时进行格式检查<br>如@override放在方法前，如果这个方法并不是覆盖了超类方法，则编译时能检查出。</p>
<p>@Deprecated // 当前方法已经过时了<br>@SuppressWarnings(“all”) // 忽略对应的警告信息</p>
</li>
</ol>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>· 作用：负责注解其他注解，Java中定义了四个标准的meta-annotation类型，被用来提供对其他annotation类型做说明。<br>· 这些类型和它们所支持的类在java.lang.annotation包中<br><img src="https://img-blog.csdnimg.cn/20210201224416229.png" alt="在这里插入图片描述"></p>
<p>@Target<br>用来描述注解的使用范围,类、方法、变量、包等类型</p>
<p>@Retention()<br>表示当前注解适用于什么环境，是源码级别还是类级别还是运行时环境，一般都是运行时环境<br>Source &lt; Class &lt; Runtime</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RetentionPolicy.RUNTIME</td>
<td align="center">运行时</td>
</tr>
<tr>
<td align="center">RetentionPolicy.CLASS</td>
<td align="center">运行环境</td>
</tr>
<tr>
<td align="center">RetentionPolicy.SOURCE</td>
<td align="center">源码级别</td>
</tr>
</tbody></table>
<p>可选：<br>@Document<br>表示该注解是否显示在javadoc中<br>@Inherited<br>表示该注解是否能否能够被继承</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation</span>(age = <span class="number">12</span>,id = <span class="number">3</span>,likes = &#123;<span class="string">"book"</span>,<span class="string">"lol"</span>,<span class="string">"movie"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义的方式看起来像方法，但是实际上使用在：使用注解的时候，填写的参数的名称，默认名称是value</span></span><br><span class="line">    <span class="comment">// 当我们在自定义注解中填写的所有方法，都需要在使用注解的时候添加值，很麻烦，因此包含默认值</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "zhangs"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    String[] likes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>JDK新特性</category>
      </categories>
      <tags>
        <tag>JDK新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle行转列经典笔试题</title>
    <url>/2021/02/06/%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>1、中国移动sql面试题：<br>create table test(<br>   id number(10) primary key,<br>   type number(10) ,<br>   t_id number(10),<br>   value varchar2(5)<br>);<br>insert into test values(100,1,1,’张三’);<br>insert into test values(200,2,1,’男’);<br>insert into test values(300,3,1,’50’);</p>
<p>insert into test values(101,1,2,’刘二’);<br>insert into test values(201,2,2,’男’);<br>insert into test values(301,3,2,’30’);</p>
<p>insert into test values(102,1,3,’刘三’);<br>insert into test values(202,2,3,’女’);<br>insert into test values(302,3,3,’10’);<br>请写出一条查询语句结果如下：</p>
<blockquote>
<p>姓名      性别     年龄<br>张三       男        50</p>
</blockquote>
<p>【重点】<strong><font color='red'>行转列</font></strong>，<code>group by</code>分组多行合并为一行。<br><strong>解析</strong>：<br>1、运行上述代码，再进行表查看<code>select * from test;</code><br><img src="https://img-blog.csdnimg.cn/20210206153045902.png" width=20% height=20% align=center><br>2、实现行转列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">decode</span>(<span class="keyword">type</span>, <span class="number">1</span>, <span class="keyword">value</span>) 姓名,</span><br><span class="line">       <span class="keyword">decode</span>(<span class="keyword">type</span>, <span class="number">2</span>, <span class="keyword">value</span>) 性别,</span><br><span class="line">       <span class="keyword">decode</span>(<span class="keyword">type</span>, <span class="number">3</span>, <span class="keyword">value</span>) 年龄</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210206153032894.png" width=20% height=20% align=center>
3、多行合并为一行。首先使用group by分成三组，然后每组的每一条记录用max得到非空值（用min()也可以）
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">decode</span>(<span class="keyword">type</span>, <span class="number">1</span>, <span class="keyword">value</span>)) 姓名,</span><br><span class="line">       <span class="keyword">max</span>(<span class="keyword">decode</span>(<span class="keyword">type</span>, <span class="number">2</span>, <span class="keyword">value</span>)) 性别,</span><br><span class="line">       <span class="keyword">max</span>(<span class="keyword">decode</span>(<span class="keyword">type</span>, <span class="number">3</span>, <span class="keyword">value</span>)) 年龄</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">group</span> <span class="keyword">by</span> t_id;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210206153019470.png" width=20% height=20% align=center>

<hr>
<p>2、一道SQL语句面试题，关于group by<br>表内容：<br>2005-05-09 胜<br>2005-05-09 胜<br>2005-05-09 负<br>2005-05-09 负<br>2005-05-10 胜<br>2005-05-10 负<br>2005-05-10 负</p>
<p>如果要生成下列结果, 该如何写sql语句?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          胜 负</span><br><span class="line">2005-05-09 2 2</span><br><span class="line">2005-05-10 1 2</span><br></pre></td></tr></table></figure>
<p>create table tmp(rq varchar2(10),shengfu varchar2(5));</p>
<p>insert into tmp values(‘2005-05-09’,’胜’);<br>insert into tmp values(‘2005-05-09’,’胜’);<br>insert into tmp values(‘2005-05-09’,’负’);<br>insert into tmp values(‘2005-05-09’,’负’);<br>insert into tmp values(‘2005-05-10’,’胜’);<br>insert into tmp values(‘2005-05-10’,’负’);<br>insert into tmp values(‘2005-05-10’,’负’);</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tmp;</span><br><span class="line"><span class="comment">-- decode缺省值null可以不写，默认null</span></span><br><span class="line"><span class="keyword">select</span> rq,</span><br><span class="line">       <span class="keyword">count</span>(<span class="keyword">decode</span>(shengfu, <span class="string">'胜'</span>, <span class="number">1</span>, <span class="literal">null</span>)) <span class="string">"胜"</span>,</span><br><span class="line">       <span class="keyword">count</span>(<span class="keyword">decode</span>(shengfu, <span class="string">'负'</span>, <span class="number">1</span>, <span class="literal">null</span>)) <span class="string">"负"</span></span><br><span class="line">  <span class="keyword">from</span> tmp</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> rq <span class="keyword">order</span> <span class="keyword">by</span> rq;</span><br></pre></td></tr></table></figure>
<hr>
<p>3、create table STUDENT_SCORE<br>(<br>  name    VARCHAR2(20),<br>  subject VARCHAR2(20),<br>  score   NUMBER(4,1)<br>);<br>insert into student_score (NAME, SUBJECT, SCORE) values (‘张三’, ‘语文’, 78.0);<br>insert into student_score (NAME, SUBJECT, SCORE) values (‘张三’, ‘数学’, 88.0);<br>insert into student_score (NAME, SUBJECT, SCORE) values (‘张三’, ‘英语’, 98.0);<br>insert into student_score (NAME, SUBJECT, SCORE) values (‘李四’, ‘语文’, 89.0);<br>insert into student_score (NAME, SUBJECT, SCORE) values (‘李四’, ‘数学’, 76.0);<br>insert into student_score (NAME, SUBJECT, SCORE) values (‘李四’, ‘英语’, 90.0);<br>insert into student_score (NAME, SUBJECT, SCORE) values (‘王五’, ‘语文’, 99.0);<br>insert into student_score (NAME, SUBJECT, SCORE) values (‘王五’, ‘数学’, 66.0);<br>insert into student_score (NAME, SUBJECT, SCORE) values (‘王五’, ‘英语’, 91.0);</p>
<p>3.1得到类似下面的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名   语文  数学  英语</span><br><span class="line">王五    89    56    89</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--至少使用四种方式写出</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student_score;</span><br><span class="line"><span class="comment">--decode</span></span><br><span class="line"><span class="keyword">select</span> ss.name,</span><br><span class="line">       <span class="keyword">max</span>(<span class="keyword">decode</span>(subject, <span class="string">'语文'</span>, score)) 语文,</span><br><span class="line">       <span class="keyword">max</span>(<span class="keyword">decode</span>(subject, <span class="string">'数学'</span>, score)) 数学,</span><br><span class="line">       <span class="keyword">max</span>(<span class="keyword">decode</span>(subject, <span class="string">'英语'</span>, score)) 英语</span><br><span class="line">  <span class="keyword">from</span> student_score ss</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br><span class="line"><span class="comment">--case when</span></span><br><span class="line"><span class="keyword">select</span> ss.name,</span><br><span class="line">       <span class="keyword">max</span>(<span class="keyword">case</span> subject</span><br><span class="line">             <span class="keyword">when</span> <span class="string">'语文'</span> <span class="keyword">then</span></span><br><span class="line">              score</span><br><span class="line">           <span class="keyword">end</span>) 语文,</span><br><span class="line">       <span class="keyword">max</span>(<span class="keyword">case</span> subject</span><br><span class="line">             <span class="keyword">when</span> <span class="string">'数学'</span> <span class="keyword">then</span></span><br><span class="line">              score</span><br><span class="line">           <span class="keyword">end</span>) 数学,</span><br><span class="line">       <span class="keyword">max</span>(<span class="keyword">case</span> subject</span><br><span class="line">             <span class="keyword">when</span> <span class="string">'英语'</span> <span class="keyword">then</span></span><br><span class="line">              score</span><br><span class="line">           <span class="keyword">end</span>) 英语</span><br><span class="line">  <span class="keyword">from</span> student_score ss</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure>
<p>下面用join方法，可以使用nutuarl join或者join on。<br><strong>注意</strong>：<br>1、<font color='purple'>如果使用nutuarl join，连接中使用的列不能有限定词。</font>因为nutuarl join会从两张表中找到<strong>相同的列</strong>做连接。score会导致错误。<br>2、<font color='purple'>如果使用nutuarl join，相同的关联列在选择列表中，不能用表名来指示（t1.name）。会报<strong>t1.name标识符错误</strong>。</font></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--错误一</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, t1.score, t2.score, t3.英语</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> ss.name, ss.score </span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'语文'</span>) t1 <span class="keyword">natural</span></span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> ss.name, ss.score </span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'数学'</span>) t2 <span class="keyword">natural</span></span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> ss.name, ss.score 英语</span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'英语'</span>) t3</span><br><span class="line"><span class="comment">--错误二</span></span><br><span class="line"><span class="keyword">select</span> t1.name, t1.语文, t2.数学, t3.英语</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> ss.name, ss.score 语文</span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'语文'</span>) t1 <span class="keyword">natural</span></span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> ss.name, ss.score 数学</span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'数学'</span>) t2 <span class="keyword">natural</span></span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> ss.name, ss.score 英语</span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'英语'</span>) t3</span><br><span class="line"><span class="comment">--正确写法</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, t1.语文, t2.数学, t3.英语</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> ss.name, ss.score 语文</span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'语文'</span>) t1 <span class="keyword">natural</span></span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> ss.name, ss.score 数学</span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'数学'</span>) t2 <span class="keyword">natural</span></span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> ss.name, ss.score 英语</span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'英语'</span>) t3</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<font color='purple'>如果使用join on，和自然连接相反，必须在选择列表中指明，查找的相同列是哪个表中的（t1.name）</font>，否则会报<strong>未明确定义列</strong>的错误。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--错误</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, t1.score 语文, t2.score 数学, t3.score 英语</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> ss.name, ss.score </span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'语文'</span>) t1</span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> ss.name, ss.score </span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'数学'</span>) t2</span><br><span class="line">    <span class="keyword">on</span> t1.name = t2.name</span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> ss.name, ss.score</span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'英语'</span>) t3</span><br><span class="line">    <span class="keyword">on</span> t1.name = t3.name</span><br><span class="line"><span class="comment">--正确写法</span></span><br><span class="line"><span class="keyword">select</span> t1.name, t1.score 语文, t2.score 数学, t3.score 英语</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> ss.name, ss.score </span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'语文'</span>) t1</span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> ss.name, ss.score </span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'数学'</span>) t2</span><br><span class="line">    <span class="keyword">on</span> t1.name = t2.name</span><br><span class="line">  <span class="keyword">join</span> (<span class="keyword">select</span> ss.name, ss.score</span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">where</span> ss.subject = <span class="string">'英语'</span>) t3</span><br><span class="line">    <span class="keyword">on</span> t1.name = t3.name</span><br></pre></td></tr></table></figure>
<p><strong>方法四</strong>可以使用全集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">max</span>(语文) 语文, <span class="keyword">max</span>(数学) 数学, <span class="keyword">max</span>(英语) 英语</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> ss1.name, ss1.score 语文, <span class="literal">null</span> 数学, <span class="literal">null</span> 英语</span><br><span class="line">          <span class="keyword">from</span> student_score ss1</span><br><span class="line">         <span class="keyword">where</span> ss1.subject = <span class="string">'语文'</span></span><br><span class="line">        <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">        <span class="keyword">select</span> ss2.name, <span class="literal">null</span> 语文, ss2.score 数学, <span class="literal">null</span> 英语</span><br><span class="line">          <span class="keyword">from</span> student_score ss2</span><br><span class="line">         <span class="keyword">where</span> ss2.subject = <span class="string">'数学'</span></span><br><span class="line">        <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">        <span class="keyword">select</span> ss3.name, <span class="literal">null</span> 数学, <span class="literal">null</span> 英语, ss3.score 英语</span><br><span class="line">          <span class="keyword">from</span> student_score ss3</span><br><span class="line">         <span class="keyword">where</span> ss3.subject = <span class="string">'英语'</span>)</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210208110519438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" width=70% height=70% align=center>

<hr>
<p>3.2有一张表，里面有3个字段：语文，数学，英语。其中有3条记录分别表示语文70分，数学80分，英语58分，请用一条sql语句查询出这三条记录并按以下条件显示出来（并写出您的思路）：<br>   大于或等于80表示优秀，大于或等于60表示及格，小于60分表示不及格。<br>显示格式：</p>
<pre><code>Name    语文              数学                英语  
张三    及格              优秀                优秀  </code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,</span><br><span class="line">       <span class="keyword">case</span></span><br><span class="line">         <span class="keyword">when</span> 语文 &gt;= <span class="number">80</span> <span class="keyword">then</span></span><br><span class="line">          to_char(<span class="string">'优秀'</span>)</span><br><span class="line">         <span class="keyword">when</span> 语文 &gt;= <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">          to_char(<span class="string">'及格'</span>)</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">          to_char(<span class="string">'不及格'</span>)</span><br><span class="line">       <span class="keyword">END</span> 语文,</span><br><span class="line">       <span class="keyword">case</span></span><br><span class="line">         <span class="keyword">when</span> 数学 &gt;= <span class="number">80</span> <span class="keyword">then</span></span><br><span class="line">          to_char(<span class="string">'优秀'</span>)</span><br><span class="line">         <span class="keyword">when</span> 数学 &gt;= <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">          to_char(<span class="string">'及格'</span>)</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">          to_char(<span class="string">'不及格'</span>)</span><br><span class="line">       <span class="keyword">END</span> 数学,</span><br><span class="line">       <span class="keyword">case</span></span><br><span class="line">         <span class="keyword">when</span> 英语 &gt;= <span class="number">80</span> <span class="keyword">then</span></span><br><span class="line">          to_char(<span class="string">'优秀'</span>)</span><br><span class="line">         <span class="keyword">when</span> 英语 &gt;= <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">          to_char(<span class="string">'及格'</span>)</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">          to_char(<span class="string">'不及格'</span>)</span><br><span class="line">       <span class="keyword">END</span> 英语</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> ss.name,</span><br><span class="line">               <span class="keyword">max</span>(<span class="keyword">decode</span>(subject, <span class="string">'语文'</span>, score)) 语文,</span><br><span class="line">               <span class="keyword">max</span>(<span class="keyword">decode</span>(subject, <span class="string">'数学'</span>, score)) 数学,</span><br><span class="line">               <span class="keyword">max</span>(<span class="keyword">decode</span>(subject, <span class="string">'英语'</span>, score)) 英语</span><br><span class="line">          <span class="keyword">from</span> student_score ss</span><br><span class="line">         <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>

<p>4、请用一个sql语句得出结果<br>从table1,table2中取出如table3所列格式数据，注意提供的数据及结果不准确，只是作为一个格式向大家请教。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">table1</span><br><span class="line"></span><br><span class="line">月份mon 部门dep 业绩yj</span><br><span class="line">-------------------------------</span><br><span class="line">一月份      01      10</span><br><span class="line">一月份      02      10</span><br><span class="line">一月份      03      5</span><br><span class="line">二月份      02      8</span><br><span class="line">二月份      04      9</span><br><span class="line">三月份      03      8</span><br><span class="line"></span><br><span class="line">table2</span><br><span class="line"></span><br><span class="line">部门dep      部门名称dname</span><br><span class="line">--------------------------------</span><br><span class="line">      01      国内业务一部</span><br><span class="line">      02      国内业务二部</span><br><span class="line">      03      国内业务三部</span><br><span class="line">      04      国际业务部</span><br><span class="line"></span><br><span class="line">table3 （result）</span><br><span class="line"></span><br><span class="line">部门dep 一月份      二月份      三月份</span><br><span class="line">--------------------------------------</span><br><span class="line">      01      10                  </span><br><span class="line">      02                10        8         </span><br><span class="line">      03                 5        8</span><br><span class="line">      04                          9</span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br></pre></td></tr></table></figure>
<p>create table yj01(<br>       month varchar2(10),<br>       deptno number(10),<br>       yj number(10)<br>);</p>
<p>insert into yj01(month,deptno,yj) values(‘一月份’,01,10);<br>insert into yj01(month,deptno,yj) values(‘二月份’,02,10);<br>insert into yj01(month,deptno,yj) values(‘二月份’,03,5);<br>insert into yj01(month,deptno,yj) values(‘三月份’,02,8);<br>insert into yj01(month,deptno,yj) values(‘三月份’,04,9);<br>insert into yj01(month,deptno,yj) values(‘三月份’,03,8);</p>
<p>create table yjdept(<br>       deptno number(10),<br>       dname varchar2(20)<br>);</p>
<p>insert into yjdept(deptno,dname) values(01,’国内业务一部’);<br>insert into yjdept(deptno,dname) values(02,’国内业务二部’);<br>insert into yjdept(deptno,dname) values(03,’国内业务三部’);<br>insert into yjdept(deptno,dname) values(04,’国际业务部’);</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--这题中，table2没有用到</span></span><br><span class="line"><span class="keyword">select</span> t1.deptno <span class="string">"部门dep"</span>,</span><br><span class="line">       <span class="keyword">max</span>(<span class="keyword">decode</span>(<span class="keyword">month</span>, <span class="string">'一月份'</span>, yj)) 一月份,</span><br><span class="line">       <span class="keyword">max</span>(<span class="keyword">decode</span>(<span class="keyword">month</span>, <span class="string">'二月份'</span>, yj)) 二月份,</span><br><span class="line">       <span class="keyword">max</span>(<span class="keyword">decode</span>(<span class="keyword">month</span>, <span class="string">'三月份'</span>, yj)) 三月份</span><br><span class="line">  <span class="keyword">from</span> yj01 t1</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> deptno</span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL语言</tag>
        <tag>行转列</tag>
      </tags>
  </entry>
  <entry>
    <title>解决oracle连接navicat出现oracle net admin error</title>
    <url>/2021/02/04/%E8%A7%A3%E5%86%B3oracle%E8%BF%9E%E6%8E%A5navicat%E9%93%BE%E6%8E%A5%E6%97%B6%E5%87%BA%E7%8E%B0oracle%20net%20admin%20error/</url>
    <content><![CDATA[<p>Navicat 进行Oracle连接：<br><img src="https://img-blog.csdnimg.cn/20210204214107242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>出现<code>oracle net admin error</code></p>
<p>工具–&gt;选项–&gt;环境–&gt;OCL环境<br>把Oracle安装目录D:\oracle\product\11.2.0\dbhome_1\bin\oci.dll(根据你的实际安装目录)下的oci.dll文件替换Navicat安装目录D:\Program Files (x86)\Navicat Premium 12\instantclient_11_2\oci.dll(根据你的实际安装目录)下的oci.dll就可以了。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>navicat</tag>
      </tags>
  </entry>
  <entry>
    <title>论文导读《DeepCT: Tomographic Combinatorial Testing for Deep Learning Systems》</title>
    <url>/2020/05/17/%E8%AE%BA%E6%96%87%E5%AF%BC%E8%AF%BB%E3%80%8ADeepCT-Tomographic-Combinatorial-Testing-for-Deep-Learning-Systems%E3%80%8B/</url>
    <content><![CDATA[<p>大创第一次讨论论文</p>
<h2 id="DeepCT：深度学习系统的层析组合测试"><a href="#DeepCT：深度学习系统的层析组合测试" class="headerlink" title="DeepCT：深度学习系统的层析组合测试"></a>DeepCT：深度学习系统的层析组合测试</h2><blockquote>
<p><font color=green >思考</font></br><br><font color=#FF9000 >问题</font></br><br> 已解决⭐ </br><br> <font color=#FF4500 >重点</font></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200629184641601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#目录">目录</a><ul>
<li><a href="#摘要">摘要</a></li>
<li><a href="#简介">简介</a></li>
<li><a href="#层析组合的背景和动机">层析组合的背景和动机</a></li>
<li><a href="#组合测试标准">组合测试标准</a></li>
<li><a href="#深度学习的ct稳健性测试">深度学习的CT稳健性测试</a></li>
<li><a href="#实验及结果">实验及结果</a></li>
</ul>
</li>
</ul>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>提出了一套专门针对DL系统的组合测试标准，以及CT（组合测试）覆盖率指导的测试生成技术。</li>
<li>初步评估结果表明CT确实是测试DL系统的有希望的方向。</li>
<li>当前的深度学习的测试方法，都是基于神经元的激活覆盖率。本文就是以一种层析的方式断层检测模型某一层中神经元之间的相互作用。</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>DL测试的必要性和重要性。</li>
<li>面临的问题：运行时状态空间巨大导致测试困难</li>
<li>CT可以系统地探索各种输入组合，这可以很好地权衡缺陷检测能力和尽最大努力测试搜索空间。</li>
<li>为了在测试套件尽可能小的情况下，又同时获得较好的CT覆盖率，CT通常采用的是将测试生成转换成约束解决问题。</li>
</ol>
<h2 id="层析组合的背景和动机"><a href="#层析组合的背景和动机" class="headerlink" title="层析组合的背景和动机"></a>层析组合的背景和动机</h2><p><strong>PER1:层析</strong><br><img src="https://img-blog.csdnimg.cn/202006291855095.png" alt="在这里插入图片描述"></p>
<p>CNNs是由简单的结构组合起来，逐渐随着层的增加复杂度，CNNs掌握的特征也越来越复杂</p>
<p><strong>PER2:组合</strong><br><img src="https://img-blog.csdnimg.cn/20200629185547370.png" alt="在这里插入图片描述"><br><font size=1> 图2：相邻两层之间的相互作用，用于(A)标准卷积，(B)局部连接卷积，(c)平铺卷积，以及最后(D)全连通情况(DNN) </font></p>
<p>很明显，每一层内都没有神经相互作用。<br>但当前层的神经元共同决定其下一层神经元间的逻辑的相互作用。</p>
<h2 id="组合测试标准"><a href="#组合测试标准" class="headerlink" title="组合测试标准"></a>组合测试标准</h2><p><strong>定义</strong></p>
<ol>
<li>CT ： Combinatorial Testing ，组合测试</li>
</ol>
<ul>
<li>系统地探索各种输入组合</li>
<li>为了在CT覆盖率尽量大的同时最小化测试集大小，CT通常将测试生成问题转化为约束求解问题。<br>传统软件组合测试：<br><img src="https://img-blog.csdnimg.cn/20200629185918295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<ol start="2">
<li><p><strong>t-way</strong> ：t代表考虑的元组个数，2-way就是考虑二元祖的神经元之间的组合。比如：模型N的Li层中，有四个神经元 {n1,n2,n3,n4}，2-way 组合共六种{n1,n2}，{n1,n3}，{n1,n4}，{n2,n3}，{n2,n4}，{n3,n4}</p>
</li>
<li><p><strong>Neuron-activation configuration</strong> :神经元激活配置，个数为：2^t<br>举例：假设现在有一组神经元：N={n1,n2,n3}，每个神经元有两个状态{0,1} ，分别对应未激活和激活。使用2-way组合测试，这组神经元共有三个组合方式：{n1,n2}，{n1,n3}，{n2,n3}则每个组合的Neuron-activation configuration有四个：(0,0)，(0,1)，(1,0)，(1,1) </p>
</li>
<li><p><strong>组合稀疏覆盖率</strong><br><img src="https://img-blog.csdnimg.cn/20200629190221565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>稠密覆盖率</strong><br><img src="https://img-blog.csdnimg.cn/20200629190333800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>(p，t)-完备性</strong><br><img src="https://img-blog.csdnimg.cn/20200629190418172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
<h2 id="深度学习的CT稳健性测试"><a href="#深度学习的CT稳健性测试" class="headerlink" title="深度学习的CT稳健性测试"></a>深度学习的CT稳健性测试</h2><ul>
<li><p><strong>d-locally-robust</strong>局部鲁棒性：<br><img src="https://img-blog.csdnimg.cn/20200629190517686.png" alt="在这里插入图片描述"><br>当满足x与x’的距离为d，x与x’的分类相同时，则DNN在x处d-local-robust。<br>  即对图片添加扰动但不会改变预测结果</p>
</li>
<li><p><strong>robustness issue</strong>鲁棒性问题： 一个input x，在它的附近有一个 x’，如果x与x’经过DNN后分类不同，则x’为对抗样本，DNN在x处存在robustness issue。</p>
</li>
<li><p>可以通过<strong>检查局部鲁棒性</strong>来分析对抗性鲁棒性。因此，本文其余部分着重于测试DNN的局部鲁棒性。</p>
</li>
</ul>
<h2 id="实验及结果"><a href="#实验及结果" class="headerlink" title="实验及结果"></a>实验及结果</h2><p><strong>算法</strong></p>
<ul>
<li>分析局部鲁棒性的一种方法是通过随机测试。常常无效，本文提出了组合测试技术。</li>
<li>通过随机测试和DeepCT获得的CT覆盖率和检测到对抗性问题。</li>
<li>具体来说，我们为每个种子测试随机生成10000个测试，并分析是否可以检测到健壮性问题。</li>
<li>过程</li>
</ul>
<ol>
<li>给定一个种子测试集T，t-way和CT准则作为输入，初始化整个DNN的CT覆盖表    </li>
<li>针对由CT覆盖层逐层引导的每个播种测试，开始生成测试迭代<ol>
<li>对于每个候选层，分析覆盖率；</li>
<li>更新了覆盖率表，并计算未覆盖的CT目标；</li>
<li>检查生成的测试是否包含对抗性示例;<ol start="4">
<li>更新生成的测试工作集。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>实验过程</strong></p>
<ol>
<li>共有1000个种子测试集，每个种子测试集使用随机测试方法生成出10000个样本</li>
<li>使用随机测试，在1000个种子测试集中，能够在DNN1上的194个种子测试和DNN2上的178个种子测试上检测到鲁棒性问题，其中共同存在的有106个，共计266个robustness issue。</li>
<li>过滤掉了266个测试，这些测试的鲁棒性问题已经可以通过随机测试检测到。 对于其余的734个测试，我们通过DeepCT（其中d = 0.15，并使用双向定义的CT标准）随机抽样50个测试，以进一步分析其稳健性，与通过随机测试生成的相应测试一致。</li>
<li>逐层迭代的生成测试样例</li>
</ol>
<ul>
<li><font color=#FF4500>在这734个种子测试集中，随机抽50个进一步分析d-local-robust。（表中是这50个测试集的结果，所以第一行的对抗样本为0个。）</font></li>
</ul>
<p><strong>结论</strong></p>
<ul>
<li><p>DNN在处理不同测试输入时的鲁棒性可能不同。 </p>
</li>
<li><p><font color=#FF4500>DNN决策边界附近的测试输入可能会更容易触发健壮性问题。</font></p>
</li>
<li><p>作为第一次尝试，RT（随机测试）可以用于检测脆弱的测试输入。</p>
</li>
<li><p>CT并非穷举搜索输入空间的所有组合，而是专注于测试输入的交互，旨在减小测试对象的大小，同时获得令人满意的缺陷检测能力。本文启动了第一个研究，探索CT在测试DL系统中的实用性。 我们的结果表明，CT为测试DL系统提供了有希望的途径。 我们未来的工作将对定点CT对对抗性示例检测的效果进行更深入的研究，并为现实世界的DL系统合并更多可扩展的CT测试生成器。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大创</category>
        <category>DNNs测试</category>
      </categories>
      <tags>
        <tag>论文导读</tag>
        <tag>大创</tag>
        <tag>DNNs测试</tag>
      </tags>
  </entry>
  <entry>
    <title>论文导读《DeepGini:Prioritizing Massive Tests to Enhance the Robustnessof Deep Neural Networks》</title>
    <url>/2020/06/29/%E8%AE%BA%E6%96%87%E5%AF%BC%E8%AF%BB%E3%80%8ADeepGini-Prioritizing-Massive-Tests-to-Enhance-the-Robustnessof-Deep-Neural-Networks%E3%80%8B/</url>
    <content><![CDATA[<p>  大创第二次讨论论文</p>
<h2 id="DeepGini：优先进行大规模测试以增强深度神经网络的鲁棒性"><a href="#DeepGini：优先进行大规模测试以增强深度神经网络的鲁棒性" class="headerlink" title="DeepGini：优先进行大规模测试以增强深度神经网络的鲁棒性"></a>DeepGini：优先进行大规模测试以增强深度神经网络的鲁棒性</h2><p><a href="https://arxiv.org/pdf/1903.00661.pdf" target="_blank" rel="noopener">原文地址</a></p>
<blockquote>
<p><font color=green >思考</font></br><br><font color=#FF9000 >问题</font></br><br> 已解决⭐ </br><br> <font color=#FF4500 >重点</font></p>
</blockquote>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><ol>
<li><p>为给定输入定义正确输出的测试预言在自动测试中通常不可用。 为了获取理论信息，基于DNN的系统的测试任务通常需要提前进行人工贴标签。</p>
</li>
<li><p>DeepGini，一种基于DNN统计视角设计的测试优先级划分技术。这样的统计角度使我们能够将测量错误分类概率的问题减少到测量固定杂质的问题，使我们能够快速识别可能错误分类的测试。</p>
</li>
<li><p>DeepGini在优先考虑有效性和效率方面的测试方面优于现有的基于覆盖的技术。并且由DeepGini优先进行的测试在提高DNN质量方面更为有效。特别针对图像分类DNN</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3></li>
<li><p>背景：常规软件测试依靠程序员手写建立业务逻辑，而DNN测试依靠数据驱动的编程范例<font color=#FF9000 >（data-drivenprogramming paradigm）</font>，所以足够的带有oracle信息的数据对于基于DNN的软件错误行为的检测十分重要。</p>
</li>
<li><p>问题：无法自动测试Oracle。</p>
</li>
<li><p>启发：在测试基于DNN的系统时，软件测试人员通常将注意力集中在那些可能导致系统运行不正常的测试上，因为诊断这些测试可以洞察程序中的各种问题。 这一事实自然促使我们提出一种对测试进行优先级排序的技术，以便可以在其他测试之前对引起故障的测试进行标记和分析。</p>
</li>
<li><p>现有测试优先级排序技术：代码覆盖率用作指导优先级排序过程的度量， 两种主要的基于覆盖的技术称为覆盖总数测试和覆盖范围附加测试优先级划分[46]。<br> 覆盖总数测试方法主要是如果它覆盖更多程序元素，我们就优先选择它进行测试。<br> 覆盖范围附加测试方法首选的测试则是是否可以覆盖更多之前测试未发现的程序元素。<br> 上述的基于覆盖的方法预期效果不是很好。<br> 原因：</p>
<ol>
<li>这些标准是用来衡量测试充分性的，使用这些覆盖标准测试DNN后，往往不清楚如何提高DNN的质量</li>
<li>需要非常高的时间复杂度O(mn^2)</li>
</ol>
</li>
<li><p>直观地讲，如果DNN为每个类别输出相似的概率，则DNN可能会将测试分类为错误的类别。</p>
</li>
<li><p>缺点：我们的方法需要运行所有测试以获得输出矢量</p>
</li>
<li><p>本文实验思路：将DeepGini与使用现有神经元覆盖标准的基于覆盖的方法进行比较。 从两个方面评估了我们方法的有效性。 首先，我们计算平均故障检测百分比（APFD）[46]的值，这是评估优先级排序技术的标准方法。 其次，我们评估我们的技术是否可以提高DNN的质量。 为此，我们在训练集的前面添加了优先级最高的测试，并将重新训练的DNN的准确性与原始训练进行了比较。</p>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>深度学习和测试优先级的背景知识</p>
</li>
<li><p>Neuron Coverage Criteria（NAC（k），神经元激活覆盖率）<br> 定义为覆盖神经元数量与神经元总数的比率，k值自设，神经元输出值大于k认为它被激活。</p>
</li>
<li><p>k-Multisection Neuron Coverage (KMNC(k)，k-多段神经元覆盖率）<br> 假设神经元的输出位于一个区间[lowo，higho]中，在大多数情况下，单个测试必须覆盖每个神经元的一部分。 只有极少数的测试没有覆盖间隔中的一个部分，而是覆盖了边界，即（-∞，lowo]和[higho，+∞）。（KMNC（k））定义为覆盖部分数与部分总数之比。 因此，几乎所有单个测试的KMNC（k）覆盖率都相同。</p>
</li>
<li><p>Neuron Boundary Coverage (NBC(k)，神经元边界覆盖）<br> 与KMNC（k）不同，NBC（k）并非旨在覆盖[lowo，higho]中的所有部分，而是旨在覆盖（-∞，lowo]和[higho，+∞）的边界。<br> 定义为覆盖边界数与边界总数之比。<br> 度量了给定测试输入集覆盖极端案例区（上边界区和下边界区）的程度。由于每个神经元都有一个上限和一个下限，因此边界总数是神经元数的两倍。</p>
</li>
<li><p>Strong Neuron Activation Coverage (SNAC(k)，强神经元激活覆盖率）<br> 可以看作是NBC(K)的特例。<br> 定义为覆盖上边界的数目与上边界总数的比率，其中上边界总数实际上等于DNN中的神经元数目。</p>
</li>
<li><p>Top-kNeuron Coverage (TKNC(k)，top-k神经元覆盖）<br> 度量的是每一层中成为激活值最大的前k个神经元的数量。<br> 定义为每一层上的前k活跃的神经元的总数与DNN中的神经元总数的比率。<br> 当且仅当神经元输出结果不小于神经元层中第k个最大值时，我们认为这个神经元被这个测试覆盖。<br> 这个度量只能用于将两个测试集与一个以上的测试进行比较。</p>
</li>
<li><p>Likelihood- and Distance-based Surprise Coverage (LSC(k)and DSC(k)，基于可能性和距离的意外覆盖）</p>
<ul>
<li><p>SA: 意外充分性(Surprise Adequacy )<br>  衡量新用例相对于训练集中用例的多样性程度.指标越大分类器越容易分错。<br>  SA旨在衡量<strong>给定新输入</strong>相对于<strong>用于训练的输入</strong>的相对新颖性,是DL系统如何对未知输入做出反应的指标。<br>  两种计算方法：<br>  · LSA: 基于可能性的SA (Likelihood-based Surprise Adequacy)<br>  采用核密度估计（KDE）来获得输入数据的分布密度函数。在选定Nl层后,对于所有的训练集中的用例,每个用例使用核函数计算该用例与新输入x的激活迹的差值。<br>  概率密度降低了,证明输入更加稀有,概率密度增高了,证明输入更加相似。<br>  · DSA: 基于距离的SA (Distance-based Surprise Adequacy)</p>
</li>
<li><p>SC: 意外覆盖率 (Surprise Coverage)<br>被覆盖的段数除以总段数<br>一组具有较高SC的输入是一组多样化的输入    </p>
</li>
</ul>
</li>
<li><p>基于覆盖率的测试优先级<br> · 覆盖率的尽早最大化将导致早期发现故障。</p>
<ul>
<li>Coverage-Total Method (CTM)：<br>· 总是选择覆盖率最高的测试<br>· O（nlogn）<ul>
<li>Coverage-Additional Method (CAM)<br>· 根据先前选择的反馈选择下一个测试。<br>· 选择一个可以覆盖更多未发现的代码结构的测试。<br>· 在达到最大覆盖率之后，我们可以使用CTM对其余未优先测试进行  优先级排序。<font color=#FF9000 >ACDB为什么不行？</font><br>· O(mn^2)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h3><p>对测试进行优先排序的方法及其在提高DNN质量方面的应用</p>
<ol>
<li><p>两次随机取样有不同结果的概率如下，概率越低，纯度越高。<br><img src="https://img-blog.csdnimg.cn/20200629182257282.png" alt="在这里插入图片描述"></p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/20200629182426943.png" alt="在这里插入图片描述"></p>
</li>
<li><p>即使DNN将输入测试分成两个以上的类，ξ也具有类似的分布：</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2020062918170837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_2,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    · ξ（t1）&gt;ξ（t2）暗示t1更有可能被错误分类。 因此，对于一组优先测试，我们需要运行测试以收集输出，然后根据ξ的值对这些测试排序。<br>    · 假设我们有四个测试A、B、C和D，DNN试图将它们分类为三个类别。 表2显示了它们的输出向量和ξ的值。 根据ξ的值，我们可以对测试ABCD进行优先排序。<br>    <img src="https://img-blog.csdnimg.cn/20200629181801338.png" alt="在这里插入图片描述"><br>4. 一般情况下，我们可以在训练集上增加更多的测试，并重新训练DNN以增强其鲁棒性。DeepGini可在有限的时间预算内增强DNN健壮性。因为DeepGini在前面优先处理的测试比在后面优先处理的测试更能有效地提高DNN质量，而且比在前端优先但基于覆盖的优先技术更能有效地提高DNN的质量。<br>    DeepGini有效性背后的原理实际上遵循了主动机器学习的理论，它倾向于在决策边界附近的测试。</p>
<h3 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h3><ol>
<li>实现了我们的方法以及各种基于神经元覆盖的测试优先级排序方法。<a href="https://github.com/deepgini/deepgini" target="_blank" rel="noopener">https://github.com/deepgini/deepgini</a></li>
<li>每个比较实验都在四个模式下进行，涉及两个方面：（1）使用CTM或CAM对测试进行优先级排序；和（2）在原始数据集中对测试进行优先级排序或对结合原始测试和对抗性测试的测试进行优先级排序</li>
<li>DeepGini是否可以找到比基于神经元覆盖的方法更好的测试排列？<br> 计算故障检测平均百分比（APFD）， 较高的APFD值表示更快的误分类检测率</li>
<li>DeepGini比基于神经元覆盖的方法更有效吗？<br> 通过记录优先排序的时间成本来提供答案。某些优先级排序方法无法在数小时内完成，这在工业环境中不可行。<font color=#FF9000 >跟题目有什么关系？</font></li>
<li>DeepGini可以指导DNN的再培训以提高其准确性吗？<br> 利用对抗测试来回答。测试集T和验证集V，我们将前1％，2％，··，10％的测试加回到训练集中，并重新训练新的DNN。我们不会添加超过50％的测试来重新训练DNN， 因为我们观察到DNN的准确性不会随着更多测试而发生显着变化。使用V，我们计算新DNN的准确性。答案是可以。</li>
</ol>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>介绍了测试优先级排序（RQ1和RQ2）的结果，然后分析了我们的方法是否可以更好地指导DNN的再训练（RQ3）。</p>
<ol>
<li><p>我们将DeepGini的结果与现有的两组基于覆盖的方法：（1）NAC，NBC和SNAC； （2）TKNC，LSC，DSC和KMNC</p>
</li>
<li><p>结果：<br> <strong>（效力和效率 问题1，2）</strong><br> • DeepGini能够在2秒内确定成千上万次测试的优先级<br> • DeepGini的APFD故障检测平均百分比非常接近1</p>
</li>
</ol>
<p><strong>第一组：NAC，NBC，SNAC</strong><br>    • 不足0.5％的测试足以达到以下三个覆盖率标准的最大覆盖率，无论其参数设置如何：NAC，NBC和SNAC<br>    • 在MNIST的10,000个原始测试中，非常少量的测试就足以实现最大覆盖率：NAC（0.75），22个测试可以达到最大覆盖率（84％）；NBC（0.5），有5个测试可以达到最大覆盖率（0.97％）； SNAC（0.5），有5个测试可以达到最大覆盖率（2％）。由于我们可以很快达到最大覆盖率，因此CAM将很快退化为CTM，因此，对于这些数据集，CAM的有效性和效率几乎与CTM相同。<br>效力：图四绘制了检测到的错误分类测试的百分比（y轴）与优先级​​测试百分比（x轴）的对比。<br>    • 首先，与NAC，NBC和SNAC相比，DeepGini获得了更高的APFD值。<br>    • 其次，如图4中的虚线所示，基于神经元覆盖的优先级排序方法，有时甚至比随机优先级策略还差。<br>效率：表5<br>    • 对于原始测试集，NAC，NBC和SNAC基于CAM的优先级排序过程分别花费至少2、5、7秒，而DeepGini仅花费0.45秒。<br>    •  类似地，对于带有对抗性示例的测试集，我们发现三个基线的基于CAM的优先级排序过程花费了超过11秒的时间，而DeepGini仅花费了2秒的时间。<br>    • 这些数据表明DeepGini与NAC，NBC和SNAC相比具有更高的效率<br><strong>第二组：TKNC，LSC，DSC，KMNC</strong><br>    • 每个测试的TKNC，LSC和DSC覆盖率均相同，而与参数k无关<br>    • 因此，如果我们使用这些覆盖率指标对测试进行优先级排序，则⭐CTM无法正常工作（5.1.2节）CTM本来就是按照覆盖率的大小进行优先级排序的，覆盖率相同了就无法排序了。 不幸的是，使用这些覆盖率指标，CAM也无法很好地工作。 主要原因是少于5％的测试足以实现最大覆盖率。 在对5％的测试进行优先级排序后，CAM会退化为CTM，无法按照上述说明进行操作。<br>    • 如果我们使用KMNC来对测试进行优先级排序，则CTM无法正常工作，因为几乎所有单个测试都具有相同的KMNC覆盖率，而与参数k无关。 但是，KMNC可以使用CAM优先级排序方法。 因此，我们仅将基于KMNC的CAM与我们的优先级方法进行比较：<br>效力：<br>    • DeepGini在优先测试的有效性方面明显优于四个基准<br>效率：<br>    • 表5显示，基于这些覆盖率指标的优先级排序方法比我们的方法慢20倍-2000倍</p>
<pre><code>**（问题3）**
图5-a和图5-b展示了LeNet-5在MNIST上的结果。 曲线显示了再训练后DNN的准确性
 在表6中，我们用前10％的优先测试对DNN进行了重新训练后，还提供了精度值。从表中可以看出，虽然基线标准可以达到0.83-0.85的准确度，但DeepGini可以将准确度值提高到0.96。</code></pre><p>对于其中一些标准，我们观察到原始测试的很小一部分（约1％至5％）足以实现最大覆盖率。覆盖率标准无法区分不同的测试。在我们的实验中，随机优先排序策略甚至优于NAC和TKNC，这意味着这些覆盖标准可能会误导发现新的错误DNN行为。<br>KMNC标准在有效性和效率方面都未能很好地发挥作用。 还需要进行更多的研究，以探索其潜力和改进之处。</p>
]]></content>
      <categories>
        <category>大创</category>
        <category>DNNs测试</category>
      </categories>
      <tags>
        <tag>论文导读</tag>
        <tag>大创</tag>
        <tag>DNNs测试</tag>
      </tags>
  </entry>
  <entry>
    <title>进程 线程 纤程</title>
    <url>/2020/09/22/%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E7%BA%A4%E7%A8%8B/</url>
    <content><![CDATA[<p>进程和线程有什么区别？<br><img src="https://img-blog.csdnimg.cn/20200922160346478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>答案：进程就是一个程序运行起来的状态，线程是一个进程中的不同的执行路径。<br>专业版：进程是OS分配资源的基本单位，线程是执行调度的基本单位。分配资源最重要的是：独立的内存空间，线程调度执行（<strong>线程共享进程的内存空间</strong>，没有自己独立的内存空间）</p>
<p><img src="https://img-blog.csdnimg.cn/20200922160312873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>理论上，一个程序是可以启动多个进程的。例如，点击QQ，内存中创建一个进程。再点击一次，再创建一个。</p>
<p>不同的进程会被OS分配到一些资源。例如占有的寄存器和PC，不过最重要的资源是自己独立的内存地址空间。</p>
<p>进程到内存后，CPU开始读内存指令。把指令拿过来放到PC中，一条条执行。<br>进程放到内存后，main函数所在的地方，是启动点。那是我们的主线程。一旦开始执行后，一个进程里面可能有其他不同的线程，到底执行哪个线程，就需要CPU进行调度。</p>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>不同的操作系统，线程的实现不太一样。</p>
<p>在Linux里实现：<br>就是一个普通的进程，只不过与其他进程共享资源（内存空间，全局数据等）</p>
<p>在其它系统都有LWP的实现（轻量级进程 Light Weight Process）</p>
<p>从更高层面理解：一个进程中不同的执行路线，就叫做一个线程。</p>
<h2 id="纤程（协程）"><a href="#纤程（协程）" class="headerlink" title="纤程（协程）"></a>纤程（协程）</h2><p>JVM跑在用户态，OS跑在内核态。JVM的线程和OS的线程是一一对应的。（即目前Hotspot目前是一对一）一般起一万个都很卡了。</p>
<p>Fiber：用户态的线程。线程里面的线程。在用户空间进行切换调度，不需要与OS打交道，只需要在自己的用户空间就可以完成。JVM自己管理，自己切换。起几万个，几十万个都没问题。<br><img src="https://img-blog.csdnimg.cn/20200922160422310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4MjI3OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>优势</strong>：</p>
<ol>
<li>占有资源很少 OS要起一个线程，首先1M内存就被占用了。 而Fiber只需要4K </li>
<li>切换比较简单 </li>
<li>由于非常轻量级，可以启动很多个<code>10W+</code></li>
</ol>
<p>目前2020/3/22 自然而然支持内置纤程的<strong>语言</strong>：Kotlin Scala Go Python(加上某个lib)… Java？（open jdk : loom项目在做尝试）<br>JAVA在类库级别可以支持，不成熟</p>
<p>JDK14没有纤程</p>
<p>具体实现：相当于JVM自己实现了小小的OS级别的调度程序。</p>
<h4 id="Java中对于纤程的支持：没有内置，盼望内置"><a href="#Java中对于纤程的支持：没有内置，盼望内置" class="headerlink" title="Java中对于纤程的支持：没有内置，盼望内置"></a>Java中对于纤程的支持：没有内置，盼望内置</h4><p>利用Quaser库（不成熟）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> co.paralleluniverse.fibers.Fiber;</span><br><span class="line"><span class="keyword">import</span> co.paralleluniverse.fibers.SuspendExecution;</span><br><span class="line"><span class="keyword">import</span> co.paralleluniverse.strands.SuspendableRunnable;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 线程版 6秒左右</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFiber</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                calc(); <span class="comment">// 做一个复杂计算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 10000万个任务</span></span><br><span class="line">​        <span class="comment">// 在os系统级别起了1万多个线程（重量级切换）</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">10000</span>;</span><br><span class="line">​</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">10000</span>; m++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) result += i;</span><br><span class="line">​</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> co.paralleluniverse.fibers.Fiber;</span><br><span class="line"><span class="keyword">import</span> co.paralleluniverse.fibers.SuspendExecution;</span><br><span class="line"><span class="keyword">import</span> co.paralleluniverse.strands.SuspendableRunnable;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 纤程版 3秒左右</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFiber2</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">10000</span>;</span><br><span class="line">​       <span class="comment">// void代表没有返回值</span></span><br><span class="line">        Fiber&lt;Void&gt;[] fibers = <span class="keyword">new</span> Fiber[size]; </span><br><span class="line">        </span><br><span class="line">​       </span><br><span class="line">        <span class="comment">// 纤程启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fibers.length; i++) &#123;</span><br><span class="line">            fibers[i] = <span class="keyword">new</span> Fiber&lt;Void&gt;(<span class="keyword">new</span> SuspendableRunnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> SuspendExecution, InterruptedException </span>&#123;</span><br><span class="line">                    calc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fibers.length; i++) &#123;</span><br><span class="line">            fibers[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fibers.length; i++) &#123;</span><br><span class="line">            fibers[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">10000</span>; m++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) result += i;</span><br><span class="line">​</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好模型可以起10个线程，然后每个线程执行1000个任务。这样既利用了操作系统在内核级别的对线程的调度，又充分利用了JVM在用户空间对纤程的调度。</p>
<h3 id="纤程的应用场景"><a href="#纤程的应用场景" class="headerlink" title="纤程的应用场景"></a>纤程的应用场景</h3><p>纤程vs线程池：很短的计算任务，不需要和内核打交道（比如不需要读文件等），并发量高</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>linux中也称task，是系统分配资源的基本单位。<br>资源包括：独立地址空间、内核数据结构（PCB…）、全局变量、数据段…<br>每一个进程有一个<strong>PCB</strong>（Process Control Block，进程描述符）<br>Linux管理时，把所有相应信息都记录到PCB表中。大小不固定</p>
<p>注：每一个线程也都有一个PCB</p>
<p><font color = red>内核线程</font>：内核启动后经常要做一些后台操作，比如计时，定期清理垃圾，这些由Kernel Tread完成。就是内核内部所使用的线程。</p>
<h3 id="进程创建和启动"><a href="#进程创建和启动" class="headerlink" title="进程创建和启动"></a>进程创建和启动</h3><p>系统函数fork() exec()<br>内核暴露出来的接口，我们对其进行调用，来让内核帮我们干一些事情，就是系统函数。<br>从A中fork B，A为B的父进程。</p>
<h3 id="僵尸进程-孤儿进程"><a href="#僵尸进程-孤儿进程" class="headerlink" title="僵尸进程 孤儿进程"></a>僵尸进程 孤儿进程</h3><p><strong>僵尸进程</strong>：父进程产生子进程后，会维护子进程的PCB结构。子进程退出，由父进程释放。但如果父进程没有释放，那么子进程就成为一个僵尸进程。<defunct><br>一般情况没有什么影响。结束后相关资源已经都释放了，基本不再占资源，<strong>唯一占的资源就是PCB</strong>了。</p>
<p>C程序用wait()函数可以手动释放<br>kill掉父进程，就可以一起干掉僵尸进程</p>
<p>下面的例子就会产生僵尸进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123; <span class="comment">// 执行在子进程中</span></span><br><span class="line">                <span class="comment">// getpid()获得该进程的编号</span></span><br><span class="line">                <span class="comment">// getppid()获得该进程父进程的编号</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"child id is %d\n"</span>, getpid());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"parent id is %d\n"</span>, getppid());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>孤儿进程</strong>：子进程结束前，父进程已经退出</p>
<p>一般情况下，会把孤儿进程都交给一个特殊进程（命令行底下一般是init进程 1号）处理。</p>
<p>影响不大。换了个爹。</p>
<p>下面的例子就会产生孤儿进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A fork 出一个B</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"child ppid is %d\n"</span>, getppid());</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"parent ppid is %d\n"</span>, getppid());<span class="comment">// 此时已经换爹</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"parent id is %d\n"</span>, getpid());</span><br><span class="line">                sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 父亲A打印编号5s后死亡</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：<br>child ppid is 19071<br>parent id is 19071<br>parent ppid is 1457</p>
<p>注：</p>
<ul>
<li>1457是UI界面（图形界面）孤儿的爹。如果UI界面都死了，那么就变成1号了</li>
<li>1457的父亲是1</li>
</ul>
<h2 id="进程（任务）调度"><a href="#进程（任务）调度" class="headerlink" title="进程（任务）调度"></a>进程（任务）调度</h2><blockquote>
<p>内核进程调度器决定：<br>该哪个进程运行？<br>何时开始？<br>运行多长时间？</p>
</blockquote>
<p>Linux中每个进程都可以指定不同的调度方案(可以自己写)</p>
<p><strong>多任务</strong><br>非抢占式（cooperative multitasking）：除非进程主动让出CPU，否则将一直运行。（很少用）<br>抢占式（preemtive multitasking）：由进程调度器强制开始或暂停（抢占）某一进程的执行。</p>
<p><strong>进程调度</strong><br>Linux2.5 经典Unix O(1)调度策略，偏向服务器，但对UI交互不友好。平均分配时间片，不能及时响应。</p>
<p>Linux2.6.23 采用CFS完全公平调度算法Completely Fair Scheduler<br>不再采用绝对时间片。因为有的进程不需要那么多时间。而是按优先级分配时间片的比例，记录每个进程的执行时间，如果有一个进程执行时间不到他应该分配的比例，优先执行（计算原来执行的时间片）</p>
<p><strong>进程类型</strong>：<br>IO密集型 大部分时间用于等待IO<br>CPU密集型 大部分时间用于闷头计算<br>（时间片先给CPU密集型，什么时候IO来了，马上给它执行）</p>
<p><strong>进程优先级</strong>：<br>实时进程 &gt; 普通进程（0<del>99）<br>普通进程nice值（-20</del>19）</p>
<p><strong>linux默认调度策略</strong>：<br>对于实时进程：使用<code>SCHED_FIFO</code> 和 <code>SCHED_RR</code>（Round Robin轮询）<br>对于普通进程：使用CFS</p>
<ul>
<li>其中等级最高的是FIFO。如果一个进程中一个优先级是99，一个是98。99的是先进先出，那么执行完了才轮到98.这种进程除非自己让出CPU，或者更高级的FIFO和RR抢占它。</li>
<li>两个进程优先级一样的进程，使用RR策略。平均分配。</li>
<li>只有<font color = red>实时进程</font>主动让出，或执行完毕，普通进程才有机会运行。</li>
</ul>
<p>（类似急诊和普通号。急诊中，有非常严重的，用FIFO，按严重程度顺序进行，除非前一个主动放弃，可以让出医生资源。不是特别严重的，严重程度相同，采用RR策略。急诊都结束，才进行普通号就诊，CFS策略）</p>
]]></content>
      <categories>
        <category>硬件基础知识</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>OS</tag>
        <tag>进程</tag>
        <tag>纤程</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】spawn failed错误解决</title>
    <url>/2021/03/15/%E3%80%90hexo%E3%80%91spawnfailed%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>先是出现错误：<br>error：spawn failed…<br>然后经过一些博客的操作会出现以下问题：<br>fatal: cannot lock ref ‘HEAD’: unable to resolve reference HEAD: Invalid argument error: src refspec<br>或者：<br>error: src refspec HEAD does not match any.等等<br>总结一下：<br>问题大多是因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容。</p>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>删除.deploy_git文件夹;<br>输入git config –global core.autocrlf false<br>然后，依次执行：<br>hexo clean<br>hexo g<br>hexo d<br>问题解决。</p>
<p>参考：<a href="https://blog.csdn.net/HTL2018/article/details/106876940" target="_blank" rel="noopener">https://blog.csdn.net/HTL2018/article/details/106876940</a></p>
]]></content>
      <categories>
        <category>踩坑</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
